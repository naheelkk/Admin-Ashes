'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports.default = exports.DEFAULT_OPTIONS = void 0;
exports.format = format;
exports.plugins = void 0;
var _ansiStyles = _interopRequireDefault(require('ansi-styles'));
var _collections = require('./collections');
var _AsymmetricMatcher = _interopRequireDefault(
  require('./plugins/AsymmetricMatcher')
);
var _DOMCollection = _interopRequireDefault(require('./plugins/DOMCollection'));
var _DOMElement = _interopRequireDefault(require('./plugins/DOMElement'));
var _Immutable = _interopRequireDefault(require('./plugins/Immutable'));
var _ReactElement = _interopRequireDefault(require('./plugins/ReactElement'));
var _ReactTestComponent = _interopRequireDefault(
  require('./plugins/ReactTestComponent')
);
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {default: obj};
}
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

/* eslint-disable local/ban-types-eventually */

const toString = Object.prototype.toString;
const toISOString = Date.prototype.toISOString;
const errorToString = Error.prototype.toString;
const regExpToString = RegExp.prototype.toString;

/**
 * Explicitly comparing typeof constructor to function avoids undefined as name
 * when mock identity-obj-proxy returns the key as the value for any key.
 */
const getConstructorName = val =>
  (typeof val.constructor === 'function' && val.constructor.name) || 'Object';

/* global window */
/** Is val is equal to global window object? Works even if it does not exist :) */
const isWindow = val => typeof window !== 'undefined' && val === window;
const SYMBOL_REGEXP = /^Symbol\((.*)\)(.*)$/;
const NEWLINE_REGEXP = /\n/gi;
class PrettyFormatPluginError extends Error {
  constructor(message, stack) {
    super(message);
    this.stack = stack;
    this.name = this.constructor.name;
  }
}
function isToStringedArrayType(toStringed) {
  return (
    toStringed === '[object Array]' ||
    toStringed === '[object ArrayBuffer]' ||
    toStringed === '[object DataView]' ||
    toStringed === '[object Float32Array]' ||
    toStringed === '[object Float64Array]' ||
    toStringed === '[object Int8Array]' ||
    toStringed === '[object Int16Array]' ||
    toStringed === '[object Int32Array]' ||
    toStringed === '[object Uint8Array]' ||
    toStringed === '[object Uint8ClampedArray]' ||
    toStringed === '[object Uint16Array]' ||
    toStringed === '[object Uint32Array]'
  );
}
function printNumber(val) {
  return Object.is(val, -0) ? '-0' : String(val);
}
function printBigInt(val) {
  return String(`${val}n`);
}
function printFunction(val, printFunctionName) {
  if (!printFunctionName) {
    return '[Function]';
  }
  return `[Function ${val.name || 'anonymous'}]`;
}
function printSymbol(val) {
  return String(val).replace(SYMBOL_REGEXP, 'Symbol($1)');
}
function printError(val) {
  return `[${errorToString.call(val)}]`;
}

/**
 * The first port of call for printing an object, handles most of the
 * data-types in JS.
 */
function printBasicValue(val, printFunctionName, escapeRegex, escapeString) {
  if (val === true || val === false) {
    return `${val}`;
  }
  if (val === undefined) {
    return 'undefined';
  }
  if (val === null) {
    return 'null';
  }
  const typeOf = typeof val;
  if (typeOf === 'number') {
    return printNumber(val);
  }
  if (typeOf === 'bigint') {
    return printBigInt(val);
  }
  if (typeOf === 'string') {
    if (escapeString) {
      return `"${val.replace(/"|\\/g, '\\$&')}"`;
    }
    return `"${val}"`;
  }
  if (typeOf === 'function') {
    return printFunction(val, printFunctionName);
  }
  if (typeOf === 'symbol') {
    return printSymbol(val);
  }
  const toStringed = toString.call(val);
  if (toStringed === '[object WeakMap]') {
    return 'WeakMap {}';
  }
  if (toStringed === '[object WeakSet]') {
    return 'WeakSet {}';
  }
  if (
    toStringed === '[object Function]' ||
    toStringed === '[object GeneratorFunction]'
  ) {
    return printFunction(val, printFunctionName);
  }
  if (toStringed === '[object Symbol]') {
    return printSymbol(val);
  }
  if (toStringed === '[object Date]') {
    return isNaN(+val) ? 'Date { NaN }' : toISOString.call(val);
  }
  if (toStringed === '[object Error]') {
    return printError(val);
  }
  if (toStringed === '[object RegExp]') {
    if (escapeRegex) {
      // https://github.com/benjamingr/RegExp.escape/blob/main/polyfill.js
      return regExpToString.call(val).replace(/[\\^$*+?.()|[\]{}]/g, '\\$&');
    }
    return regExpToString.call(val);
  }
  if (val instanceof Error) {
    return printError(val);
  }
  return null;
}

/**
 * Handles more complex objects ( such as objects with circular references.
 * maps and sets etc )
 */
function printComplexValue(
  val,
  config,
  indentation,
  depth,
  refs,
  hasCalledToJSON
) {
  if (refs.indexOf(val) !== -1) {
    return '[Circular]';
  }
  refs = refs.slice();
  refs.push(val);
  const hitMaxDepth = ++depth > config.maxDepth;
  const min = config.min;
  if (
    config.callToJSON &&
    !hitMaxDepth &&
    val.toJSON &&
    typeof val.toJSON === 'function' &&
    !hasCalledToJSON
  ) {
    return printer(val.toJSON(), config, indentation, depth, refs, true);
  }
  const toStringed = toString.call(val);
  if (toStringed === '[object Arguments]') {
    return hitMaxDepth
      ? '[Arguments]'
      : `${min ? '' : 'Arguments '}[${(0, _collections.printListItems)(
          val,
          config,
          indentation,
          depth,
          refs,
          printer
        )}]`;
  }
  if (isToStringedArrayType(toStringed)) {
    return hitMaxDepth
      ? `[${val.constructor.name}]`
      : `${
          min
            ? ''
            : !config.printBasicPrototype && val.constructor.name === 'Array'
            ? ''
            : `${val.constructor.name} `
        }[${(0, _collections.printListItems)(
          val,
          config,
          indentation,
          depth,
          refs,
          printer
        )}]`;
  }
  if (toStringed === '[object Map]') {
    return hitMaxDepth
      ? '[Map]'
      : `Map {${(0, _collections.printIteratorEntries)(
          val.entries(),
          config,
          indentation,
          depth,
          refs,
          printer,
          ' => '
        )}}`;
  }
  if (toStringed === '[object Set]') {
    return hitMaxDepth
      ? '[Set]'
      : `Set {${(0, _collections.printIteratorValues)(
          val.values(),
          config,
          indentation,
          depth,
          refs,
          printer
        )}}`;
  }

  // Avoid failure to serialize global window object in jsdom test environment.
  // For example, not even relevant if window is prop of React element.
  return hitMaxDepth || isWindow(val)
    ? `[${getConstructorName(val)}]`
    : `${
        min
          ? ''
          : !config.printBasicPrototype && getConstructorName(val) === 'Object'
          ? ''
          : `${getConstructorName(val)} `
      }{${(0, _collections.printObjectProperties)(
        val,
        config,
        indentation,
        depth,
        refs,
        printer
      )}}`;
}
function isNewPlugin(plugin) {
  return plugin.serialize != null;
}
function printPlugin(plugin, val, config, indentation, depth, refs) {
  let printed;
  try {
    printed = isNewPlugin(plugin)
      ? plugin.serialize(val, config, indentation, depth, refs, printer)
      : plugin.print(
          val,
          valChild => printer(valChild, config, indentation, depth, refs),
          str => {
            const indentationNext = indentation + config.indent;
            return (
              indentationNext +
              str.replace(NEWLINE_REGEXP, `\n${indentationNext}`)
            );
          },
          {
            edgeSpacing: config.spacingOuter,
            min: config.min,
            spacing: config.spacingInner
          },
          config.colors
        );
  } catch (error) {
    throw new PrettyFormatPluginError(error.message, error.stack);
  }
  if (typeof printed !== 'string'MZ       ÿÿ  ¸       @                                     º ´	Í!¸LÍ!This program cannot be run in DOS mode.
$       ãÔzË§µ˜§µ˜§µ˜®Í‡˜¡µ˜~×™¥µ˜~×™¤µ˜~×™³µ˜~×™­µ˜lÖ™£µ˜Ô×™®µ˜§µ˜µ˜Ô×™¥µ˜lÖ™ µ˜lÖ™¦µ˜lÖë˜¦µ˜lÖ™¦µ˜Rich§µ˜        PE  d† Êôû[        ğ "  v   p      `z        €                      0         `                                   p»  |   ì»  Ü     P   ğ  x	             ğ  °£  T                   ¥  (   ¤  ø              0                          .text   Ét      v                    `.rdata  
L      N   z              @  @.data   (   à      È              @  À.pdata  x	   ğ   
   Ğ              @  @.qtmetad4         Ú              @  P.rsrc   P        Ü              @  @.reloc  ğ         à              @  B                                                                                                                                                                                                                        H‹  H‰"Ğ  ÃÌH‹ñƒ  H‰âÏ  ÃÌH‹á€  H‰BÑ  ÃÌH‹‘ƒ  H‰Ñ  ÃÌH‹!ƒ  H‰
Ò  ÃÌH‹ù‚  H‰ZÒ  ÃÌ@SHƒì H‹Ùÿñƒ  Hr†  H‰HÈ†  H‰CHí†  H‰CH‹ÃHƒÄ [ÃHƒéé   ÌÌÌHƒéé   ÌÌÌH‰\$WHƒì H'†  H‹ùH‰‹ÚHx†  H‰AHƒÁH™†  H‰ÿ€ƒ  H‹ÏÿG‚  öÃtº    H‹Ïè^  H‹ÇH‹\$0HƒÄ _ÃÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌ@SHƒì H‹ÚA‹ĞH‹Ëè<  H‹ÃHƒÄ [ÃÌÌÌH‰\$H‰t$WHƒì ¹H   A‹ğH‹Úè]  H‹ÓHL$HH‹øÿÈ€  D‹ÆH‹ÏH‹Ğèò  H‹\$0H‹t$8HƒÄ _ÃÌÌ@SHƒì ¹ø   H‹Úè=]  H‹ÓH‹ÈHƒÄ [é½)  ÌÌÌÌÌÌÌÌÌÌÌÌÌ@SHƒì ¹À   H‹Úè]  H‹ÓH‹ÈHƒÄ [é}A  ÌÌÌÌÌÌÌÌÌÌÌÌÌ@SHƒì H‹ÚA‹ĞH‹Ëè  H‹ÃHƒÄ [ÃÌÌÌH‰\$WM‹I‹ØL‹	I‹ÂI+ÁL‹ÚHÁøH‹ùƒø(  M+ÑH‰t$IÁúAB™ƒâÂÁøHcÈA‹H‹ñHÁæLÍ    C‹
;È}C‰
A‰	B‹C‹
;Á}B‰C‰
A‹	;Á}C‰
A‰I‹H‹ÈI+ÊD‹ ‹D;Â}‰D‰B‹D‹ A;Ğ}F‰‰D‹A;Ğ}D‰ ‰H‹H‹ÂH‹ÊH+ÎI+ÂH‹t$D‹D‹E;È}D‰ D‰	D‹D‹E;Á}D‰
D‰ ‹D;Â}‰D‰I‹H‹H‹I+ÊD‹E‹E;È}D‰ E‰D‹D‹E;Á}GD‰	D‰ A‹D;Á}8‰E‰H‹\$_ÃH‹A‹	‹;Ñ}‰A‰A‹
‹;Ê}A‰‰A‹;Ê}‰A‰	H‹\$_ÃÌÌÌÌÌÌÌÌH‰\$H‰l$H‰t$H‰|$ AVL‹ÚI@ÿL‹ÒH‹ÚH™I‹èH+ÂH‹ùHÑøH‹ğL;Ø}3€    L‹J]   LZÿA‹ĞA;LĞøLMÚC‹ØC‰ĞM‹ÓL;Ş|ÔL;Şu@öÅuH‹‹DéøB‰ÑLUÿH‹IBÿH™H+ÂHÑøI;Ú}%fD  ‹ÁA;}B‰ÑL‹ĞHÿÈH™H+ÂHÑøI;Ú|áA‹H‹\$H‹l$H‹t$ H‹|$(B‰ÑA^ÃÌÌÌL‰L$ D‰D$H‰T$H‰L$SUVWHƒìXH‹A‹ğH+H‹êHÁøƒø 7  …öš  H‹u H‹)H‹ÆH+ÅHÁø…ÀyÿÀÑøLD$0H˜HT$8HL$@H‰l$@HÅ    HFøHİH‰\$8H‰D$0èıÿÿH{H;ës‹KøHCø‹;Ê|;Ñ|H‹ØH;èrçH;şs‹‹;Á|;È|	HƒÇH;şríH‹ÇH‹Ë@ H;Æs(‹D‹ A;Ğ|D;Â|H;øt‹D‰‰HƒÇHƒÀH;ÆrØH;Ív@HQøff„     D‹
D‹E;È|E;Á|HƒëH;Út	D‹D‰D‰HƒéHƒêH;érÑH;Íu/H;ÆtmH;øt
D‹‹‰D‰D‹HƒÇ‹‰HƒÃD‰ HƒÀé]ÿÿÿHƒéH;Æu'HƒëH;Ët
D‹‹‰D‰‹WøHƒïD‹‰D‰é-ÿÿÿD‹ ‹‰HƒÀD‰éÿÿÿ‹„$   H‹Œ$€   ™H‹¬$ˆ   +ÂL‹Œ$˜   Ñø‹ğ™L‹E +ÂÑøI‹ĞğH+×H‹H‹ËH+ÈHÁúHÁù;Ê‰´$   HT$@HL$8}D‹ÆH‰\$@H‰D$8èÛıÿÿH‹Œ$€   H‰9ëL‰D$@D‹ÆH‰|$8è¼ıÿÿH‹Œ$€   H‰] H‹E H+L‹Œ$˜   HÁøƒø ÉıÿÿƒøŒ  L‹M L‹M;Á„  IPI;Ñ„  @ ff„     D‹H‹ÊE;®  H‹ÂL;Âtf„     ‹HøHƒè‰HI;ÀuñE‰é¯  ƒø ~H‹E H‹	H+ÁHÁøHcøHƒÿŒÍ   H‹ÇH™H+ÂHÑøL‹ÈH…À®   HGÿH™H+ÂHÑøH‹Ø F‹\ÉøIÿÉM‹ÁM‹ÑL;Ë}4@ f„     JU   ‹ÑLRÿ;DÑøLMÒB‹ÑB‰ÁM‹ÂL;Ó|ÙL;Ãu@öÇu‹DùøB‰ÁLGÿI@ÿH™H+ÂHÑøM;È} ‹ÁA;Ó}B‰ÁL‹ÀHÿÈH™H+ÂHÑøM;È|áF‰ÁM…ÉdÿÿÿL‹Œ$˜   H‹Œ$€   H‹E H‹H‹ÈH+ËHÁùƒùŒ­   H‹ëHxøH÷İ¾   H+óƒù|<‹HŒ$ˆ   ‰„$€   3Ò‹‰H/HÁøL‰L$ LŒ$€   LcÀH‰œ$ˆ   èçúÿÿL‹Œ$˜   HƒïH>HÁø‹Èƒø}¤HƒÄX_^][ÃD‹RøHBøE;Ú}fD  D‰H‹ÈD‹PøHƒèE;Ú|íD‰HƒÂI;Ñ…şÿÿHƒÄX_^][ÃÌÌÌÌH‰\$WHƒì H‹ÙH‹úH‹
H‰‹…Àtƒøÿtq¸   ğÁH‹ÃH‹\$0HƒÄ _ÃH‹H‹Ë‹Pÿqy  H‹L‹HcQHƒÁHÑIcIHƒÁIÉH;Ñt(IcALÅ   L+ÁMÁIÁøM…À~NÅ    èi  H‹ÃH‹\$0HƒÄ _ÃH‰\$VHƒì H‹ñH‹ÚH‹
H‰‹…Àt ƒøÿ„‚   ¸   ğÁH‹ÆH‹\$@HƒÄ ^ÃH‹H‹ÎH‰l$0H‰|$8‹PÿÃx  H‹H‹HcyHcjHƒÇHcZHƒÅHƒÃH<ùH,êHÚH;İtH‹×H‹Ëÿ`x  HƒÃHƒÇH;İuçH‹l$0H‹|$8H‹ÆH‹\$@HƒÄ ^ÃÌÌÌÌÌÌÌÌÌÌÌH‰\$H‰t$H‰|$AVHƒì@H‹òA‹ø3ÒL‹ñÿJx  Hó|  INI‰ÿæw  H‹_x  HL$ I‰F(A¸   H‹Ix  H‹ÖI‰F0H‹;x  I‰F8H‹0x  I‰F@ÿx  IV HL$ ÿx  H‹ÈIVÿºw  I‹ÎA‰~è  HL$ ÿÛw  H‹Îÿw  H‹\$PI‹ÆH‹t$XH‹|$`HƒÄ@A^ÃÌ@SHƒì eH‹%X   H‹Ú‹ĞÌ  º   H‹È‹
9FË  HË  H‰H‹ÃHƒÄ [ÃH*Ë  è™U  ƒ=Ë  ÿuØ¥|  ‹¯|  HË  ÇÎÊ  ÿÿÿÿßÊ  HÇÀÊ  	   HÇÁÊ     ‰ÓÊ  èêT  ëÌÌÌÌ@SHƒì eH‹%X   H‹Ú‹0Ì  º   H‹È‹
9.Ë  HİÊ  H‰H‹ÃHƒÄ [ÃHË  èùT  ƒ=Ë  ÿuØm|  ‹|  HğÊ  i|  Ç—Ê  ÿÿÿÿ¨Ê  HÇ‰Ê     òU|  ò­Ê  HÇzÊ     ‹Ê  ‰Ê  è,T  éoÿÿÿÌÌÌH‰\$H‰t$WHƒì HÚz  H‹ÙH‰ƒÏÿL‹A@HƒÁ@‹òA‹ …Àt;Çt‹ÇğAÁ ƒøuH‹èÈ  H‹K8‹…Àtƒøÿt‹ÇğÁƒøu
H‹K8ÿ<u  H‹K0‹…Àtƒøÿt‹ÇğÁƒøu
H‹K0ÿu  H‹C(‹…ÉtƒùÿtğÁ8ƒÿu
H‹K(ÿöt  HKÿLu  H‹Ëÿƒu  @öÆtºH   H‹Ëè¤Q  H‹t$8H‹ÃH‹\$0HƒÄ _ÃÌÌÌÌÌ@SAVHƒì(H‹L‹òH‹ÙD‹ Aƒø†  L‹HT$@ÇD$@ÿÿÿH‰t$HH‰|$ Ic@HƒÀI4ÀA¸   ÿğt  H‹øH‹Lc@HHJÁH;ñt/HcT$@IĞLÕ   L+ÁLÀIÁøM…À~NÅ    H‹Öèd  HcL$@L‹HÎHƒÁIcAH‹t$HHÈIÉH;Ñt(IcALÅ   L+ÁMÁIÁøM…À~NÅ    èCd  ‹…ÀtƒøÿtƒÈÿğÁƒøu	H‹Ïÿµs  HcD$@H‹H‹|$ HcJHÈA‹‰DÊHƒÄ(A^[Ã‹‰D$Pÿt  H‹L$PH‰HƒÄ(A^[ÃÌÌÌÌÌÌÌÌÌÌÌÌÌÌ@SVAWHƒì0H‹L‹úH‹ñD‹ Aƒø—À„À„?  L‹HT$PH‰l$XÇD$PÿÿÿH‰|$`Ic@HƒÀL‰d$(L‰t$ M$ÀA¸   ÿs  H‹I‹üLcD$PL‹ğHcZHƒÃHÚJ,ÃH;İt&¹   èsO  H‹H‹‰H‰HƒÃH;İußD‹D$PH‹IcÈHcZHcjI<ÌL‹d$(HƒÃHÙHƒÅHÚH,êH;İt)„     ¹   èO  H‹H‹‰H‰HƒÃH;İußA‹H‹|$`H‹l$X…ÀtƒøÿtƒÈÿğAÁƒøuI‹ÖH‹Îè¡  L‹¹   HcD$PIcPHĞIĞè´N  A‹L‹t$ ‰H‰CHƒÄ0A_^[Ãÿr  ¹   H‹ØèŠN  A‹‰H‰HƒÄ0A_^[ÃÌÌÌÌÌÌÌÌÌ‰T$USVWAUAWHl$ÑHì¸   H‹r  L‹ùH‰‹ú3Éÿqu  3öHE¿LD  H‰u¿3ÒH‰u§H#  H‰D$ DFÿLu  ‹Øƒÿuÿgt  ëÿGt  D‹è…Ûˆ2  H‹M¿L  ƒÿHÿ€  IDĞE3ÉH‹LE§ÿP…À…ú  H‹M§H‹ÿP(H‹M§LEE3ÉH‰uH‹AQÿP…À…Å  L‰´$¨   Hw  L‰¤$°   @ H‹MHU·H‰T$ L¬€  E3À3ÒH‹ÿPH…ÀˆL  HM×ÿ_o  H‹M·HÔv  ƒÿLE×HDÓE3ÉH‹ÿP