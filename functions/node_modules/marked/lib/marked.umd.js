/**
 * marked v4.3.0 - a markdown parser
 * Copyright (c) 2011-2023, Christopher Jeffrey. (MIT Licensed)
 * https://github.com/markedjs/marked
 */

/**
 * DO NOT EDIT THIS FILE
 * The code in this file is generated from files in ./src/
 */

(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.marked = {}));
})(this, (function (exports) { 'use strict';

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
    }
  }
  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {
      writable: false
    });
    return Constructor;
  }
  function _extends() {
    _extends = Object.assign ? Object.assign.bind() : function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends.apply(this, arguments);
  }
  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }
  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
    return arr2;
  }
  function _createForOfIteratorHelperLoose(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (it) return (it = it.call(o)).next.bind(it);
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;
      return function () {
        if (i >= o.length) return {
          done: true
        };
        return {
          done: false,
          value: o[i++]
        };
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _toPrimitive(input, hint) {
    if (typeof input !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
      var res = prim.call(input, hint || "default");
      if (typeof res !== "object") return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  function _toPropertyKey(arg) {
    var key = _toPrimitive(arg, "string");
    return typeof key === "symbol" ? key : String(key);
  }

  function getDefaults() {
    return {
      async: false,
      baseUrl: null,
      breaks: false,
      extensions: null,
      gfm: true,
      headerIds: true,
      headerPrefix: '',
      highlight: null,
      hooks: null,
      langPrefix: 'language-',
      mangle: true,
      pedantic: false,
      renderer: null,
      sanitize: false,
      sanitizer: null,
      silent: false,
      smartypants: false,
      tokenizer: null,
      walkTokens: null,
      xttom;white-space:nowrap;text-transform:none}.base--dtxF1bBt:hover{background:rgba(0,0,0,.3)}.base--dtxF1bBt:focus{outline:#000 dashed 1px}.base--dtxF1bBt.lightweight--2QYsnMgY{position:relative;border:2px solid transparent;outline:0;padding:10px 12px 11px;background-color:transparent;color:#0067b8}.base--dtxF1bBt.flex--FJozWeUK{width:100%;max-width:100%;white-space:normal}.base--dtxF1bBt.disabled--p38OixhJ{background-color:rgba(0,0,0,.2);color:rgba(0,0,0,.2);cursor:not-allowed}.base--dtxF1bBt.inline--YYe8sl88{font-size:13px;min-width:0;padding:0;text-decoration:underline;border:1px solid transparent}.base--dtxF1bBt.inline--YYe8sl88:focus{border:1px dashed #000;background-color:transparent}.base--dtxF1bBt:before{display:block;position:absolute;top:0;bottom:0;right:0;left:0;content:"";border:1px solid transparent}@media screen and (-ms-high-contrast:active){.base--dtxF1bBt:before{display:block;position:absolute;top:0;bottom:0;right:0;left:0;content:"";border:1px solid transparent}.base--dtxF1bBt:focus:before{border:2px solid ButtonText;top:1px;bottom:1px;right:1px;left:1px}}.base--dtxF1bBt.primary--u50j0J8g{position:relative;border:2px solid transparent;outline:0;max-width:200px;color:#fff;background-color:#0067b8}.base--dtxF1bBt.primary--u50j0J8g:hover{background:#005da6}.base--dtxF1bBt.primary--u50j0J8g:disabled{background-color:rgba(0,0,0,.4);color:#000;cursor:not-allowed;pointer-events:none;opacity:.5;border-color:transparent}.base--AMUfuKVw{font:inherit;position:relative;border:2px solid transparent;outline:0;padding:9px 12px 10px;background-color:rgba(0,0,0,.2);color:#000;min-width:120px;margin:0;display:inline-block;text-align:center;cursor:pointer;overflow:hidden;transition:all .2s ease-in-out;vertical-align:bottom;white-space:nowrap;text-transform:none}.base--AMUfuKVw:hover{background:rgba(0,0,0,.3)}.base--AMUfuKVw:focus{outline:#000 dashed 1px}.base--AMUfuKVw.lightweight--Qndxjco6{position:relative;border:2px solid transparent;outline:0;padding:10px 12px 11px;background-color:transparent;color:#0067b8}.base--AMUfuKVw.flex--rWHWZJ82{width:100%;max-width:100%;white-space:normal}.base--AMUfuKVw.disabled--V3UQ\+qlA{background-color:rgba(0,0,0,.2);color:rgba(0,0,0,.2);cursor:not-allowed}.base--AMUfuKVw.inline--BKv97NDT{font-size:13px;min-width:0;padding:0;text-decoration:underline;border:1px solid transparent}.base--AMUfuKVw.inline--BKv97NDT:focus{border:1px dashed #000;background-color:transparent}.base--AMUfuKVw:before{display:block;position:absolute;top:0;bottom:0;right:0;left:0;content:"";border:1px solid transparent}@media screen and (-ms-high-contrast:active){.base--AMUfuKVw:before{display:block;position:absolute;top:0;bottom:0;right:0;left:0;content:"";border:1px solid transparent}.base--AMUfuKVw:focus:before{border:2px solid ButtonText;top:1px;bottom:1px;right:1px;left:1px}}.base--AMUfuKVw.primary--EQrmGvRv{position:relative;border:2px solid transparent;outline:0;max-width:200px;color:#000;background-color:#0067b8}.base--AMUfuKVw.primary--EQrmGvRv:hover{background:#005da6}.base--AMUfuKVw.primary--EQrmGvRv:disabled{background-color:rgba(0,0,0,.4);color:#000;cursor:not-allowed;pointer-events:none;opacity:.5;border-color:transparent}.base--J1J4708L{font:inherit;position:relative;border:2px solid transparent;outline:0;padding:9px 12px 10px;background-color:rgba(0,0,0,.2);color:#000;min-width:120px;margin:0;display:inline-block;text-align:center;cursor:pointer;overflow:hidden;transition:all .2s ease-in-out;vertical-align:bottom;white-space:nowrap;text-transform:none}.base--J1J4708L:hover{background:rgba(0,0,0,.3)}.base--J1J4708L:focus{outline:#000 dashed 1px}.base--J1J4708L.lightweight--3L\+zn3YT{position:relative;border:2px solid transparent;outline:0;padding:10px 12px 11px;background-color:transparent;color:#0067b8}.base--J1J4708L.flex---yRBKLth{width:100%;max-width:100%;white-space:normal}.base--J1J4708L.disabled--h3A5RpCZ{background-color:rgba(0,0,0,.2);color:rgba(0,0,0,.2);cursor:not-allowed}.base--J1J4708L.inline--fSqqkWnc{font-size:13px;min-width:0;padding:0;text-decoration:underline;border:1px solid transparent}.base--J1J4708L.inline--fSqqkWnc:focus{border:1px dashed #000;background-color:transparent}.base--J1J4708L:before{display:block;position:absolute;top:0;bottom:0;right:0;left:0;content:"";border:1px solid transparent}@media screen and (-ms-high-contrast:active){.base--J1J4708L:before{display:block;position:absolute;top:0;bottom:0;right:0;left:0;content:"";border:1px solid transparent}.base--J1J4708L:focus:before{border:2px solid ButtonText;top:1px;bottom:1px;right:1px;left:1px}}.base--J1J4708L{transition:none}.base--J1J4708L.primary--3me1I6oV{padding:11px 19px 13px;min-width:160px;border:1px solid transparent;border-radius:100px;font-size:13px;font-weight:700;outline:0;background-color:#0078d4;color:#fff}.base--J1J4708L.primary--3me1I6oV:focus{outline:0}.base--J1J4708L.primary--3me1I6oV:focus-visible{outline:2px solid #1686d9}.base--J1J4708L.primary--3me1I6oV:disabled{cursor:default;pointer-events:none;opacity:.5}.base--J1J4708L.primary--3me1I6oV:focus-visible,.base--J1J4708L.primary--3me1I6oV:hover{background-color:#004e8c}.base--J1J4708L.primary--3me1I6oV:disabled{background-color:#0078d4;color:#fff}.base--J1J4708L.lightweight--3L\+zn3YT{background-color:transparent;color:#0078ca}.base--J1J4708L.inline--fSqqkWnc{text-decoration:none}.base--J1J4708L.inline--fSqqkWnc:hover{text-decoration:underline}.base--J1J4708L.inline--fSqqkWnc:focus,.base--J1J4708L.inline--fSqqkWnc:hover{border-color:transparent;outline:0}.base--J1J4708L.inline--fSqqkWnc:focus-visible{outline:2px solid #1686d9;text-decoration:underline}.base--J1J4708L.flex---yRBKLth{width:auto}.base--YG9fHgi8{font:inherit;position:relative;border:2px solid transparent;outline:0;padding:9px 12px 10px;background-color:rgba(0,0,0,.2);color:#000;min-width:120px;margin:0;display:inline-block;text-align:center;cursor:pointer;overflow:hidden;transition:all .2s ease-in-out;vertical-align:bottom;white-space:nowrap;text-transform:none}.base--YG9fHgi8:hover{background:rgba(0,0,0,.3)}.base--YG9fHgi8:focus{outline:#000 dashed 1px}.base--YG9fHgi8.lightweight--OdgyQfV8{position:relative;border:2px solid transparent;outline:0;padding:10px 12px 11px;background-color:transparent;color:#0067b8}.base--YG9fHgi8.flex--DzuvDnXn{width:100%;max-width:100%;white-space:normal}.base--YG9fHgi8.disabled--gTGTM-Y\+{background-color:rgba(0,0,0,.2);color:rgba(0,0,0,.2);cursor:not-allowed}.base--YG9fHgi8.inline--YV7gla7R{font-size:13px;min-width:0;padding:0;text-decoration:underline;border:1px solid transparent}.base--YG9fHgi8.inline--YV7gla7R:focus{border:1px dashed #000;background-color:transparent}.base--YG9fHgi8:before{display:block;position:absolute;top:0;bottom:0;right:0;left:0;content:"";border:1px solid transparent}@media screen and (-ms-high-contrast:active){.base--YG9fHgi8:before{display:block;position:absolute;top:0;bottom:0;right:0;left:0;content:"";border:1px solid transparent}.base--YG9fHgi8:focus:before{border:2px solid ButtonText;top:1px;bottom:1px;right:1px;left:1px}}.base--YG9fHgi8{padding:6px 12px}.base--YG9fHgi8.primary--D3QXf57x{position:relative;border:2px solid transparent;outline:0;color:#fff;background-color:#0067b8}.base--YG9fHgi8.primary--D3QXf57x:hover{background:#005da6}.base--YG9fHgi8.primary--D3QXf57x:disabled{background-color:rgba(0,0,0,.4);color:#000;cursor:not-allowed;pointer-events:none;opacity:.5;border-color:transparent}.base--YG9fHgi8.lightweight--OdgyQfV8{padding:6px 12px}.base--YG9fHgi8.flex--DzuvDnXn{width:auto;min-width:150px}.base--4CyKMbh8{font:inherit;position:relative;border:2px solid transparent;outline:0;padding:9px 12px 10px;background-color:rgba(0,0,0,.2);color:#000;min-width:120px;margin:0;display:inline-block;text-align:center;cursor:pointer;overflow:hidden;transition:all .2s ease-in-out;vertical-align:bottom;white-space:nowrap;text-transform:none}.base--4CyKMbh8:hover{background:rgba(0,0,0,.3)}.base--4CyKMbh8:focus{outline:#000 dashed 1px}.base--4CyKMbh8.lightweight--L3fELGoI{position:relative;border:2px solid transparent;outline:0;padding:10px 12px 11px;background-color:transparent;color:#0067b8}.base--4CyKMbh8.flex--i3TFVa\+x{width:100%;max-width:100%;white-space:normal}.base--4CyKMbh8.disabled--F-YtIShF{background-color:rgba(0,0,0,.2);color:rgba(0,0,0,.2);cursor:not-allowed}.base--4CyKMbh8.inline--juw3tD4J{font-size:13px;min-width:0;padding:0;text-decoration:underline;border:1px solid transparent}.base--4CyKMbh8.inline--juw3tD4J:focus{border:1px dashed #000;background-color:transparent}.base--4CyKMbh8:before{display:block;position:absolute;top:0;bottom:0;right:0;left:0;content:"";border:1px solid transparent}@media screen and (-ms-high-contrast:active){.base--4CyKMbh8:before{display:block;position:absolute;top:0;bottom:0;right:0;left:0;content:"";border:1px solid transparent}.base--4CyKMbh8:focus:before{border:2px solid ButtonText;top:1px;bottom:1px;right:1px;left:1px}}.base--4CyKMbh8{padding:6px 12px}.base--4CyKMbh8.primary--FQ0omsEL{position:relative;border:2px solid transparent;outline:0;color:#fff;background-color:#0067b8}.base--4CyKMbh8.primary--FQ0omsEL:hover{background:#005da6}.base--4CyKMbh8.primary--FQ0omsEL:disabled{background-color:rgba(0,0,0,.4);color:#000;cursor:not-allowed;pointer-events:none;opacity:.5;border-color:transparent}.base--4CyKMbh8.lightweight--L3fELGoI{padding:6px 12px}.base--4CyKMbh8.flex--i3TFVa\+x{width:auto;min-width:150px}.base--n-QGd0YO{font:inherit;position:relative;border:2px solid transparent;outline:0;padding:9px 12px 10px;background-color:rgba(0,0,0,.2);color:#000;min-width:120px;margin:0;display:inline-block;text-align:center;cursor:pointer;overflow:hidden;transition:all .2s ease-in-out;vertical-align:bottom;white-space:nowrap;text-transform:none}.base--n-QGd0YO:hover{background:rgba(0,0,0,.3)}.base--n-QGd0YO:focus{outline:#000 dashed 1px}.base--n-QGd0YO.lightweight--jkFg8cVv{position:relative;border:2px solid transparent;outline:0;padding:10px 12px 11px;background-color:transparent;color:#0067b8}.base--n-QGd0YO.flex--gKUV5hbF{width:100%;max-width:100%;white-space:normal}.base--n-QGd0YO.disabled--rr0VKq4c{background-color:rgba(0,0,0,.2);color:rgba(0,0,0,.2);cursor:not-allowed}.base--n-QGd0YO.inline--ZnoVkMNx{font-size:13px;min-width:0;padding:0;text-decoration:underline;border:1px solid transparent}.base--n-QGd0YO.inline--ZnoVkMNx:focus{border:1px dashed #000;background-color:transparent}.base--n-QGd0YO:before{display:block;position:absolute;top:0;bottom:0;right:0;left:0;content:"";border:1px solid transparent}@media screen and (-ms-high-contrast:active){.base--n-QGd0YO:before{display:block;position:absolute;top:0;bottom:0;right:0;left:0;content:"";border:1px solid transparent}.base--n-QGd0YO:focus:before{border:2px solid ButtonText;top:1px;bottom:1px;right:1px;left:1px}}.base--n-QGd0YO{padding:6px 12px}.base--n-QGd0YO.primary--a9sDNHl-{position:relative;border:2px solid transparent;outline:0;color:#fff;background-color:#0067b8}.base--n-QGd0YO.primary--a9sDNHl-:hover{background:#005da6}.base--n-QGd0YO.primary--a9sDNHl-:disabled{background-color:rgba(0,0,0,.4);color:#000;cursor:not-allowed;pointer-events:none;opacity:.5;border-color:transparent}.base--n-QGd0YO.flex--gKUV5hbF{width:auto;min-width:150px}.base--a-SFWf\+E{font:inherit;position:relative;border:2px solid transparent;outline:0;padding:9px 12px 10px;background-color:rgba(0,0,0,.2);color:#000;min-width:120px;margin:0;display:inline-block;text-align:center;cursor:pointer;overflow:hidden;transition:all .2s ease-in-out;vertical-align:bottom;white-space:nowrap;text-transform:none}.base--a-SFWf\+E:hover{background:rgba(0,0,0,.3)}.base--a-SFWf\+E:focus{outline:#000 dashed 1px}.base--a-SFWf\+E.lightweight--azk6vAGC{position:relative;border:2px solid transparent;outline:0;padding:10px 12px 11px;background-color:transparent;color:#0067b8}.base--a-SFWf\+E.flex--G2Pdw4CV{width:100%;max-width:100%;white-space:normal}.base--a-SFWf\+E.disabled--O782mQpE{background-color:rgba(0,0,0,.2);color:rgba(0,0,0,.2);cursor:not-allowed}.base--a-SFWf\+E.inline--Gu7TV2DP{font-size:13px;min-width:0;padding:0;text-decoration:underline;border:1px solid transparent}.base--a-SFWf\+E.inline--Gu7TV2DP:focus{border:1px dashed #000;background-color:transparent}.base--a-SFWf\+E:before{display:block;position:absolute;top:0;bottom:0;right:0;left:0;content:"";border:1px solid transparent}@media screen and (-ms-high-contrast:active){.base--a-SFWf\+E:before{display:block;position:absolute;top:0;bottom:0;right:0;left:0;content:"";border:1px solid transparent}.base--a-SFWf\+E:focus:before{border:2px solid ButtonText;top:1px;bottom:1px;right:1px;left:1px}}.base--a-SFWf\+E.primary--pqDda5X7{width:auto;min-width:200px;font-family:"Segoe UI Variable Text";font-weight:400;line-height:20px;border-radius:3px;padding:6px 12px;border:1px solid rgba(0,0,0,.06);border-bottom-color:rgba(0,0,0,.16);color:#fff;background-color:#005fb8}.base--a-SFWf\+E.primary--pqDda5X7:disabled{cursor:not-allowed;pointer-events:none;opacity:.5}.base--a-SFWf\+E.primary--pqDda5X7:hover{background:rgba(0,95,184,.9)}.base--a-SFWf\+E.primary--pqDda5X7:disabled{background-color:rgba(0,0,0,.22);color:#000;border-color:rgba(0,0,0,.22)}.base--a-SFWf\+E.primary--pqDda5X7:active{background-color:rgba(0,95,184,.8)}.base--a-SFWf\+E.primary--pqDda5X7:focus{outline:2px solid #000;opacity:89.56;outline-offset:2px}.base--iwwvlyce{font:inherit;position:relative;border:2px solid transparent;outline:0;padding:9px 12px 10px;background-color:rgba(0,0,0,.2);color:#000;min-width:120px;margin:0;display:inline-block;text-align:center;cursor:pointer;overflow:hidden;transition:all .2s ease-in-out;vertical-align:bottom;white-space:nowrap;text-transform:none}.base--iwwvlyce:hover{background:rgba(0,0,0,.3)}.base--iwwvlyce:focus{outline:#000 dashed 1px}.base--iwwvlyce.lightweight--PzHFMjVm{position:relative;border:2px solid transparent;outline:0;padding:10px 12px 11px;background-color:transparent;color:#0067b8}.base--iwwvlyce.flex--Ef1Km0iv{width:100%;max-width:100%;white-space:normal}.base--iwwvlyce.disabled--xM2VDLrZ{background-color:rgba(0,0,0,.2);color:rgba(0,0,0,.2);cursor:not-allowed}.base--iwwvlyce.inline--AHA3p1Be{font-size:13px;min-width:0;padding:0;text-decoration:underline;border:1px solid transparent}.base--iwwvlyce.inline--AHA3p1Be:focus{border:1px dashed #000;background-color:transparent}.base--iwwvlyce:before{display:block;position:absolute;top:0;bottom:0;right:0;left:0;content:"";border:1px solid transparent}@media screen and (-ms-high-contrast:active){.base--iwwvlyce:before{display:block;position:absolute;top:0;bottom:0;right:0;left:0;content:"";border:1px solid transparent}.base--iwwvlyce:focus:before{border:2px solid ButtonText;top:1px;bottom:1px;right:1px;left:1px}}.base--iwwvlyce.primary--b9cklKWw{width:auto;min-width:200px;font-family:"Segoe UI Variable Text";font-weight:400;line-height:20px;border-radius:3px;padding:6px 12px;border:1px solid rgba(0,0,0,.06);border-bottom-color:rgba(0,0,0,.16);color:#fff;background-color:#005fb8}.base--iwwvlyce.primary--b9cklKWw:disabled{cursor:not-allowed;pointer-events:none;opacity:.5}.base--iwwvlyce.primary--b9cklKWw:hover{background:rgba(0,95,184,.9)}.base--iwwvlyce.primary--b9cklKWw:disabled{background-color:rgba(0,0,0,.22);color:#000;border-color:rgba(0,0,0,.22)}.base--iwwvlyce.primary--b9cklKWw:active{background-color:rgba(0,95,184,.8)}.base--iwwvlyce.primary--b9cklKWw:focus{outline:2px solid #000;opacity:89.56;outline-offset:2px}.base--iwwvlyce.primary--b9cklKWw{width:auto;min-width:200px;font-family:"Segoe UI Variable Text";font-weight:400;line-height:20px;border-radius:3px;padding:6px 12px;border:1px solid rgba(255,255,255,.09);border-bottom-color:rgba(255,255,255,.07);border:1px solid rgba(255,255,255,.09);border-bottom-color:rgba(255,255,255,.07);color:#000;background-color:#60cdff}.base--iwwvlyce.primary--b9cklKWw:disabled{cursor:not-allowed;pointer-events:none;opacity:.5}.base--iwwvlyce.primary--b9cklKWw:hover{background-color:rgba(96,205,255,.9)}.base--iwwvlyce.primary--b9cklKWw:active{background-color:rgba(96,205,255,.8)}.base--iwwvlyce.primary--b9cklKWw:focus{outline:2px solid #fff;outline-offset:2px}.headerDivider--o9XkgfIz{margin-bottom:18px!important}.addToCartButton--H1df0rhk{font-weight:400!important}.addToCartButton--H1df0rhk:disabled{opacity:.5;color:#000!important}@media(min-width:768px){.headerDivider--urveyTryingToFixProblem": "Προσπαθώ να διορθώσω ένα πρόβλημα με το OneDrive",
  "exitSurveyPerformance": "Προσπαθώ να επιταχύνω τον υπολογιστή μου",
  "exitSurveyTooManyNotifications": "Λαμβάνω πάρα πολλές ειδοποιήσεις",
  "exitSurveyOther": "Άλλο",
  "exitStartOnLogon": "Εκκίνηση του OneDrive την επόμενη φορά που θα εισέλθω σε αυτόν τον υπολογιστή",
  "kfmOptoutSurveyPrivacyStatementLink": "Δήλωση προστασίας προσωπικών δεδομένων",
  "kfmOptoutSurveyReasonOther": "Άλλο",
  "moveWindowInfoAreaScanningNoProgress": "Γίνεται προετοιμασία...",
  "reportABugChooseImageDialogErrorUnexpected": "Παρουσιάστηκε μη αναμενόμενο σφάλμα. Προσπαθήστε ξανά.",
  "systraMenuSettings": "Ρυθμίσεις",
  "systrayMenuExit": "Έξοδος από το OneDrive",
  "systrayMenuFeedback": "Αποστολή σχολίων",
  "systrayMenuReportIssue": "Αναφορά προβλήματος",
  "systrayMenuGetHelp": "Λήψη βοήθειας",
  "systrayMenuManageStorage": "Διαχείριση χώρου αποθήκευσης",
  "systrayMenuUnlockVault": "Ξεκλείδωμα Προσωπικής θυρίδας",
  "systrayMenuLockVault": "Κλείδωμα Προσωπικής θυρίδας",
  "systrayMenuUpgrade": "Αναβάθμιση",
  "systrayMenuReportABug": "Εσωτερικό MSFT - Αναφορά σφάλματος",
  "systrayMenuPauseTimerPlural": "{1} ώρες",
  "systrayMenuPauseTimerSingular": "1 ώρα",
  "systrayMenuPauseAccessible": "Παύση συγχρονισμού για {1} ώρες",
  "systrayMenuPauseAccessibleOne": "Παύση συγχρονισμού για 1 ώρα",
  "systrayMenuPause": "Παύση συγχρονισμού",
  "systrayMenuResume": "Συνέχιση συγχρονισμού",
  "errorViewEntryHeaderSyncIssues": "Προβλήματα συγχρονισμού",
  "errorViewEntryHeaderSyncIssue": "Πρόβλημα συγχρονισμού",
  "activityFooterButtonOpenfolder": "Άνοιγμα φακέλου",
  "activityFooterButtonViewonline": "Προβολή online",
  "activityFooterButtonRecyclebin": "Κάδος Ανακύκλωσης",
  "activityFooterButtonGopremium": "Μετάβαση στην έκδοση Premium",
  "activityHeaderOnedriveNotConnected": "{1} δεν είναι συνδεδεμένος",
  "activitySummarySyncingPrimarySingular": "Συγχρονισμός 1 αρχείου - {1} {2} από {3} {4}",
  "activitySummaryPreparingUpload": "Προετοιμασία για αποστολή",
  "activitySummaryPreparingDownload": "Προετοιμασία για λήψη",
  "activityListProgressReviewingChanges": "Προετοιμασία για συγχρονισμό",
  "activityListProgressUploading": "Φόρτωση",
  "activityListProgressDownloading": "Γίνεται λήψη",
  "activityListProgress": "{1} {2} of {3} {4}",
  "activityListCoAuthLocked": "Ο συγχρονισμός θα ολοκληρωθεί όταν κλείσει",
  "activitySummaryUploading": "Αποστολή {1} αρχείων, {2} {3} από {4} {5}",
  "activitySummaryUploadingSingular": "Αποστολή 1 αρχείου, {1} {2} από {3} {4}",
  "activitySummaryDownloading": "Λήψη {1} αρχείων, {2} {3} από {4} {5}",
  "activitySummaryDownloadingSingular": "Λήψη 1 αρχείου, {1} {2} από {3} {4}",
  "activitySummarySyncingPrimary": "Συγχρονισμός {1} αρχείων, {2} {3} από {4} {5}",
  "flyoutSyncStatusUpToDate": "Τα αρχεία σας είναι συγχρονισμένα",
  "activitySummaryCrossScopeMoving": "Μετακίνηση κοινόχρηστων στοιχείων",
  "activitySummaryMetadataSending": "Αποστολή αλλαγών",
  "activitySummaryMetadataReceiving": "Λήψη αλλαγών",
  "flyoutProcessingPrimary": "Επεξεργασία αλλαγών",
  "flyoutProcessingCountSingular": "Επεξεργασία αλλαγής",
  "flyoutProcessingCountPrimary": "Επεξεργασία {1} αλλαγών",
  "flyoutLookingPrimary": "Αναζήτηση για αλλαγές",
  "selectiveSyncEmailString": "OneDrive {1} ({2})",
  "activityListMenuitemOpen": "Άνοιγμα",
  "activityListMenuitemShare": "Κοινή χρήση",
  "activityListMenuitemViewonline": "Προβολή online",
  "activityListMenuitemVersionhistory": "Ιστορικό εκδόσεων",
  "activityCenterCoAuthLockedFile": "Κλείσιμο αρχείου για ολοκλήρωση του συγχρονισμού",
  "activityCenterCoAuthLockedFiles": "Κλείσιμο αρχείων για ολοκλήρωση του συγχρονισμού",
  "activityCenterSigningIn": "Είσοδος",
  "activityCenterSigningOut": "Έξοδος",
  "sendFeedbackTitle": "Αποστολή σχολίων στη Microsoft",
  "reportABugOptionTitle": "Βρήκα ένα σφάλμα (εσωτερικό MSFT)",
  "reportABugOptionSubTitle": "Αναφέρετε ένα σφάλμα σε εμάς.",
  "sendSmileOptionTitle": "Μου αρέσει κάτι",
  "sendSmileOptionSubTitle": "Θέλουμε να μάθουμε τι κάνουμε σωστά.",
  "sendFrownOptionTitle": "Δεν μου αρέσει κάτι",
  "sendFrownOptionSubTitle": "Αν κάτι δεν είναι σωστό, θέλουμε να το μάθουμε.",
  "sendSuggestionOptionTitle": "Έχω μια πρόταση",
  "sendSuggestionOptionSubTitle": "Κοινοποιήστε μια ιδέα ή μια βελτίωση.",
  "smilePlaceHolderText": "Πες μας τι σας αρέσει. Μην συμπεριλάβετε εμπιστευτικές ή προσωπικές πληροφορίες στο σχόλιό σας.",
  "frownPlaceholderText": "Πες μας τι δεν σου άρεσε. Μην συμπεριλάβετε εμπιστευτικές ή προσωπικές πληροφορίες στο σχόλιό σας.",
  "inProgressText": "Αποστολή...",
  "successTitle": "Σας ευχαριστούμε",
  "successSubTitle": "Ευχαριστούμε για τα σχόλιά σας! Τα σχόλιά σας θα μας βοηθήσουν να βελτιωθούμε.",
  "failureSubTitle": "Δυστυχώς, παρουσιάστηκε ένα πρόβλημα κατά την αποστολή των σχολίων σας. Ελέγξτε τη σύνδεσή σας στο Internet και δοκιμάστε ξανά. Μπορείτε επίσης να αναφέρετε το πρόβλημά σας μέσω ",
  "contactingSupportLink": "Επικοινωνία με την υποστήριξη",
  "privacyStatementText": "Πατώντας υποβολή, τα σχόλια σας θα χρησιμοποιηθούν για την βελτίωση των προϊόντων και των υπηρεσιών της Microsoft.Ο διαχειριστής IT θα μπορεί να συλλέξει τα δεδομένα αυτά.",
  "activityCenterHeaderSettingsAccessibleText": "Βοήθεια και Ρυθμίσεις",
  "activityPausedPrimary": "Τα αρχεία δεν συγχρονίζονται αυτήν τη στιγμή",
  "activityPausedSecondary": "Πατήστε ή κάντε κλικ εδώ για να συνεχιστεί ο συγχρονισμός ώστε να διατηρηθούν τα αρχεία σας ενημερωμένα.",
  "activityPausedSecondaryNetwork": "Πατήστε ή κάντε κλικ εδώ για να συνεχιστεί ο συγχρονισμός ώστε να διατηρηθούν τα αρχεία σας ενημερωμένα. Ενδέχεται να ισχύουν χρεώσεις δεδομένων, καθώς η συσκευή σας βρίσκεται σε δίκτυο με βάση τη χρήση.",
  "activityPausedSecondaryBattery": "Πατήστε ή κάντε κλικ εδώ για να συνεχιστεί ο συγχρονισμός ώστε να διατηρηθούν τα αρχεία σας ενημερωμένα. Η διάρκεια ζωής της μπαταρίας ενδέχεται να επηρεαστεί.",
  "systrayMenuItemLabel": "{1} από {2} στοιχεία μενού",
  "activityCenterHeaderAccessibleReportAVSOBug": "Αναφορά σφάλματος",
  "activityListAccessibleName": "Πρόσφατα αρχεία.",
  "historyListItemIndexAccessibleText": "{1} από {2} πρόσφατα στοιχεία.",
  "activityListAccessibleMenuButtonName": "Περισσότερες επιλογές",
  "errorViewExitAccessibleText": "{1}. Κλείστε τη σελίδα με τα θέματα συγχρονισμού.",
  "errorViewListItemIndexAccessibleText": "{1} από {2} θέματα συγχρονισμού.",
  "errorViewHomeTooltip": "Αρχική σελίδα",
  "errorViewListAccessibleText": "Λίστα θεμάτων συγχρονισμού του OneDrive",
  "activityACMDismissHint": "Κλείσιμο",
  "signInLoading": "Φόρτωση...",
  "freMarketingNeitherConfigured": "Αυτή η διεύθυνση ηλεκτρονικού ταχυδρομείου δεν αναγνωρίστηκε. Προσπαθήστε ξανά ή εγγραφείτε για νέον λογαριασμό.",
  "freMarketingConfiguredMsaAadError": "Αυτή η διεύθυνση ηλεκτρονικού ταχυδρομείου χρησιμοποιείται τόσο για το OneDrive όσο και για το OneDrive για επιχειρήσεις. Σε ποιο θέλετε να εισέλθετε πρώτα;",
  "freMarketingAdminDisabledPersonalError": "Ο οργανισμός σας δεν επιτρέπει τον συγχρονισμό του προσωπικού σας OneDrive σε αυτόν τον υπολογιστή.",
  "freMarketingPersonalConfiguredError": "Συγχρονίζετε ήδη ένα προσωπικό OneDrive σε αυτόν τον υπολογιστή. Καταργήστε τη σύνδεση με αυτόν το λογαριασμό για να προσθέσετε έναν νέο.",
  "errorPageNetworkErrorPrimary": "Παρουσιάστηκε πρόβλημα με τη σύνδεση στο OneDrive",
  "offlineFlyoutPrimaryString": "Έναρξη του OneDrive",
  "offlineFlyoutMoreInfoUIString": "Διατηρήστε τα αρχεία σας ενημερωμένα",
  "freMarketingConsumerButton": "Προσωπικός",
  "freMarketingBusinessButton": "Εταιρικός ή σχολικός",
  "offlineFlyoutOneDrivePrimaryStatus": "Αποσυνδέθηκε",
  "offlineFlyoutOneDriveMoreInfoUI": "Συνδέστε το OneDrive για να διατηρήσετε τα αρχεία σας προστατευμένα και ενημερωμένα.",
  "offlineFlyoutOneDriveMoreInfoButton": "Σύνδεση του OneDrive"
}                                                                                                                        1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1369-\u137C\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u17E0-\u17E9\u17F0-\u17F9\u1810-\u1819\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A16\u1A20-\u1A54\u1A80-\u1A89\u1A90-\u1A99\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B50-\u1B59\u1B83-\u1BA0\u1BAE-\u1BE5\u1C00-\u1C23\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2070\u2071\u2074-\u2079\u207F-\u2089{
  "WalletECNewCtaDescriptionCashback": "attivare il programma di cashback",
  "WalletECNewCtaDescriptionCoupon": "applicare automaticamente i coupon",
  "WalletECNewCtaDescriptionFillAddress": "riempire automaticamente le informazioni di spedizione",
  "WalletECNewCtaDescriptionFillDetail": "inserisci le informazioni di spedizione e fatturazione",
  "WalletECNewCtaDescriptionFillPayment": "inserire le informazioni di fatturazione",
  "WalletECNewCtaDescriptionGiftCard": "riscatta buono regalo",
  "WalletECNewCtaDescriptionTakeToBNPL": "portarti a $1",
  "WalletECNewUXErrorMessageForAutofill": "Il riempimento automatico non è riuscito a completare tutti i dettagli. Immettili manualmente per completare l'acquisto.",
  "WalletECNewUXErrorMessageForCashback": "Al momento non è possibile applicare il cashback all'acquisto. Riprova più tardi.",
  "WalletECNewUXErrorMessageForCoupon": "Il test del coupon non è disponibile al momento, ma puoi comunque testare i coupon manualmente.",
  "WalletECNewUXForNoSuccessMessage": "Non possiamo aiutarvi in questo momento",
  "WalletECNewUXForNoSuccessMessageOptimized": "Hmm. Non funziona, riprova.",
  "WalletECNewUXForNoWorkingCoupon": "Non sono stati trovati coupon funzionanti",
  "WalletECNewUXMultiErrorMessageForAutofill": "riempimento automatico",
  "WalletECNewUXMultiErrorMessageForCashback": "cashback",
  "WalletECNewUXMultiErrorMessageForCoupon": "coupon",
  "WalletECNewUXPartialSuccessMessageForAutofill": "Alcuni dettagli sono stati compilati. Immetti le informazioni rimanenti per completare l'acquisto",
  "WalletECNewUXSSuccessMessageForCouponAndGiftCard": "Hai già risparmiato $1 con il miglior coupon e buono regalo",
  "WalletECNewUXSSuccessMessagegiftCardInfo": "Hai riscattato $1 punti Microsoft Rewards per $2",
  "WalletECNewUXSuccessMessageForAutofill": "I dettagli della transazione sono stati compilati",
  "WalletECNewUXSuccessMessageForCashback": "Riceverai fino a $1 in cashback $2",
  "WalletECNewUXSuccessMessageForCoupon": "Hai già risparmiato $1 con il miglior coupon",
  "WalletECNewUXSuccessMessageForGiftCard": "Hai già risparmiato $1 con un buono regalo",
  "WalletECSimplifyAutofillSubTitle": "Attiva per abilitare il riempimento automatico",
  "WalletECSimplifyAutofillTitle": "Riempimento automatico dei dettagli della transazione",
  "WalletECUXSimplifyCtaDescriptionSaving": "Applica i risparmi",
  "walletBNPLSmallCardBottomMessagePayInFour": "$1 offre anche pagamenti mensili con interessi.",
  "walletBNPLSmallCardBottomMessageZip": "Zip offre anche pagamenti mensili con interessi.",
  "walletBNPLSmallCardFooterMessage": "Microsoft non addebita alcun costo o non viene pagato da questi provider.",
  "walletBNPLSmallCardTitle": "L'acquisto verrà suddiviso in 4 rate",
  "walletBNPLSmallCardTitleBothFinancedAndPayInFour": "L'acquisto può essere suddiviso in 4 rate",
  "walletChangeYourSettings": "modifica le impostazioni",
  "walletDrawerFormPageMicroFeedbackPrompt": "Sei soddisfatto del Portafoglio?",
  "walletDrawerGiftCardAuofillMultipleFailureTitle": "Applica automaticamente il tuo buono regalo a questo ordine. Controlla l'indirizzo e-mail per il numero di buono regalo, quindi immettilo manualmente per usarlo.",
  "walletDrawerGiftCardAutofillFailureTitle": "Non è stato possibile applicare automaticamente il tuo buono regalo a questo ordine. Controlla l'indirizzo e-mail per il numero di buono regalo, quindi immettilo manualmente per usarlo.",
  "walletDrawerGiftCardRedeemFailureTitle": "Non è stato possibile riscattare i punti Rewards come buono regalo. Puoi continuare con l'ordine o riprovare più tardi.",
  "walletDrawerGiftCardRedeemMultipleFailureTitle": "Riscatta i tuoi punti Rewards come buono regalo.",
  "walletECAllFailureMessageBottom": "Non preoccuparti, puoi continuare la transazione.",
  "walletECAllFailureTitle": "Le funzionalità seguenti non sono al momento disponibili:",
  "walletECApplyCashBackTitle": "Cashback",
  "walletECApplyCashCackTitle": "Riceverai fino a $1 in cashback.",
  "walletECApplySavingTitle": "Risparmierai $1 e otterrai fin|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDE70-\uDEBE\uDEC0-\uDEC9\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF50-\uDF59\uDF5B-\uDF61\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE96\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD50-\uDD52\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD834[\uDEE0-\uDEF3\uDF60-\uDF78]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD837[\uDF00-\uDF1E]|\uD838[\uDD00-\uDD2C\uDD37-\uDD3D\uDD40-\uDD49\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB\uDEF0-\uDEF9]|\uD839[\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDCC7-\uDCCF\uDD00-\uDD43\uDD4B\uDD50-\uDD59]|\uD83B[\uDC71-\uDCAB\uDCAD-\uDCAF\uDCB1-\uDCB4\uDD01-\uDD2D\uDD2F-\uDD3D\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD83C[\uDD00-\uDD0C]|\uD83E[\uDFF0-\uDFF9]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF38\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A])/)) return;
      var nextChar = match[1] || match[2] || '';
      if (!nextChar || nextChar && (prevChar === '' || this.rules.inline.punctuation.exec(prevChar))) {
        var lLength = match[0].length - 1;
        var rDelim,
          rLength,
          delimTotal = lLength,
          midDelimTotal = 0;
        var endReg = match[0][0] === '*' ? this.rules.inline.emStrong.rDelimAst : this.rules.inline.emStrong.rDelimUnd;
        endReg.lastIndex = 0;

        // Clip maskedSrc to same section of string as src (move to lexer?)
        maskedSrc = maskedSrc.slice(-1 * src.length + lLength);
        while ((match = endReg.exec(maskedSrc)) != null) {
          rDelim = match[1] || match[2] || match[3] || match[4] || match[5] || match[6];
          if (!rDelim) continue; // skip single * in __abc*abc__

          rLength = rDelim.length;
          if (match[3] || match[4]) {
            // found another Left Delim
            delimTotal += rLength;
            continue;
          } else if (match[5] || match[6]) {
            // either Left or Right Delim
            if (lLength % 3 && !((lLength + rLength) % 3)) {
              midDelimTotal += rLength;
              continue; // CommonMark Emphasis Rules 9-10
            }
          }

          delimTotal -= rLength;
          if (delimTotal > 0) continue; // Haven't found enough closing delimiters

          // Remove extra characters. *a*** -> *a*
          rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal);
          var raw = src.slice(0, lLength + match.index + (match[0].length - rDelim.length) + rLength);

          // Create `em` if smallest delimiter has odd char count. *a***
          if (Math.min(lLength, rLength) % 2) {
            var _text = raw.slice(1, -1);
            return {
              type: 'em',
              raw: raw,
              text: _text,
              tokens: this.lexer.inlineTokens(_text)
            };
          }

          // Create 'strong' if smallest delimiter has even char count. **a***
          var text = raw.slice(2, -2);
          return {
            type: 'strong',
            raw: raw,
            text: text,
            tokens: this.lexer.inlineTokens(text)
          };
        }
      }
    };
    _proto.codespan = function codespan(src) {
      var cap = this.rules.inline.code.exec(src);
      if (cap) {
        var text = cap[2].replace(/\n/g, ' ');
        var hasNonSpaceChars = /[^ ]/.test(text);
        var hasSpaceCharsOnBothEnds = /^ /.test(text) && / $/.test(text);
        if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {
          text = text.substring(1, text.length - 1);
        }
        text = escape(text, true);
        return {
          type: 'codespan',
          raw: cap[0],
          text: text
        };
      }
    };
    _proto.br = function br(src) {
      var cap = this.rules.inline.br.exec(src);
      if (cap) {
        return {
          type: 'br',
          raw: cap[0]
        };
      }
    };
    _proto.del = function del(src) {
      var cap = this.rules.inline.del.exec(src);
      if (cap) {
        return {
          type: 'del',
          raw: cap[0],
          text: cap[2],
          tokens: this.lexer.inlineTokens(cap[2])
        };
      }
    };
    _proto.autolink = function autolink(src, mangle) {
      var cap = this.rules.inline.autolink.exec(src);
      if (cap) {
        var text, href;
        if (cap[2] === '@') {
          text = escape(this.options.mangle ? mangle(cap[1]) : cap[1]);
          href = 'mailto:' + text;
        } else {
          text = escape(cap[1]);
          href = text;
        }
        return {
          type: 'link',
          raw: cap[0],
          text: text,
          href: href,
          tokens: [{
            type: 'text',
            raw: text,
            text: text
          }]
        };
      }
    };
    _proto.url = function url(src, mangle) {
      var cap;
      if (cap = this.rules.inline.url.exec(src)) {
        var text, href;
        if (cap[2] === '@') {
          text = escape(this.options.mangle ? mangle(cap[0]) : cap[0]);
          href = 'mailto:' + text;
        } else {
          // do extended autolink path validation
          var prevCapZero;
          do {
            prevCapZero = cap[0];
            cap[0] = this.rules.inline._backpedal.exec(cap[0])[0];
          } while (prevCapZero !== cap[0]);
          text = escape(cap[0]);
          if (cap[1] === 'www.') {
            href = 'http://' + cap[0];
          } else {
            href = cap[0];
          }
        }
        return {
          type: 'link',
          raw: cap[0],
          text: text,
          href: href,
          tokens: [{
            type: 'text',
            raw: text,
            text: text
          }]
        };
      }
    };
    _proto.inlineText = function inlineText(src, smartypants) {
      var cap = this.rules.inline.text.exec(src);
      if (cap) {
        var text;
        if (this.lexer.state.inRawBlock) {
          text = this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0]) : cap[0];
        } else {
          text = escape(this.options.smartypants ? smartypants(cap[0]) : cap[0]);
        }
        return {
          type: 'text',
          raw: cap[0],
          text: text
        };
      }
    };
    return Tokenizer;
  }();

  /**
   * Block-Level Grammar
   */
  var block = {
    newline: /^(?: *(?:\n|$))+/,
    code: /^( {4}[^\n]+(?:\n(?: *(?:\n|$))*)?)+/,
    fences: /^ {0,3}(`{3,}(?=[^`\n]*(?:\n|$))|~{3,})([^\n]*)(?:\n|$)(?:|([\s\S]*?)(?:\n|$))(?: {0,3}\1[~`]* *(?=\n|$)|$)/,
    hr: /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/,
    heading: /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/,
    blockquote: /^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/,
    list: /^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/,
    html: '^ {0,3}(?:' // optional indentation
    + '<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)' // (1)
    + '|comment[^\\n]*(\\n+|$)' // (2)
    + '|<\\?[\\s\\S]*?(?:\\?>\\n*|$)' // (3)
    + '|<![A-Z][\\s\\S]*?(?:>\\n*|$)' // (4)
    + '|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)' // (5)
    + '|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n *)+\\n|$)' // (6)
    + '|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)' // (7) open tag
    + '|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)' // (7) closing tag
    + ')',
    def: /^ {0,3}\[(label)\]: *(?:\n *)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n *)?| *\n *)(title))? *(?:\n+|$)/,
    table: noopTest,
    lheading: /^((?:.|\n(?!\n))+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
    // regex template, placeholders will be replaced according to different paragraph
    // interruption rules of commonmark and the original markdown spec:
    _paragraph: /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/,
    text: /^[^\n]+/
  };
  block._label = /(?!\s*\])(?:\\.|[^\[\]\\])+/;
  block._title = /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/;
  block.def = edit(block.def).replace('label', block._label).replace('title', block._title).getRegex();
  block.bullet = /(?:[*+-]|\d{1,9}[.)])/;
  block.listItemStart = edit(/^( *)(bull) */).replace('bull', block.bullet).getRegex();
  block.list = edit(block.list).replace(/bull/g, block.bullet).replace('hr', '\\n+(?=\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$))').replace('def', '\\n+(?=' + block.def.source + ')').getRegex();
  block._tag = 'address|article|aside|base|basefont|blockquote|body|caption' + '|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption' + '|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe' + '|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option' + '|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr' + '|track|ul';
  block._comment = /<!--(?!-?>)[\s\S]*?(?:-->|$)/;
  block.html = edit(block.html, 'i').replace('comment', block._comment).replace('tag', block._tag).replace('attribute', / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex();
  block.paragraph = edit(block._paragraph).replace('hr', block.hr).replace('heading', ' {0,3}#{1,6} ').replace('|lheading', '') // setex headings don't interrupt commonmark paragraphs
  .replace('|table', '').replace('blockquote', ' {0,3}>').replace('fences', ' {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n').replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt
  .replace('html', '</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)').replace('tag', block._tag) // pars can be interrupted by type (6) html blocks
  .getRegex();
  block.blockquote = edit(block.blockquote).replace('paragraph', block.paragraph).getRegex();

  /**
   * Normal Block Grammar
   */

  block.normal = _extends({}, block);

  /**
   * GFM Block Grammar
   */

  block.gfm = _extends({}, block.normal, {
    table: '^ *([^\\n ].*\\|.*)\\n' // Header
    + ' {0,3}(?:\\| *)?(:?-+:? *(?:\\| *:?-+:? *)*)(?:\\| *)?' // Align
    + '(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)' // Cells
  });

  block.gfm.table = edit(block.gfm.table).replace('hr', block.hr).replace('heading', ' {0,3}#{1,6} ').replace('blockquote', ' {0,3}>').replace('code', ' {4}[^\\n]').replace('fences', ' {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n').replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt
  .replace('html', '</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)').replace('tag', block._tag) // tables can be interrupted by type (6) html blocks
  .getRegex();
  block.gfm.paragraph = edit(block._paragraph).replace('hr', block.hr).replace('heading', ' {0,3}#{1,6} ').replace('|lheading', '') // setex headings don't interrupt commonmark paragraphs
  .replace('table', block.gfm.table) // interrupt paragraphs with table
  .replace('blockquote', ' {0,3}>').replace('fences', ' {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n').replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt
  .replace('html', '</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)').replace('tag', block._tag) // pars can be interrupted by type (6) html blocks
  .getRegex();
  /**
   * Pedantic grammar (original John Gruber's loose markdown specification)
   */

  block.pedantic = _extends({}, block.normal, {
    html: edit('^ *(?:comment *(?:\\n|\\s*$)' + '|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)' // closed tag
    + '|<tag(?:"[^"]*"|\'[^\']*\'|\\s[^\'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))').replace('comment', block._comment).replace(/tag/g, '(?!(?:' + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub' + '|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)' + '\\b)\\w+(?!:|[^\\w\\s@]*@)\\b').getRegex(),
    def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
    heading: /^(#{1,6})(.*)(?:\n+|$)/,
    fences: noopTest,
    // fences not supported
    lheading: /^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
    paragraph: edit(block.normal._paragraph).replace('hr', block.hr).replace('heading', ' *#{1,6} *[^\n]').replace('lheading', block.lheading).replace('blockquote', ' {0,3}>').replace('|fences', '').replace('|list', '').replace('|html', '').getRegex()
  });

  /**
   * Inline-Level Grammar
   */
  var inline = {
    escape: /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/,
    autolink: /^<(scheme:[^\s\x00-\x1f<>]*|email)>/,
    url: noopTest,
    tag: '^comment' + '|^</[a-zA-Z][\\w:-]*\\s*>' // self-closing tag
    + '|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>' // open tag
    + '|^<\\?[\\s\\S]*?\\?>' // processing instruction, e.g. <?php ?>
    + '|^<![a-zA-Z]+\\s[\\s\\S]*?>' // declaration, e.g. <!DOCTYPE html>
    + '|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>',
    // CDATA section
    link: /^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/,
    reflink: /^!?\[(label)\]\[(ref)\]/,
    nolink: /^!?\[(ref)\](?:\[\])?/,
    reflinkSearch: 'reflink|nolink(?!\\()',
    emStrong: {
      lDelim: /^(?:\*+(?:([punct_])|[^\s*]))|^_+(?:([punct*])|([^\s_]))/,
      //        (1) and (2) can only be a Right Delimiter. (3) and (4) can only be Left.  (5) and (6) can be either Left or Right.
      //          () Skip orphan inside strong                                      () Consume to delim     (1) #***                (2) a***#, a***                             (3) #***a, ***a                 (4) ***#              (5) #***#                 (6) a***a
      rDelimAst: /^(?:[^_*\\]|\\.)*?\_\_(?:[^_*\\]|\\.)*?\*(?:[^_*\\]|\\.)*?(?=\_\_)|(?:[^*\\]|\\.)+(?=[^*])|[punct_](\*+)(?=[\s]|$)|(?:[^punct*_\s\\]|\\.)(\*+)(?=[punct_\s]|$)|[punct_\s](\*+)(?=[^punct*_\s])|[\s](\*+)(?=[punct_])|[punct_](\*+)(?=[punct_])|(?:[^punct*_\s\\]|\\.)(\*+)(?=[^punct*_\s])/,
      rDelimUnd: /^(?:[^_*\\]|\\.)*?\*\*(?:[^_*\\]|\\.)*?\_(?:[^_*\\]|\\.)*?(?=\*\*)|(?:[^_\\]|\\.)+(?=[^_])|[punct*](\_+)(?=[\s]|$)|(?:[^punct*_\s\\]|\\.)(\_+)(?=[punct*\s]|$)|[punct*\s](\_+)(?=[^punct*_\s])|[\s](\_+)(?=[punct*])|[punct*](\_+)(?=[punct*])/ // ^- Not allowed for _
    },

    code: /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/,
    br: /^( {2,}|\\)\n(?!\s*$)/,
    del: noopTest,
    text: /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/,
    punctuation: /^([\spunctuation])/
  };

  // list of punctuation marks from CommonMark spec
  // without * and _ to handle the different emphasis markers * and _
  inline._punctuation = '!"#$%&\'()+\\-.,/:;<=>?@\\[\\]`^{|}~';
  inline.punctuation = edit(inline.punctuation).replace(/punctuation/g, inline._punctuation).getRegex();

  // sequences em should skip over [title](link), `code`, <html>
  inline.blockSkip = /\[[^\]]*?\]\([^\)]*?\)|`[^`]*?`|<[^>]*?>/g;
  // lookbehind is not available on Safari as of version 16
  // inline.escapedEmSt = /(?<=(?:^|[^\\)(?:\\[^])*)\\[*_]/g;
  inline.escapedEmSt = /(?:^|[^\\])(?:\\\\)*\\[*_]/g;
  inline._comment = edit(block._comment).replace('(?:-->|$)', '-->').getRegex();
  inline.emStrong.lDelim = edit(inline.emStrong.lDelim).replace(/punct/g, inline._punctuation).getRegex();
  inline.emStrong.rDelimAst = edit(inline.emStrong.rDelimAst, 'g').replace(/punct/g, inline._punctuation).getRegex();
  inline.emStrong.rDelimUnd = edit(inline.emStrong.rDelimUnd, 'g').replace(/punct/g, inline._punctuation).getRegex();
  inline._escapes = /\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/g;
  inline._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/;
  inline._email = /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/;
  inline.autolink = edit(inline.autolink).replace('scheme', inline._scheme).replace('email', inline._email).getRegex();
  inline._attribute = /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/;
  inline.tag = edit(inline.tag).replace('comment', inline._comment).replace('attribute', inline._attribute).getRegex();
  inline._label = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/;
  inline._href = /<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/;
  inline._title = /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/;
  inline.link = edit(inline.link).replace('label', inline._label).replace('href', inline._href).replace('title', inline._title).getRegex();
  inline.reflink = edit(inline.reflink).replace('label', inline._label).replace('ref', block._label).getRegex();
  inline.nolink = edit(inline.nolink).replace('ref', block._label).getRegex();
  inline.reflinkSearch = edit(inline.reflinkSearch, 'g').replace('reflink', inline.reflink).replace('nolink', inline.nolink).getRegex();

  /**
   * Normal Inline Grammar
   */

  inline.normal = _extends({}, inline);

  /**
   * Pedantic Inline Grammar
   */

  inline.pedantic = _extends({}, inline.normal, {
    strong: {
      start: /^__|\*\*/,
      middle: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
      endAst: /\*\*(?!\*)/g,
      endUnd: /__(?!_)/g
    },
    em: {
      start: /^_|\*/,
      middle: /^()\*(?=\S)([\s\S]*?\S)\*(?!\*)|^_(?=\S)([\s\S]*?\S)_(?!_)/,
      endAst: /\*(?!\*)/g,
      endUnd: /_(?!_)/g
    },
    link: edit(/^!?\[(label)\]\((.*?)\)/).replace('label', inline._label).getRegex(),
    reflink: edit(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace('label', inline._label).getRegex()
  });

  /**
   * GFM Inline Grammar
   */

  inline.gfm = _extends({}, inline.normal, {
    escape: edit(inline.escape).replace('])', '~|])').getRegex(),
    _extended_email: /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,
    url: /^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/,
    _backpedal: /(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/,
    del: /^(~~?)(?=[^\s~])([\s\S]*?[^\s~])\1(?=[^~]|$)/,
    text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/
  });
  inline.gfm.url = edit(inline.gfm.url, 'i').replace('email', inline.gfm._extended_email).getRegex();
  /**
   * GFM + Line Breaks Inline Grammar
   */

  inline.breaks = _extends({}, inline.gfm, {
    br: edit(inline.br).replace('{2,}', '*').getRegex(),
    text: edit(inline.gfm.text).replace('\\b_', '\\b_| {2,}\\n').replace(/\{2,\}/g, '*').getRegex()
  });

  /**
   * smartypants text replacement
   * @param {string} text
   */
  function smartypants(text) {
    return text
    // em-dashes
    .replace(/---/g, "\u2014")
    // en-dashes
    .replace(/--/g, "\u2013")
    // opening singles
    .replace(/(^|[-\u2014/(\[{"\s])'/g, "$1\u2018")
    // closing singles & apostrophes
    .replace(/'/g, "\u2019")
    // opening doubles
    .replace(/(^|[-\u2014/(\[{\u2018\s])"/g, "$1\u201C")
    // closing doubles
    .replace(/"/g, "\u201D")
    // ellipses
    .replace(/\.{3}/g, "\u2026");
  }

  /**
   * mangle email addresses
   * @param {string} text
   */
  function mangle(text) {
    var out = '',
      i,
      ch;
    var l = text.length;
    for (i = 0; i < l; i++) {
      ch = text.charCodeAt(i);
      if (Math.random() > 0.5) {
        ch = 'x' + ch.toString(16);
      }
      out += '&#' + ch + ';';
    }
    return out;
  }

  /**
   * Block Lexer
   */
  var Lexer = /*#__PURE__*/function () {
    function Lexer(options) {
      this.tokens = [];
      this.tokens.links = Object.create(null);
      this.options = options || exports.defaults;
      this.options.tokenizer = this.options.tokenizer || new Tokenizer();
      this.tokenizer = this.options.tokenizer;
      this.tokenizer.options = this.options;
      this.tokenizer.lexer = this;
      this.inlineQueue = [];
      this.state = {
        inLink: false,
        inRawBlock: false,
        top: true
      };
      var rules = {
        block: block.normal,
        inline: inline.normal
      };
      if (this.options.pedantic) {
        rules.block = block.pedantic;
        rules.inline = inline.pedantic;
      } else if (this.options.gfm) {
        rules.block = block.gfm;
        if (this.options.breaks) {
          rules.inline = inline.breaks;
        } else {
          rules.inline = inline.gfm;
        }
      }
      this.tokenizer.rules = rules;
    }

    /**
     * Expose Rules
     */
    /**
     * Static Lex Method
     */
    Lexer.lex = function lex(src, options) {
      var lexer = new Lexer(options);
      return lexer.lex(src);
    }

    /**
     * Static Lex Inline Method
     */;
    Lexer.lexInline = function lexInline(src, options) {
      var lexer = new Lexer(options);
      return lexer.inlineTokens(src);
    }

    /**
     * Preprocessing
     */;
    var _proto = Lexer.prototype;
    _proto.lex = function lex(src) {
      src = src.replace(/\r\n|\r/g, '\n');
      this.blockTokens(src, this.tokens);
      var next;
      while (next = this.inlineQueue.shift()) {
        this.inlineTokens(next.src, next.tokens);
      }
      return this.tokens;
    }

    /**
     * Lexing
     */;
    _proto.blockTokens = function blockTokens(src, tokens) {
      var _this = this;
      if (tokens === void 0) {
        tokens = [];
      }
      if (this.options.pedantic) {
        src = src.replace(/\t/g, '    ').replace(/^ +$/gm, '');
      } else {
        src = src.replace(/^( *)(\t+)/gm, function (_, leading, tabs) {
          return leading + '    '.repeat(tabs.length);
        });
      }
      var token, lastToken, cutSrc, lastParagraphClipped;
      while (src) {
        if (this.options.extensions && this.options.extensions.block && this.options.extensions.block.some(function (extTokenizer) {
          if (token = extTokenizer.call({
            lexer: _this
          }, src, tokens)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            return true;
          }
          return false;
        })) {
          continue;
        }

        // newline
        if (token = this.tokenizer.space(src)) {
          src = src.substring(token.raw.length);
          if (token.raw.length === 1 && tokens.length > 0) {
            // if there's a single \n as a spacer, it's terminating the last line,
            // so move it there so that we don't get unecessary paragraph tags
            tokens[tokens.length - 1].raw += '\n';
          } else {
            tokens.push(token);
          }
          continue;
        }

        // code
        if (token = this.tokenizer.code(src)) {
          src = src.substring(token.raw.length);
          lastToken = tokens[tokens.length - 1];
          // An indented code block cannot interrupt a paragraph.
          if (lastToken && (lastToken.type === 'paragraph' || lastToken.type === 'text')) {
            lastToken.raw += '\n' + token.raw;
            lastToken.text += '\n' + token.text;
            this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
          } else {
            tokens.push(token);
          }
          continue;
        }

        // fences
        if (token = this.tokenizer.fences(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }

        // heading
        if (token = this.tokenizer.heading(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }

        // hr
        if (token = this.tokenizer.hr(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }

        // blockquote
        if (token = this.tokenizer.blockquote(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }

        // list
        if (token = this.tokenizer.list(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }

        // html
        if (token = this.tokenizer.html(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }

        // def
        if (token = this.tokenizer.def(src)) {
          src = src.substring(token.raw.length);
          lastToken = tokens[tokens.length - 1];
          if (lastToken && (lastToken.type === 'paragraph' || lastToken.type === 'text')) {
            lastToken.raw += '\n' + token.raw;
            lastToken.text += '\n' + token.raw;
            this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
          } else if (!this.tokens.links[token.tag]) {
            this.tokens.links[token.tag] = {
              href: token.href,
              title: token.title
            };
          }
          continue;
        }

        // table (gfm)
        if (token = this.tokenizer.table(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }

        // lheading
        if (token = this.tokenizer.lheading(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }

        // top-level paragraph
        // prevent paragraph consuming extensions by clipping 'src' to extension start
        cutSrc = src;
        if (this.options.extensions && this.options.extensions.startBlock) {
          (function () {
            var startIndex = Infinity;
            var tempSrc = src.slice(1);
            var tempStart = void 0;
            _this.options.extensions.startBlock.forEach(function (getStartIndex) {
              tempStart = getStartIndex.call({
                lexer: this
              }, tempSrc);
              if (typeof tempStart === 'number' && tempStart >= 0) {
                startIndex = Math.min(startIndex, tempStart);
              }
            });
            if (startIndex < Infinity && startIndex >= 0) {
              cutSrc = src.substring(0, startIndex + 1);
            }
          })();
        }
        if (this.state.top && (token = this.tokenizer.paragraph(cutSrc))) {
          lastToken = tokens[tokens.length - 1];
          if (lastParagraphClipped && lastToken.type === 'paragraph') {
            lastToken.raw += '\n' + token.raw;
            lastToken.text += '\n' + token.text;
            this.inlineQueue.pop();
            this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
          } else {
            tokens.push(token);
          }
          lastParagraphClipped = cutSrc.length !== src.length;
          src = src.substring(token.raw.length);
          continue;
        }

        // text
        if (token = this.tokenizer.text(src)) {
          src = src.substring(token.raw.length);
          lastToken = tokens[tokens.length - 1];
          if (lastToken && lastToken.type === 'text') {
            lastToken.raw += '\n' + token.raw;
            lastToken.text += '\n' + token.text;
            this.inlineQueue.pop();
            this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
          } else {
            tokens.push(token);
          }
          continue;
        }
        if (src) {
          var errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);
          if (this.options.silent) {
            console.error(errMsg);
            break;
          } else {
            throw new Error(errMsg);
          }
        }
      }
      this.state.top = true;
      return tokens;
    };
    _proto.inline = function inline(src, tokens) {
      if (tokens === void 0) {
        tokens = [];
      }
      this.inlineQueue.push({
        src: src,
        tokens: tokens
      });
      return tokens;
    }

    /**
     * Lexing/Compiling
     */;
    _proto.inlineTokens = function inlineTokens(src, tokens) {
      var _this2 = this;
      if (tokens === void 0) {
        tokens = [];
      }
      var token, lastToken, cutSrc;

      // String with links masked to avoid interference with em and strong
      var maskedSrc = src;
      var match;
      var keepPrevChar, prevChar;

      // Mask out reflinks
      if (this.tokens.links) {
        var links = Object.keys(this.tokens.links);
        if (links.length > 0) {
          while ((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null) {
            if (links.includes(match[0].slice(match[0].lastIndexOf('[') + 1, -1))) {
              maskedSrc = maskedSrc.slice(0, match.index) + '[' + repeatString('a', match[0].length - 2) + ']' + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);
            }
          }
        }
      }
      // Mask out other blocks
      while ((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null) {
        maskedSrc = maskedSrc.slice(0, match.index) + '[' + repeatString('a', match[0].length - 2) + ']' + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
      }

      // Mask out escaped em & strong delimiters
      while ((match = this.tokenizer.rules.inline.escapedEmSt.exec(maskedSrc)) != null) {
        maskedSrc = maskedSrc.slice(0, match.index + match[0].length - 2) + '++' + maskedSrc.slice(this.tokenizer.rules.inline.escapedEmSt.lastIndex);
        this.tokenizer.rules.inline.escapedEmSt.lastIndex--;
      }
      while (src) {
        if (!keepPrevChar) {
          prevChar = '';
        }
        keepPrevChar = false;

        // extensions
        if (this.options.extensions && this.options.extensions.inline && this.options.extensions.inline.some(function (extTokenizer) {
          if (token = extTokenizer.call({
            lexer: _this2
          }, src, tokens)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            return true;
          }
          return false;
        })) {
          continue;
        }

        // escape
        if (token = this.tokenizer.escape(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }

        // tag
        if (token = this.tokenizer.tag(src)) {
          src = src.substring(token.raw.length);
          lastToken = tokens[tokens.length - 1];
          if (lastToken && token.type === 'text' && lastToken.type === 'text') {
            lastToken.raw += token.raw;
            lastToken.text += token.text;
          } else {
            tokens.push(token);
          }
          continue;
        }

        // link
        if (token = this.tokenizer.link(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }

        // reflink, nolink
        if (token = this.tokenizer.reflink(src, this.tokens.links)) {
          src = src.substring(token.raw.length);
          lastToken = tokens[tokens.length - 1];
          if (lastToken && token.type === 'text' && lastToken.type === 'text') {
            lastToken.raw += token.raw;
            lastToken.text += token.text;
          } else {
            tokens.push(token);
          }
          continue;
        }

        // em & strong
        if (token = this.tokenizer.emStrong(src, maskedSrc, prevChar)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }

        // code
        if (token = this.tokenizer.codespan(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }

        // br
        if (token = this.tokenizer.br(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }

        // del (gfm)
        if (token = this.tokenizer.del(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }

        // autolink
        if (token = this.tokenizer.autolink(src, mangle)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }

        // url (gfm)
        if (!this.state.inLink && (token = this.tokenizer.url(src, mangle))) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }

        // text
        // prevent inlineText consuming extensions by clipping 'src' to extension start
        cutSrc = src;
        if (this.options.extensions && this.options.extensions.startInline) {
          (function () {
            var startIndex = Infinity;
            var tempSrc = src.slice(1);
            var tempStart = void 0;
            _this2.options.extensions.startInline.forEach(function (getStartIndex) {
              tempStart = getStartIndex.call({
                lexer: this
              }, tempSrc);
              if (typeof tempStart === 'number' && tempStart >= 0) {
                startIndex = Math.min(startIndex, tempStart);
              }
            });
            if (startIndex < Infinity && startIndex >= 0) {
              cutSrc = src.substring(0, startIndex + 1);
            }
          })();
        }
        if (token = this.tokenizer.inlineText(cutSrc, smartypants)) {
          src = src.substring(token.raw.length);
          if (token.raw.slice(-1) !== '_') {
            // Track prevChar before string of ____ started
            prevChar = token.raw.slice(-1);
          }
          keepPrevChar = true;
          lastToken = tokens[tokens.length - 1];
          if (lastToken && lastToken.type === 'text') {
            lastToken.raw += token.raw;
            lastToken.text += token.text;
          } else {
            tokens.push(token);
          }
          continue;
        }
        if (src) {
          var errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);
          if (this.options.silent) {
            console.error(errMsg);
            break;
          } else {
            throw new Error(errMsg);
          }
        }
      }
      return tokens;
    };
    _createClass(Lexer, null, [{
      key: "rules",
      get: function get() {
        return {
          block: block,
          inline: inline
        };
      }
    }]);
    return Lexer;
  }();

  /**
   * Renderer
   */
  var Renderer = /*#__PURE__*/function () {
    function Renderer(options) {
      this.options = options || exports.defaults;
    }
    var _proto = Renderer.prototype;
    _proto.code = function code(_code, infostring, escaped) {
      var lang = (infostring || '').match(/\S*/)[0];
      if (this.options.highlight) {
        var out = this.options.highlight(_code, lang);
        if (out != null && out !== _code) {
          escaped = true;
          _code = out;
        }
      }
      _code = _code.replace(/\n$/, '') + '\n';
      if (!lang) {
        return '<pre><code>' + (escaped ? _code : escape(_code, true)) + '</code></pre>\n';
      }
      return '<pre><code class="' + this.options.langPrefix + escape(lang) + '">' + (escaped ? _code : escape(_code, true)) + '</code></pre>\n';
    }

    /**
     * @param {string} quote
     */;
    _proto.blockquote = function blockquote(quote) {
      return "<blockquote>\n" + quote + "</blockquote>\n";
    };
    _proto.html = function html(_html) {
      return _html;
    }

    /**
     * @param {string} text
     * @param {string} level
     * @param {string} raw
     * @param {any} slugger
     */;
    _proto.heading = function heading(text, level, raw, slugger) {
      if (this.options.headerIds) {
        var id = this.options.headerPrefix + slugger.slug(raw);
        return "<h" + level + " id=\"" + id + "\">" + text + "</h" + level + ">\n";
      }

      // ignore IDs
      return "<h" + level + ">" + text + "</h" + level + ">\n";
    };
    _proto.hr = function hr() {
      return this.options.xhtml ? '<hr/>\n' : '<hr>\n';
    };
    _proto.list = function list(body, ordered, start) {
      var type = ordered ? 'ol' : 'ul',
        startatt = ordered && start !== 1 ? ' start="' + start + '"' : '';
      return '<' + type + startatt + '>\n' + body + '</' + type + '>\n';
    }

    /**
     * @param {string} text
     */;
    _proto.listitem = function listitem(text) {
      return "<li>" + text + "</li>\n";
    };
    _proto.checkbox = function checkbox(checked) {
      return '<input ' + (checked ? 'checked="" ' : '') + 'disabled="" type="checkbox"' + (this.options.xhtml ? ' /' : '') + '> ';
    }

    /**
     * @param {string} text
     */;
    _proto.paragraph = function paragraph(text) {
      return "<p>" + text + "</p>\n";
    }

    /**
     * @param {string} header
     * @param {string} body
     */;
    _proto.table = function table(header, body) {
      if (body) body = "<tbody>" + body + "</tbody>";
      return '<table>\n' + '<thead>\n' + header + '</thead>\n' + body + '</table>\n';
    }

    /**
     * @param {string} content
     */;
    _proto.tablerow = function tablerow(content) {
      return "<tr>\n" + content + "</tr>\n";
    };
    _proto.tablecell = function tablecell(content, flags) {
      var type = flags.header ? 'th' : 'td';
      var tag = flags.align ? "<" + type + " align=\"" + flags.align + "\">" : "<" + type + ">";
      return tag + content + ("</" + type + ">\n");
    }

    /**
     * span level renderer
     * @param {string} text
     */;
    _proto.strong = function strong(text) {
      return "<strong>" + text + "</strong>";
    }

    /**
     * @param {string} text
     */;
    _proto.em = function em(text) {
      return "<em>" + text + "</em>";
    }

    /**
     * @param {string} text
     */;
    _proto.codespan = function codespan(text) {
      return "<code>" + text + "</code>";
    };
    _proto.br = function br() {
      return this.options.xhtml ? '<br/>' : '<br>';
    }

    /**
     * @param {string} text
     */;
    _proto.del = function del(text) {
      return "<del>" + text + "</del>";
    }

    /**
     * @param {string} href
     * @param {string} title
     * @param {string} text
     */;
    _proto.link = function link(href, title, text) {
      href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);
      if (href === null) {
        return text;
      }
      var out = '<a href="' + href + '"';
      if (title) {
        out += ' title="' + title + '"';
      }
      out += '>' + text + '</a>';
      return out;
    }

    /**
     * @param {string} href
     * @param {string} title
     * @param {string} text
     */;
    _proto.image = function image(href, title, text) {
      href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);
      if (href === null) {
        return text;
      }
      var out = "<img src=\"" + href + "\" alt=\"" + text + "\"";
      if (title) {
        out += " title=\"" + title + "\"";
      }
      out += this.options.xhtml ? '/>' : '>';
      return out;
    };
    _proto.text = function text(_text) {
      return _text;
    };
    return Renderer;
  }();

  /**
   * TextRenderer
   * returns only the textual part of the token
   */
  var TextRenderer = /*#__PURE__*/function () {
    function TextRenderer() {}
    var _proto = TextRenderer.prototype;
    // no need for block level renderers
    _proto.strong = function strong(text) {
      return text;
    };
    _proto.em = function em(text) {
      return text;
    };
    _proto.codespan = function codespan(text) {
      return text;
    };
    _proto.del = function del(text) {
      return text;
    };
    _proto.html = function html(text) {
      return text;
    };
    _proto.text = function text(_text) {
      return _text;
    };
    _proto.link = function link(href, title, text) {
      return '' + text;
    };
    _proto.image = function image(href, title, text) {
      return '' + text;
    };
    _proto.br = function br() {
      return '';
    };
    return TextRenderer;
  }();

  /**
   * Slugger generates header id
   */
  var Slugger = /*#__PURE__*/function () {
    function Slugger() {
      this.seen = {};
    }

    /**
     * @param {string} value
     */
    var _proto = Slugger.prototype;
    _proto.serialize = function serialize(value) {
      return value.toLowerCase().trim()
      // remove html tags
      .replace(/<[!\/a-z].*?>/ig, '')
      // remove unwanted chars
      .replace(/[\u2000-\u206F\u2E00-\u2E7F\\'!"#$%&()*+,./:;<=>?@[\]^`{|}~]/g, '').replace(/\s/g, '-');
    }

    /**
     * Finds the next safe (unique) slug to use
     * @param {string} originalSlug
     * @param {boolean} isDryRun
     */;
    _proto.getNextSafeSlug = function getNextSafeSlug(originalSlug, isDryRun) {
      var slug = originalSlug;
      var occurenceAccumulator = 0;
      if (this.seen.hasOwnProperty(slug)) {
        occurenceAccumulator = this.seen[originalSlug];
        do {
          occurenceAccumulator++;
          slug = originalSlug + '-' + occurenceAccumulator;
        } while (this.seen.hasOwnProperty(slug));
      }
      if (!isDryRun) {
        this.seen[originalSlug] = occurenceAccumulator;
        this.seen[slug] = 0;
      }
      return slug;
    }

    /**
     * Convert string to unique id
     * @param {object} [options]
     * @param {boolean} [options.dryrun] Generates the next unique slug without
     * updating the internal accumulator.
     */;
    _proto.slug = function slug(value, options) {
      if (options === void 0) {
        options = {};
      }
      var slug = this.serialize(value);
      return this.getNextSafeSlug(slug, options.dryrun);
    };
    return Slugger;
  }();

  /**
   * Parsing & Compiling
   */
  var Parser = /*#__PURE__*/function () {
    function Parser(options) {
      this.options = options || exports.defaults;
      this.options.renderer = this.options.renderer || new Renderer();
      this.renderer = this.options.renderer;
      this.renderer.options = this.options;
      this.textRenderer = new TextRenderer();
      this.slugger = new Slugger();
    }

    /**
     * Static Parse Method
     */
    Parser.parse = function parse(tokens, options) {
      var parser = new Parser(options);
      return parser.parse(tokens);
    }

    /**
     * Static Parse Inline Method
     */;
    Parser.parseInline = function parseInline(tokens, options) {
      var parser = new Parser(options);
      return parser.parseInline(tokens);
    }

    /**
     * Parse Loop
     */;
    var _proto = Parser.prototype;
    _proto.parse = function parse(tokens, top) {
      if (top === void 0) {
        top = true;
      }
      var out = '',
        i,
        j,
        k,
        l2,
        l3,
        row,
        cell,
        header,
        body,
        token,
        ordered,
        start,
        loose,
        itemBody,
        item,
        checked,
        task,
        checkbox,
        ret;
      var l = tokens.length;
      for (i = 0; i < l; i++) {
        token = tokens[i];

        // Run any renderer extensions
        if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {
          ret = this.options.extensions.renderers[token.type].call({
            parser: this
          }, token);
          if (ret !== false || !['space', 'hr', 'heading', 'code', 'table', 'blockquote', 'list', 'html', 'paragraph', 'text'].includes(token.type)) {
            out += ret || '';
            continue;
          }
        }
        switch (token.type) {
          case 'space':
            {
              continue;
            }
          case 'hr':
            {
              out += this.renderer.hr();
              continue;
            }
          case 'heading':
            {
              out += this.renderer.heading(this.parseInline(token.tokens), token.depth, unescape(this.parseInline(token.tokens, this.textRenderer)), this.slugger);
              continue;
            }
          case 'code':
            {
              out += this.renderer.code(token.text, token.lang, token.escaped);
              continue;
            }
          case 'table':
            {
              header = '';

              // header
              cell = '';
              l2 = token.header.length;
              for (j = 0; j < l2; j++) {
                cell += this.renderer.tablecell(this.parseInline(token.header[j].tokens), {
                  header: true,
                  align: token.align[j]
                });
              }
              header += this.renderer.tablerow(cell);
              body = '';
              l2 = token.rows.length;
              for (j = 0; j < l2; j++) {
                row = token.rows[j];
                cell = '';
                l3 = row.length;
                for (k = 0; k < l3; k++) {
                  cell += this.renderer.tablecell(this.parseInline(row[k].tokens), {
                    header: false,
                    align: token.align[k]
                  });
                }
                body += this.renderer.tablerow(cell);
              }
              out += this.renderer.table(header, body);
              continue;
            }
          case 'blockquote':
            {
              body = this.parse(token.tokens);
              out += this.renderer.blockquote(body);
              continue;
            }
          case 'list':
            {
              ordered = token.ordered;
              start = token.start;
              loose = token.loose;
              l2 = token.items.length;
              body = '';
              for (j = 0; j < l2; j++) {
                item = token.items[j];
                checked = item.checked;
                task = item.task;
                itemBody = '';
                if (item.task) {
                  checkbox = this.renderer.checkbox(checked);
                  if (loose) {
                    if (item.tokens.length > 0 && item.tokens[0].type === 'paragraph') {
                      item.tokens[0].text = checkbox + ' ' + item.tokens[0].text;
                      if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === 'text') {
                        item.tokens[0].tokens[0].text = checkbox + ' ' + item.tokens[0].tokens[0].text;
                      }
                    } else {
                      item.tokens.unshift({
                        type: 'text',
                        text: checkbox
                      });
                    }
                  } else {
                    itemBody += checkbox;
                  }
                }
                itemBody += this.parse(item.tokens, loose);
                body += this.renderer.listitem(itemBody, task, checked);
              }
              out += this.renderer.list(body, ordered, start);
              continue;
            }
          case 'html':
            {
              // TODO parse inline content if parameter markdown=1
              out += this.renderer.html(token.text);
              continue;
            }
          case 'paragraph':
            {
              out += this.renderer.paragraph(this.parseInline(token.tokens));
              continue;
            }
          case 'text':
            {
              body = token.tokens ? this.parseInline(token.tokens) : token.text;
              while (i + 1 < l && tokens[i + 1].type === 'text') {
                token = tokens[++i];
                body += '\n' + (token.tokens ? this.parseInline(token.tokens) : token.text);
              }
              out += top ? this.renderer.paragraph(body) : body;
              continue;
            }
          default:
            {
              var errMsg = 'Token with "' + token.type + '" type was not found.';
              if (this.options.silent) {
                console.error(errMsg);
                return;
              } else {
                throw new Error(errMsg);
              }
            }
        }
      }
      return out;
    }

    /**
     * Parse Inline Tokens
     */;
    _proto.parseInline = function parseInline(tokens, renderer) {
      renderer = renderer || this.renderer;
      var out = '',
        i,
        token,
        ret;
      var l = tokens.length;
      for (i = 0; i < l; i++) {
        token = tokens[i];

        // Run any renderer extensions
        if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {
          ret = this.options.extensions.renderers[token.type].call({
            parser: this
          }, token);
          if (ret !== false || !['escape', 'html', 'link', 'image', 'strong', 'em', 'codespan', 'br', 'del', 'text'].includes(token.type)) {
            out += ret || '';
            continue;
          }
        }
        switch (token.type) {
          case 'escape':
            {
              out += renderer.text(token.text);
              break;
            }
          case 'html':
            {
              out += renderer.html(token.text);
              break;
            }
          case 'link':
            {
              out += renderer.link(token.href, token.title, this.parseInline(token.tokens, renderer));
              break;
            }
          case 'image':
            {
              out += renderer.image(token.href, token.title, token.text);
              break;
            }
          case 'strong':
            {
              out += renderer.strong(this.parseInline(token.tokens, renderer));
              break;
            }
          case 'em':
            {
              out += renderer.em(this.parseInline(token.tokens, renderer));
              break;
            }
          case 'codespan':
            {
              out += renderer.codespan(token.text);
              break;
            }
          case 'br':
            {
              out += renderer.br();
              break;
            }
          case 'del':
            {
              out += renderer.del(this.parseInline(token.tokens, renderer));
              break;
            }
          case 'text':
            {
              out += renderer.text(token.text);
              break;
            }
          default:
            {
              var errMsg = 'Token with "' + token.type + '" type was not found.';
              if (this.options.silent) {
                console.error(errMsg);
                return;
              } else {
                throw new Error(errMsg);
              }
            }
        }
      }
      return out;
    };
    return Parser;
  }();

  var Hooks = /*#__PURE__*/function () {
    function Hooks(options) {
      this.options = options || exports.defaults;
    }
    var _proto = Hooks.prototype;
    /**
     * Process markdown before marked
     */
    _proto.preprocess = function preprocess(markdown) {
      return markdown;
    }

    /**
     * Process HTML after marked is finished
     */;
    _proto.postprocess = function postprocess(html) {
      return html;
    };
    return Hooks;
  }();
  Hooks.passThroughHooks = new Set(['preprocess', 'postprocess']);

  function onError(silent, async, callback) {
    return function (e) {
      e.message += '\nPlease report this to https://github.com/markedjs/marked.';
      if (silent) {
        var msg = '<p>An error occurred:</p><pre>' + escape(e.message + '', true) + '</pre>';
        if (async) {
          return Promise.resolve(msg);
        }
        if (callback) {
          callback(null, msg);
          return;
        }
        return msg;
      }
      if (async) {
        return Promise.reject(e);
      }
      if (callback) {
        callback(e);
        return;
      }
      throw e;
    };
  }
  function parseMarkdown(lexer, parser) {
    return function (src, opt, callback) {
      if (typeof opt === 'function') {
        callback = opt;
        opt = null;
      }
      var origOpt = _extends({}, opt);
      opt = _extends({}, marked.defaults, origOpt);
      var throwError = onError(opt.silent, opt.async, callback);

      // throw error in case of non string input
      if (typeof src === 'undefined' || src === null) {
        return throwError(new Error('marked(): input parameter is undefined or null'));
      }
      if (typeof src !== 'string') {
        return throwError(new Error('marked(): input parameter is of type ' + Object.prototype.toString.call(src) + ', string expected'));
      }
      checkSanitizeDeprecation(opt);
      if (opt.hooks) {
        opt.hooks.options = opt;
      }
      if (callback) {
        var highlight = opt.highlight;
        var tokens;
        try {
          if (opt.hooks) {
            src = opt.hooks.preprocess(src);
          }
          tokens = lexer(src, opt);
        } catch (e) {
          return throwError(e);
        }
        var done = function done(err) {
          var out;
          if (!err) {
            try {
              if (opt.walkTokens) {
                marked.walkTokens(tokens, opt.walkTokens);
              }
              out = parser(tokens, opt);
              if (opt.hooks) {
                out = opt.hooks.postprocess(out);
              }
            } catch (e) {
              err = e;
            }
          }
          opt.highlight = highlight;
          return err ? throwError(err) : callback(null, out);
        };
        if (!highlight || highlight.length < 3) {
          return done();
        }
        delete opt.highlight;
        if (!tokens.length) return done();
        var pending = 0;
        marked.walkTokens(tokens, function (token) {
          if (token.type === 'code') {
            pending++;
            setTimeout(function () {
              highlight(token.text, token.lang, function (err, code) {
                if (err) {
                  return done(err);
                }
                if (code != null && code !== token.text) {
                  token.text = code;
                  token.escaped = true;
                }
                pending--;
                if (pending === 0) {
                  done();
                }
              });
            }, 0);
          }
        });
        if (pending === 0) {
          done();
        }
        return;
      }
      if (opt.async) {
        return Promise.resolve(opt.hooks ? opt.hooks.preprocess(src) : src).then(function (src) {
          return lexer(src, opt);
        }).then(function (tokens) {
          return opt.walkTokens ? Promise.all(marked.walkTokens(tokens, opt.walkTokens)).then(function () {
            return tokens;
          }) : tokens;
        }).then(function (tokens) {
          return parser(tokens, opt);
        }).then(function (html) {
          return opt.hooks ? opt.hooks.postprocess(html) : html;
        })["catch"](throwError);
      }
      try {
        if (opt.hooks) {
          src = opt.hooks.preprocess(src);
        }
        var _tokens = lexer(src, opt);
        if (opt.walkTokens) {
          marked.walkTokens(_tokens, opt.walkTokens);
        }
        var html = parser(_tokens, opt);
        if (opt.hooks) {
          html = opt.hooks.postprocess(html);
        }
        return html;
      } catch (e) {
        return throwError(e);
      }
    };
  }

  /**
   * Marked
   */
  function marked(src, opt, callback) {
    return parseMarkdown(Lexer.lex, Parser.parse)(src, opt, callback);
  }

  /**
   * Options
   */

  marked.options = marked.setOptions = function (opt) {
    marked.defaults = _extends({}, marked.defaults, opt);
    changeDefaults(marked.defaults);
    return marked;
  };
  marked.getDefaults = getDefaults;
  marked.defaults = exports.defaults;

  /**
   * Use Extension
   */

  marked.use = function () {
    var extensions = marked.defaults.extensions || {
      renderers: {},
      childTokens: {}
    };
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    args.forEach(function (pack) {
      // copy options to new object
      var opts = _extends({}, pack);

      // set async to true if it was set to true before
      opts.async = marked.defaults.async || opts.async || false;

      // ==-- Parse "addon" extensions --== //
      if (pack.extensions) {
        pack.extensions.forEach(function (ext) {
          if (!ext.name) {
            throw new Error('extension name required');
          }
          if (ext.renderer) {
            // Renderer extensions
            var prevRenderer = extensions.renderers[ext.name];
            if (prevRenderer) {
              // Replace extension with func to run new extension but fall back if false
              extensions.renderers[ext.name] = function () {
                for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                  args[_key2] = arguments[_key2];
                }
                var ret = ext.renderer.apply(this, args);
                if (ret === false) {
                  ret = prevRenderer.apply(this, args);
                }
                return ret;
              };
            } else {
              extensions.renderers[ext.name] = ext.renderer;
            }
          }
          if (ext.tokenizer) {
            // Tokenizer Extensions
            if (!ext.level || ext.level !== 'block' && ext.level !== 'inline') {
              throw new Error("extension level must be 'block' or 'inline'");
            }
            if (extensions[ext.level]) {
              extensions[ext.level].unshift(ext.tokenizer);
            } else {
              extensions[ext.level] = [ext.tokenizer];
            }
            if (ext.start) {
              // Function to check for start of token
              if (ext.level === 'block') {
                if (extensions.startBlock) {
                  extensions.startBlock.push(ext.start);
                } else {
                  extensions.startBlock = [ext.start];
                }
              } else if (ext.level === 'inline') {
                if (extensions.startInline) {
                  extensions.startInline.push(ext.start);
                } else {
                  extensions.startInline = [ext.start];
                }
              }
            }
          }
          if (ext.childTokens) {
            // Child tokens to be visited by walkTokens
            extensions.childTokens[ext.name] = ext.childTokens;
          }
        });
        opts.extensions = extensions;
      }

      // ==-- Parse "overwrite" extensions --== //
      if (pack.renderer) {
        (function () {
          var renderer = marked.defaults.renderer || new Renderer();
          var _loop = function _loop(prop) {
            var prevRenderer = renderer[prop];
            // Replace renderer with func to run extension, but fall back if false
            renderer[prop] = function () {
              for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
                args[_key3] = arguments[_key3];
              }
              var ret = pack.renderer[prop].apply(renderer, args);
              if (ret === false) {
                ret = prevRenderer.apply(renderer, args);
              }
              return ret;
            };
          };
          for (var prop in pack.renderer) {
            _loop(prop);
          }
          opts.renderer = renderer;
        })();
      }
      if (pack.tokenizer) {
        (function () {
          var tokenizer = marked.defaults.tokenizer || new Tokenizer();
          var _loop2 = function _loop2(prop) {
            var prevTokenizer = tokenizer[prop];
            // Replace tokenizer with func to run extension, but fall back if false
            tokenizer[prop] = function () {
              for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
                args[_key4] = arguments[_key4];
              }
              var ret = pack.tokenizer[prop].apply(tokenizer, args);
              if (ret === false) {
                ret = prevTokenizer.apply(tokenizer, args);
              }
              return ret;
            };
          };
          for (var prop in pack.tokenizer) {
            _loop2(prop);
          }
          opts.tokenizer = tokenizer;
        })();
      }

      // ==-- Parse Hooks extensions --== //
      if (pack.hooks) {
        (function () {
          var hooks = marked.defaults.hooks || new Hooks();
          var _loop3 = function _loop3(prop) {
            var prevHook = hooks[prop];
            if (Hooks.passThroughHooks.has(prop)) {
              hooks[prop] = function (arg) {
                if (marked.defaults.async) {
                  return Promise.resolve(pack.hooks[prop].call(hooks, arg)).then(function (ret) {
                    return prevHook.call(hooks, ret);
                  });
                }
                var ret = pack.hooks[prop].call(hooks, arg);
                return prevHook.call(hooks, ret);
              };
            } else {
              hooks[prop] = function () {
                for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
                  args[_key5] = arguments[_key5];
                }
                var ret = pack.hooks[prop].apply(hooks, args);
                if (ret === false) {
                  ret = prevHook.apply(hooks, args);
                }
                return ret;
              };
            }
          };
          for (var prop in pack.hooks) {
            _loop3(prop);
          }
          opts.hooks = hooks;
        })();
      }

      // ==-- Parse WalkTokens extensions --== //
      if (pack.walkTokens) {
        var _walkTokens = marked.defaults.walkTokens;
        opts.walkTokens = function (token) {
          var values = [];
          values.push(pack.walkTokens.call(this, token));
          if (_walkTokens) {
            values = values.concat(_walkTokens.call(this, token));
          }
          return values;
        };
      }
      marked.setOptions(opts);
    });
  };

  /**
   * Run callback for every token
   */

  marked.walkTokens = function (tokens, callback) {
    var values = [];
    var _loop4 = function _loop4() {
      var token = _step.value;
      values = values.concat(callback.call(marked, token));
      switch (token.type) {
        case 'table':
          {
            for (var _iterator2 = _createForOfIteratorHelperLoose(token.header), _step2; !(_step2 = _iterator2()).done;) {
              var cell = _step2.value;
              values = values.concat(marked.walkTokens(cell.tokens, callback));
            }
            for (var _iterator3 = _createForOfIteratorHelperLoose(token.rows), _step3; !(_step3 = _iterator3()).done;) {
              var row = _step3.value;
              for (var _iterator4 = _createForOfIteratorHelperLoose(row), _step4; !(_step4 = _iterator4()).done;) {
                var _cell = _step4.value;
                values = values.concat(marked.walkTokens(_cell.tokens, callback));
              }
            }
            break;
          }
        case 'list':
          {
            values = values.concat(marked.walkTokens(token.items, callback));
            break;
          }
        default:
          {
            if (marked.defaults.extensions && marked.defaults.extensions.childTokens && marked.defaults.extensions.childTokens[token.type]) {
              // Walk any extensions
              marked.defaults.extensions.childTokens[token.type].forEach(function (childTokens) {
                values = values.concat(marked.walkTokens(token[childTokens], callback));
              });
            } else if (token.tokens) {
              values = values.concat(marked.walkTokens(token.tokens, callback));
            }
          }
      }
    };
    for (var _iterator = _createForOfIteratorHelperLoose(tokens), _step; !(_step = _iterator()).done;) {
      _loop4();
    }
    return values;
  };

  /**
   * Parse Inline
   * @param {string} src
   */
  marked.parseInline = parseMarkdown(Lexer.lexInline, Parser.parseInline);

  /**
   * Expose
   */
  marked.Parser = Parser;
  marked.parser = Parser.parse;
  marked.Renderer = Renderer;
  marked.TextRenderer = TextRenderer;
  marked.Lexer = Lexer;
  marked.lexer = Lexer.lex;
  marked.Tokenizer = Tokenizer;
  marked.Slugger = Slugger;
  marked.Hooks = Hooks;
  marked.parse = marked;
  var options = marked.options;
  var setOptions = marked.setOptions;
  var use = marked.use;
  var walkTokens = marked.walkTokens;
  var parseInline = marked.parseInline;
  var parse = marked;
  var parser = Parser.parse;
  var lexer = Lexer.lex;

  exports.Hooks = Hooks;
  exports.Lexer = Lexer;
  exports.Parser = Parser;
  exports.Renderer = Renderer;
  exports.Slugger = Slugger;
  exports.TextRenderer = TextRenderer;
  exports.Tokenizer = Tokenizer;
  exports.getDefaults = getDefaults;
  exports.lexer = lexer;
  exports.marked = marked;
  exports.options = options;
  exports.parse = parse;
  exports.parseInline = parseInline;
  exports.parser = parser;
  exports.setOptions = setOptions;
  exports.use = use;
  exports.walkTokens = walkTokens;

}));
