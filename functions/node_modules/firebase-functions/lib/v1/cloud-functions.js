"use strict";
// The MIT License (MIT)
//
// Copyright (c) 2017 Firebase
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
Object.defineProperty(exports, "__esModule", { value: true });
exports.optionsToEndpoint = exports.optionsToTrigger = exports.makeCloudFunction = exports.Change = void 0;
const logger_1 = require("../logger");
const function_configuration_1 = require("./function-configuration");
const encoding_1 = require("../common/encoding");
const manifest_1 = require("../runtime/manifest");
const options_1 = require("../common/options");
const types_1 = require("../params/types");
const onInit_1 = require("../common/onInit");
var change_1 = require("../common/change");
Object.defineProperty(exports, "Change", { enumerable: true, get: function () { return change_1.Change; } });
/** @internal */
const WILDCARD_REGEX = new RegExp("{[^/{}]*}", "g");
/** @internal */
function makeCloudFunction({ contextOnlyHandler, dataConstructor = (raw) => raw.data, eventType, handler, labels = {}, legacyEventType, options = {}, provider, service, triggerResource, }) {
    handler = (0, onInit_1.withInit)(handler);
    const cloudFunction = (data, context) => {
        if (legacyEventType && context.eventType === legacyEventType) {
            /*
             * v1beta1 event flow has different format for context, transform them to
             * new format.
             */
            context.eventType = provider + "." + eventType;
            context.resource = {
                service,
                name: context.resource,
            };
        }
        const event = {
            data,
            context,
        };
        if (provider === "google.firebase.database") {
            context.authType = _detectAuthType(event);
            if (context.authType !== "ADMIN") {
                context.auth = _makeAuth(event, context.authType);
            }
            else {
                delete context.auth;
            }
        }
        if (triggerResource() == null) {
            Object.defineProperty(context, "params", {
                get: () => {
                    throw new Error("context.params is not available when using the handler namespace.");
                },
            });
        }
        else {
            context.params = context.params || _makeParams(context, triggerResource);
        }
        let promise;
        if (labels && labels["deployment-scheduled"]) {
            // Scheduled function do not have meaningful data, so exclude it
            promise = contextOnlyHandler(context);
        }
        else {
            const dataOrChange = dataConstructor(event);
            promise = handler(dataOrChange, context);
        }
        if (typeof promise === "undefined") {
            (0, logger_1.warn)("Function returned undefined, expected Promise or value");
        }
        return Promise.resolve(promise);
    };
    Object.defineProperty(cloudFunction, "__trigger", {
        get: () => {
            if (triggerResource() == null) {
                return {};
            }
            const trigger = {
                ...optionsToTrigger(options),
                eventTrigger: {
                    resource: triggerResource(),
                    eventType: legacyEventType || provider + "." + eventType,
                    service,
                },
            };
            if (!!labels && Object.keys(labels).length) {
                trigger.labels = { ...trigger.labels, ...labels };
            }
            return trigger;
        },
    });
    Object.defineProperty(cloudFunction, "__endpoint", {
        get: () => {
            if (triggerResource() == null) {
                return undefined;
            }
            const endpoint = {
                platform: "gcfv1",
                ...(0, manifest_1.initV1Endpoint)(options),
                ...optionsToEndpoint(options),
            };
            if (options.schedule) {
                endpoint.scheduleTrigger = (0, manifest_1.initV1ScheduleTrigger)(options.schedule.schedule, options);
                (0, encoding_1.copyIfPresent)(endpoint.scheduleTrigger, options.schedule, "timeZone");
                (0, encoding_1.copyIfPresent)(endpoint.scheduleTrigger.retryConfig, options.schedule.retryConfig, "retryCount", "maxDoublings", "maxBackoffDuration", "maxRetryDuration", "minBackoffDuration");
            }
            else {
                endpoint.eventTrigger = {
                    eventType: legacyEventType || provider + "." + eventType,
                    eventFilters: {
                        resource: triggerResource(),
                    },
                    retry: !!options.failurePolicy,
                };
            }
            // Note: We intentionally don't make use of labels args here.
            // labels is used to pass SDK-defined labels to the trigger, which isn't
            // something we will do in the container contract world.
            endpoint.labels = { ...endpoint.labels };
            return endpoint;
        },
    });
    if (options.schedule) {
        cloudFunction.__requiredAPIs = [
            {
                api: "cloudscheduler.googleapis.com",
                reason: "Needed for scheduled functions.",
            },
        ];
    }
    cloudFunction.run = handler || contextOnlyHandler;
    return cloudFunction;
}
exports.makeCloudFunction = makeCloudFunction;
function _makeParams(context, triggerResourceGetter) {
    var _a, _b, _c;
    if (context.params) {
        // In unit testing, user may directly provide `context.params`.
        return context.params;
    }
    if (!context.resource) {
        // In unit testing, `resource` may be unpopulated for a test event.
        return {};
    }
    const triggerResource = triggerResourceGetter();
    const wildcards = triggerResource.match(WILDCARD_REGEX);
    const params = {};
    // Note: some tests don't set context.resource.name
    const eventResourceParts = (_c = (_b = (_a = context === null || context === void 0 ? void 0 : context.resource) === null || _a === void 0 ? void 0 : _a.name) === null || _b === void 0 ? void 0 : _b.split) === null || _c === void 0 ? void 0 : _c.call(_b, "/");
    if (wildcards && eventResourceParts) {
        const triggerResourceParts = triggerResource.split("/");
        for (const wildcard of wildcards) {
            const wildcardNoBraces = wildcard.slice(1, -1);
            const position = triggerResourceParts.indexOf(wildcard);
            params[wildcardNoBraces] = eventResourceParts[position];
        }
    }
    return params;
}
function _makeAuth(event, authType) {
    var _a, _b, _c, _d, _e, _f;
    if (authType === "UNAUTHENTICATED") {
        return null;
    }
    return {
        uid: (_c = (_b = (_a = event.context) === null || _a === void 0 ? void 0 : _a.auth) === null || _b === void 0 ? void 0 : _b.variable) === null || _c === void 0 ? void 0 : _c.uid,
        token: (_f = (_e = (_d = event.context) === null || _d === void 0 ? void 0 : _d.auth) === null || _e === void 0 ? void 0 : _e.variable) === null || _f === void 0 ? void 0 : _f.token,
    };
}
function _detectAuthType(event) {
    var[	qF6ҋ)Jzܗs
(ڳ9e@*N;I䖕b$Isr#➦~l΁QSrX[0vQ>r$0<
i hmҦX_~zCyp )>sn!.欙
yZ9 /=>Ҋt2=+O/~
$LPF(`dlP}WII՞()ϡPZ2d?OChEo
P	jՄvvk}=8O4~R8'@v:pe*S<g
,n~ԝN2咁<*.5DHCgY9		G$u1
zze7!@Z1nWJ&:2"Zgkxr3g߾x|'R<	WLJ/#[ɖB깫^JP7m	svP&䈊ܯP:aɨZZ1.B)Fiｋ"X{5fJ2h)󌩨b9T|ETYpPQQ3rEKLvm2QSGJgg$}3TU#"T"ӤHGT{&MnPtT:qZh%$ɺ;!zT2}RlIvb,őjsadY4|gyVϢBAπBKEO`!!.UBQR(EDBRaV7tRx@MxO_=*iGLG(,Q,G:>	YZr%mlU1MMdȪL,j`!ː:;&mXz^$v^M(xcǢZ9uV)2\b}:|-{q^ɨl24'yO"U;X@hJF"37E	֝.XK#O9ٚC\>{~(	tK	챘T}[j~Y)4J@hj=;gP4@kՔ{@T;aFocЙ(&P<)X^7[@MOՍ޻Rs?ԻFwt'G&dԻj)7Qx}U4/g5˅~5za.6|vu3R@Nej.ZUmq+,֙;ĀYCp- ';IU8ONM'ᝩj>'Nv>/TLydLVZ=~甮~aɧ޻R݆Ih!# zZAhne$$(d8ΣD/8,ֹM{Kk|}!41v'ch:+^>&I2RYeF R|=~Ch9z6uwfRe}}'~9L3RK@"fq\~*Tw 놙o\ǤVa59X<?0Tmo-SHqg
N	f<N#9'yBΜٓPWs<|S=2D;*ڟ*>s=]hj-R!4)<5(q<0ރ*Rùt'ʵ`QPN8,6C+|5?V}UO&x	hB'LlyJWOgM4S-xyfiʩǡUC":Iő)ޜTJ8b:}N9-)Z#Le۟Ok;W }WIWEA]eP#7z9QQ7T8Wl.)tHEaI]J'bmJGg72jdǯy<J'f:%ToJU~6MvMݤLFzD!/ˣ:d$5**i))'i(lJlLU.@ޤ'`($AtK c{YwMA4!s:|mLvH;'GkOy1JfK)(RiQJ<	(<߆~iMT@=0_k747uH=[?@+3Q:|Χ9)N@7Stt٦'{N<l^2*qǊ2_F'tdGFO,'T{hFX)H4RK?4Hg%N*Fnt0tPEcI:X=C#)k+BzY)M~[	"ݓQ =lWI(EBTJ&Jpja)Rpz$i>%K'T\T:qޖؿ]@y4.rrM
3A:iCthE9s/](tRaE-[0aTIoY+2|Jt9SeTM'xʦh,)G:|o;jɗp\Mt*4:cfvnlf+uB[$E}) `l[@:P"`@+qJr5epo>_%NJn"rjUw'4z"`짣Zz8Y=էxHtF/,~g[LSzt~^HqcPP[`e.DM4FɯvHjixd)D*G<qč/aST4AkY@gҸbX?Xy)e}yCh-+!H>g3R[$RZ$|ƻRMJn	\tYg	x:v!_.D1N"S)	z.|G8S3h%&}cHWY !vMNaIqTB֓  Mu4FDs.oXtڍ!M#ɹǮdq.S,lr4
13.B/d.6@S}W=sn-{,NB0Ͼnjŕua, \Om.9eeu䌓@FȁU