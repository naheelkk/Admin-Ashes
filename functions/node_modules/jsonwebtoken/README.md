# jsonwebtoken

| **Build**                                                                                                                               | **Dependency**                                                                                                         |
|-----------------------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------|
| [![Build Status](https://secure.travis-ci.org/auth0/node-jsonwebtoken.svg?branch=master)](http://travis-ci.org/auth0/node-jsonwebtoken) | [![Dependency Status](https://david-dm.org/auth0/node-jsonwebtoken.svg)](https://david-dm.org/auth0/node-jsonwebtoken) |


An implementation of [JSON Web Tokens](https://tools.ietf.org/html/rfc7519).

This was developed against `draft-ietf-oauth-json-web-token-08`. It makes use of [node-jws](https://github.com/brianloveswords/node-jws)

# Install

```bash
$ npm install jsonwebtoken
```

# Migration notes

* [From v8 to v9](https://github.com/auth0/node-jsonwebtoken/wiki/Migration-Notes:-v8-to-v9)
* [From v7 to v8](https://github.com/auth0/node-jsonwebtoken/wiki/Migration-Notes:-v7-to-v8)

# Usage

### jwt.sign(payload, secretOrPrivateKey, [options, callback])

(Asynchronous) If a callback is supplied, the callback is called with the `err` or the JWT.

(Synchronous) Returns the JsonWebToken as string

`payload` could be an object literal, buffer or string representing valid JSON. 
> **Please _note_ that** `exp` or any other claim is only set if the payload is an object literal. Buffer or string payloads are not checked for JSON validity.

> If `payload` is not a buffer or a string, it will be coerced into a string using `JSON.stringify`.

`secretOrPrivateKey` is a string (utf-8 encoded), buffer, object, or KeyObject containing either the secret for HMAC algorithms or the PEM
encoded private key for RSA and ECDSA. In case of a private key with passphrase an object `{ key, passphrase }` can be used (based on [crypto documentation](https://nodejs.org/api/crypto.html#crypto_sign_sign_private_key_output_format)), in this case be sure you pass the `algorithm` option.
When signing with RSA algorithms the minimum modulus length is 2048 except when the allowInsecureKeySizes option is set to true. Private keys below this size will be rejected with an error.

`options`:

* `algorithm` (default: `HS256`)
* `expiresIn`: expressed in seconds or a string describing a time span [vercel/ms](https://github.com/vercel/ms). 
  > Eg: `60`, `"2 days"`, `"10h"`, `"7d"`. A numeric value is interpreted as a seconds count. If you use a string be sure you provide the time units (days, hours, etc), otherwise milliseconds unit is used by default (`"120"` is equal to `"120ms"`).
* `notBefore`: expressed in seconds or a string describing a time span [vercel/ms](https://github.com/vercel/ms). 
  > Eg: `60`, `"2 days"`, `"10h"`, `"7d"`. A numeric value is interpreted as a seconds count. If you use a string be sure you provide the time units (days, hours, etc), otherwise milliseconds unit is used by default (`"120"` is equal to `"120ms"`).
* `audience`
* `issuer`
* `jwtid`
* `subject`
* `noTimestamp`
* `header`
* `keyid`
* `mutatePayload`: if true, the sign function will modify the payload object directly. This is useful if you need a raw reference to the payload after claims have been applied to it but before it has been encoded into a token.
* `allowInsecureKeySizes`: if true allows private keys with a modulus below 2048 to be used for RSA
* `allowInvalidAsymmetricKeyTypes`: if true, allows asymmetric keys which do not match the specified algorithm. This option is intended only for backwards compatability and should be avoided.



> There are no default values for `expiresIn`, `notBefore`, `audience`, `subject`, `issuer`.  These claims can also be provided in the payload directly with `exp`, `nbf`, `aud`, `sub` and `iss` respectively, but you **_can't_** include in both places.

Remember that `exp`, `nbf` and `iat` are **NumericDate**, see related [Token Expiration (exp claim)](#token-expiration-exp-claim)


The header can be customized via the `options.header` object.

Generated jwts will include an `iat` (issued at) claim by default unless `noTimestamp` is specified. If `iat` is inserted in the payload, it will be used instead of the real timestamp for calculating other things like `exp` given a timespan in `options.expiresIn`.

Synchronous Sign with default (HMAC SHA256)

```js
var jwt = require('jsonwebtoken');
var token = jwt.sign({ foo: 'bar' }, 'shhhhh');
```

Synchronous Sign with RSA SHA256
```js
// sign with RSA SHA256
var privateKey = fs.readFileSync('private.key');
var token = jwt.sign({ foo: 'bar' }, privateKey, { algorithm: 'RS256' });
```

Sign asynchronously
```js
jwt.sign({ foo: 'bar' }, privateKey, { algorithm: 'RS256' }, function(err, token) {
  console.log(token);
});
```

Backdate a jwt 30 seconds
```js
var older_token = jwt.sign({ foo: 'bar', iat: Math.floor(Date.now() / 1000) - 30 }, 'shhhhh');
```

#### Token Expiration (exp claim)

The standard for JWT defines an `exp` claim for expiration. The expiration is represented as a **NumericDate**:

> A JSON numeric value representing the number of seconds from 1970-01-01T00:00:00Z UTC until the specified UTC date/time, ignoring leap seconds.  This is equivalent to the IEEE Std 1003.1, 2013 Edition [POSIX.1] definition "Seconds Since the Epoch", in which each day is accounted for by exactly 86400 seconds, other than that non-integer values can be represented.  See RFC 3339 [RFC3339] for details regarding date/times in general and UTC in particular.

This means that the `exp` field should contain the number of seconds since the epoch.

Signing a token with 1 hour of expiration:

```javascript
jwt.sign({
  exp: Math.floor(Date.now() / 1000) + (60 * 60),
  data: 'foobar'
}, 'secret');
```

Another way to generate a token like this with this library is:

```javascript
jwt.sign({
  data: 'foobar'
}, 'secret', { expiresIn: 60 * 60 });

//or even better:

jwt.sign({
  data: 'foobar'
}, 'secret', { expiresIn: '1h' });
```

### jwt.verify(token, secretOrPublicKey, [options, callback])

(Asynchronous) If a callback is supplied, function acts asynchronously. The callback is called with the decoded payload if the signature is valid and optional expiration, audience, or issuer are valid. If not, it will be called with the error.

(Synchronous) If a callback is not supplied, function acts synchronously. Returns the payload decoded if the signature is valid and optional expiration, audience, or issuer are valid. If not, it will throw the error.

> __Warning:__ When the token comes from an untrusted source (e.g. user input or external requests), the returned decoded payload should be treated like any other user input; please make sure to sanitize and only work with properties that are expected

`token` is the JsonWebToken string

`secretOrPublicKey` is a string (utf-8 encoded), buffer, or KeyObject containing either the secret for HMAC algorithms, or the PEM
encoded public key for RSA and ECDSA.
If `jwt.verify` is called asynchronous, `secretOrPublicKey` can be a function that should fetch the secret or public key. See below for a detailed example

As mentioned in [this comment](https://github.com/auth0/node-jsonwebtoken/issues/208#issuecomment-231861138), there are other libraries that expect base64 encoded secrets (random bytes encoded using base64), if that is your case you can pass `Buffer.from(secret, 'base64')`, by doing this the secret will be decoded using base64 and the token verification will use the original random bytes.

`options`

* `algorithms`: List of strings with the names of the allowed algorithms. For instance, `["HS256", "HS384"]`. 
  > If not specified a defaults will be used based on the type of key provided
  > * secret - ['HS256', 'HS384', 'HS512']
  > * rsa - ['RS256', 'RS384', 'RS512']
  > * ec - ['ES256', 'ES384', 'ES512']
  > * default - ['RS256', 'RS384', 'RS512']
* `audience`: if you want to check audience (`aud`), provide a value here. The audience can be checked against a string, a regular expression or a list of strings and/or regular expressions. 
  > Eg: `"urn:foo"`, `/urn:f[o]{2}/`, `[/urn:f[o]{2}/, "urn:bar"]`
* `complete`: return an object with the decoded `{ payload, header, signature }` instead of only the usual content of the payload.
* `issuer` (optional): string or array of strings of valid values for the `iss` field.
* `jwtid` (optional): if you want to check JWT ID (`jti`), provide a string value here.
* `ignoreExpiration`: if `true` do not validate the expiration of the token.
* `ignoreNotBefore`...
* `subject`: if you want to check subject (`sub`), provide a value here
* `clockTolerance`: number of seconds to tolerate when checking the `nbf` and `exp` claims, to deal with small clock differences among different servers
* `maxAge`: the maximum allowed age for tokens to still be valid. It is expressed in seconds or a string describing a time span [vercel/ms](https://github.com/vercel/ms). 
  > Eg: `1000`, `"2 days"`, `"10h"`, `"7d"`. A numeric value is interpreted as a seconds count. If you use a string be sure you provide the time units (days, hours, etc), otherwise milliseconds unit is used by default (`"120"` is equal to `"120ms"`).
* `clockTimestamp`: the time in seconds that should be used as the current time for all necessary comparisons.
* `nonce`: if you want to check `nonce` claim, provide a string value here. It is used on Open ID for the ID Tokens. ([Open ID implementation notes](https://openid.net/specs/openid-connect-core-1_0.html#NonceNotes))
* `allowInvalidAsymmetricKeyTypes`: if true, allows asymmetric keys which do not match the specified algorithm. This option is intended only for backwards compatability and should be avoided.

```js
// verify a token symmetric - synchronous
var decoded = jwt.verify(token, 'shhhhh');
console.log(decoded.foo) // bar

// verify a token symmetric
jwt.verify(token, 'shhhhh', function(err, decoded) {
  console.log(decoded.foo) // bar
});

// invalid token - synchronous
try {
  var decoded = jwt.verify(token, 'wrong-secret');
} catch(err) {
  // err
}

// invalid token
jwt.verify(token, 'wrong-secret', function(err, decoded) {
  // err
  // decoded undefined
});

// verify a token asymmetric
var cert = fs.readFileSync('public.pem');  // get public key
jwt.verify(token, cert, function(err, decoded) {
  console.log(decoded.foo) // bar
});

// verify audience
var cert = fs.readFileSync('public.pem');  // get public key
jwt.verify(token, cert, { audience: 'urn:foo' }, function(err, decoded) {
  // if audience mismatch, err == invalid audience
});

// verify issuer
var cert = fs.readFileSync('public.pem');  // get public key
jwt.verify(token, cert, { audience: 'urn:foo', issuer: 'urn:issuer' }, function(err, decoded) {
  // if issuer mismatch, err == invalid issuer
});

// verify jwt id
var cert = fs.readFileSync('public.pem');  // get public key
jwt.verify(token, cert, { audience: 'urn:foo', issuer: 'urn:issuer', jwtid: 'jwtid' }, function(err, decoded) {
  // if jwt id mismatch, err == invalid jwt id
});

// verify subject
var cert = fs.readFileSync('public.pem');  // get public key
jwt.verify(token, cert, { audience: 'urn:foo', issuer: 'urn:issuer', jwtid: 'jwtid', subject: 'subject' }, function(err, decoded) {
  // if subject mismatch, err == invalid subject
});

// alg mismatch
var cert = fs.readFileSync('public.pem'); // get public key
jwt.verify(token, cert, { algorithms: ['RS256'] }, function (err, payload) {
  // if token alg != RS256,  err == invalid signature
});

// Verify using getKey callback
// Example uses https://github.com/auth0/node-jwks-rsa as a way to fetch the keys.
var jwksClient = require('jwks-rsa');
var client = jwksClient({
  jwksUri: 'https://sandrino.auth0.com/.well-known/jwks.json'
});
function getKey(header, callback){
  client.getSigningKey(header.kid, function(err, key) {
    var signingKey = key.publicKey || key.rsaPublicKey;
    callback(null, signingKey);
  });
}

jwt.verify(token, getKey, options, function(err, decoded) {
  console.log(decoded.foplace.Storefront.Contracts","ProductId":"9PGBVVFWVWJN","TileLayout":"Square","Title":"Data Recovery +","Images":[{"$type":"Microsoft.Marketplace.Storefront.Contracts.V2.ImageItem, Microsoft.Marketplace.Storefront.Contracts","ImageType":"tile","BackgroundColor":"transparent","ForegroundColor":"","Caption":"","ImagePositionInfo":"","Url":"https://store-images.s-microsoft.com/image/apps.20724.14183869940340167.108eb5fb-98b0-48d4-86f7-9edf3deb4c39.e7232b5b-1177-46bf-b045-834f036e167c","Height":300,"Width":300},{"$type":"Microsoft.Marketplace.Storefront.Contracts.V2.ImageItem, Microsoft.Marketplace.Storefront.Contracts","ImageType":"tile","BackgroundColor":"transparent","ForegroundColor":"","Caption":"","ImagePositionInfo":"","Url":"https://store-images.s-microsoft.com/image/apps.5483.14183869940340167.108eb5fb-98b0-48d4-86f7-9edf3deb4c39.42d80a37-e1b4-495d-9d46-27338f5c2964","Height":300,"Width":620},{"$type":"Microsoft.Marketplace.Storefront.Contracts.V2.ImageItem, Microsoft.Marketplace.Storefront.Contracts","ImageType":"logo","BackgroundColor":"transparent","ForegroundColor":"","Caption":"","ImagePositionInfo":"","Url":"https://store-images.s-microsoft.com/image/apps.20724.14183869940340167.108eb5fb-98b0-48d4-86f7-9edf3deb4c39.e7232b5b-1177-46bf-b045-834f036e167c","Height":300,"Width":300}],"Previews":[{"$type":"Microsoft.Marketplace.Storefront.Contracts.V2.ImageItem, Microsoft.Marketplace.Storefront.Contracts","ImageType":"Screenshot","BackgroundColor":"transparent","ForegroundColor":"","Caption":"","ImagePositionInfo":"Desktop/0","Url":"https://store-images.s-microsoft.com/image/apps.54132.14183869940340167.108eb5fb-98b0-48d4-86f7-9edf3deb4c39.e8180139-27aa-4e14-ab86-2168238b0889","Height":1080,"Width":1920}],"DisplayPrice":"Free","Price":0.0,"AverageRating":1.8,"RatingsCount":"10","Description":"professional data recovery software","PackageFamilyNames":["WuhanNetPowerTechnologyCo.2821760F37B35_63m8b6nby1dvp"],"ContentIds":["d4c5290b-1187-dc47-d657-4e5a92891763","fbed9840-aa53-4916-101d-21e3f67dad91"],"GamingOptionsXboxLive":false,"AvailableDevicesDisplayText":"  ","AvailableDevicesNarratorText":"PC,HoloLens,Mobile","TypeTag":"app","ProductFamilyName":"Apps","SkusSummary":[{"$type":"Microsoft.Marketplace.Storefront.Contracts.V8.SkuSummary, Microsoft.Marketplace.Storefront.Contracts","SkuId":"0010","MSRP":0.0,"DisplayMSRP":"Free","SalePrices":[{"$type":"Microsoft.Marketplace.Storefront.Contracts.V9.SalePrice, Microsoft.Marketplace.Storefront.Contracts","Price":0.0,"DisplayPrice":"Free","BadgeId":"default"}]},{"$type":"Microsoft.Marketplace.Storefront.Contracts.V8.SkuSummary, Microsoft.Marketplace.Storefront.Contracts","SkuId":"0011"}],"IsGamingAppOnly":false,"Categories":["Utilities & tools"],"ReleaseDate":"2021-08-30T14:52:35.4085119Z","PublisherName":"Wuhan Net Power Technology Co., Ltd","Installer":{"$type":"Microsoft.Marketplace.Storefront.Contracts.V9.Installer, Microsoft.Marketplace.Storefront.Contracts","Type":"WindowsUpdate","Id":"9PGBVVFWVWJN"},"ProductRatings":[{"$type":"Microsoft.Marketplace.Storefront.Contracts.V2.ProductRating, Microsoft.Marketplace.Storefront.Contracts","RatingSystem":"IARC","RatingSystemShortName":"IARC","RatingSystemId":"IARC","RatingSystemUrl":"https://www.globalratings.com/","RatingValue":"3+","RatingId":"IARC:3","RatingValueLogoUrl":"https://store-images.s-microsoft.com/image/global.9404.image.ddda1b2c-d334-444b-b055-e23fec6772d7.13e2dfc1-450e-4973-bcbb-f35d2cc4f4ed","RatingAge":0,"RestrictMetadata":false,"RestrictPurchase":false,"RatingDescriptors":[],"RatingDisclaimers":[],"InteractiveElements":["In-App Purchases"],"LongName":"3+","ShortName":"3+","Description":"For ages 3 and up"}],"MinimumAge":0.0,"HasIAPs":false,"CardActions":["Update","Launch","Install","Purchase"],"SupportsInstantGaming":false,"Schema":"Card;1"},{"$type":"Microsoft.Marketplace.Storefront.Contracts.V8.One.CardModel, Microsoft.Marketplace.Storefront.Contracts","ProductId":"XP9JZFJLS46DH7","TileLayout":"Square","Title":"Wise Data Recovery","Images":[{"$type":"Microsoft.Marketplace.Storefront.Contracts.V2.ImageItem, Microsoft.Marketplace.Storefront.Contracts","ImageType":"logo","Url":"https://images-eds-ssl.xboxlive.com/image?url=4rt9.lXDC4H_93laV1_eHM0OYfiFeMI2p9MWie0CvL99U4GA1gf6_kayTt_kBblFwHwo8BW8JXlqfnYxKPmmBdIyFWhEq_FUhYMVfmDuUCSWpWeXosBbVebcQ32Bva_9vxOAYRy1SCx08Jp.Mhrle0iK9ejkRsExQX.TrxgJ_vs-&format=source","Height":150,"Width":150}],"Previews":[{"$type":"Microsoft.Marketplace.Storefront.Contracts.V2.ImageItem, Microsoft.Marketplace.Storefront.Contracts","ImageType":"screenshot","ImagePositionInfo":"0","Url":"https://images-eds-ssl.xboxlive.com/image?url=4rt9.lXDC4H_93laV1_eHM0OYfiFeMI2p9MWie0CvL99U4GA1gf6_kayTt_kBblFwHwo8BW8JXlqfnYxKPmmBdIyFWhEq_FUhYMVfmDuUCQNbNk4TfQJNLQLWbKWmf8TvyMg_8Z49gqF5pFz6zHTPB2.Sk6iefeYiZaLBy.plZU-&format=source","Height":0,"Width":0}],"StrikethroughPrice":"","DisplayPrice":"Free","Price":0.0,"AverageRating":0.0,"Description":"Free to recover 2 GB of data. Easily & quickly recover deleted photos, documents, videos, emails, etc. Recover data from local drives, external drives, USB drives, SD cards, mobile phones, and other removable devices.","GamingOptionsXboxLive":false,"TypeTag":"app","ProductFamilyName":"apps","Categories":["Utilities & tools"],"PublisherName":"Lespeed Technology Co., Ltd.","Installer":{"$type":"Microsoft.Marketplace.Storefront.Contracts.V9.Installer, Mic