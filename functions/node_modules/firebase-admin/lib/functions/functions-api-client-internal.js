/*! firebase-admin v11.11.1 */
"use strict";
/*!
 * @license
 * Copyright 2021 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.FirebaseFunctionsError = exports.FUNCTIONS_ERROR_CODE_MAPPING = exports.FunctionsApiClient = void 0;
const api_request_1 = require("../utils/api-request");
const error_1 = require("../utils/error");
const utils = require("../utils/index");
const validator = require("../utils/validator");
const credential_internal_1 = require("../app/credential-internal");
const CLOUD_TASKS_API_RESOURCE_PATH = 'projects/{projectId}/locations/{locationId}/queues/{resourceId}/tasks';
const CLOUD_TASKS_API_URL_FORMAT = 'https://cloudtasks.googleapis.com/v2/' + CLOUD_TASKS_API_RESOURCE_PATH;
const FIREBASE_FUNCTION_URL_FORMAT = 'https://{locationId}-{projectId}.cloudfunctions.net/{resourceId}';
const FIREBASE_FUNCTIONS_CONFIG_HEADERS = {
    'X-Firebase-Client': `fire-admin-node/${utils.getSdkVersion()}`
};
// Default canonical location ID of the task queue.
const DEFAULT_LOCATION = 'us-central1';
/**
 * Class that facilitates sending requests to the Firebase Functions backend API.
 *
 * @internal
 */
class FunctionsApiClient {
    constructor(app) {
        this.app = app;
        if (!validator.isNonNullObject(app) || !('options' in app)) {
            throw new FirebaseFunctionsError('invalid-argument', 'First argument passed to getFunctions() must be a valid Firebase app instance.');
        }
        this.httpClient = new api_request_1.AuthorizedHttpClient(app);
    }
    /**
     * Deletes a task from a queue.
     *
     * @param id - The ID of the task to delete.
     * @param functionName - The function name of the queue.
     * @param extensionId - Optional canonical ID of the extension.
     */
    async delete(id, functionName, extensionId) {
        if (!validator.isNonEmptyString(functionName)) {
            throw new FirebaseFunctionsError('invalid-argument', 'Function name must be a non empty string');
        }
        if (!validator.isTaskId(id)) {
            throw new FirebaseFunctionsError('invalid-argument', 'id can contain only letters ([A-Za-z]), numbers ([0-9]), '
                + 'hyphens (-), or underscores (_). The maximum length is 500 characters.');
        }
        let resources;
        try {
            resources = utils.parseResourceName(functionName, 'functions');
        }
        catch (err) {
            throw new FirebaseFunctionsError('invalid-argument', 'Function name must be a single string or a qualified resource name');
        }
        resources.projectId = resources.projectId || await this.getProjectId();
        resources.locationId = resources.locationId || DEFAULT_LOCATION;
        if (!validator.isNonEmptyString(resources.resourceId)) {
            throw new FirebaseFunctionsError('invalid-argument', 'No valid function name specified to enqueue tasks for.');
        }
        if (typeof extensionId !== 'undefined' && validator.isNonEmptyString(extensionId)) {
            resources.resourceId = `ext-${extensionId}-${resources.resourceId}`;
        }
        try {
            const serviceUrl = await this.getUrl(resources, CLOUD_TASKS_API_URL_FORMAT.concat('/', id));
            const request = {
                method: 'DELETE',
                url: serviceUrl,
                headers: FIREBASE_FUNCTIONS_CONFIG_HEADERS,
            };
            await this.httpClient.send(request);
        }
        catch (err) {
            if (err instanceof api_request_1.HttpError) {
                if (err.response.status === 404) {
                    // if no task with the provided ID exists, then ignore the delete.
                    return;
                }
                throw this.toFirebaseError(err);
            }
            else {
                throw err;
            }
        }
    }
    /**
     * Creates a task and adds it to a queue.
     *
     * @param data - The data payload of the task.
     * @param functionName - The functionName of the queue.
     * @param extensionId - Optional canonical ID of the extension.
     * @param opts - Optional options when enqueuing a new task.
     */
    async enqueue(data, functionName, extensionId, opts) {
        if (!validator.isNonEmptyString(functionName)) {
            throw new FirebaseFunctionsError('invalid-argument', 'Function name must be a non empty string');
        }
        let resources;
        try {
            resources = utils.parseResourceName(functionName, 'functions');
        }
        catch (err) {
            throw new FirebaseFunctionsError('invalid-argument', 'Function name must be a single string or a qualified resource name');
        }
        resources.projectId = resources.projectId || await this.getProjectId();
        resources.locationId = resources.locationId || DEFAULT_LOCATION;
        if (!validator.isNonEmptyString(resources.resourceId)) {
            throw new FirebaseFunctionsError('invalid-argument', 'No valid function name specified to enqueue tasks for.');
        }
        if (typeof extensionId !== 'undefined' && validator.isNonEmptyString(extensionId)) {
            resources.resourceId = `ext-${extensionId}-${resources.resourceId}`;
        }
        const task = this.validateTaskOptions(data, resources, opts);
        try {
            const serviceUrl = await this.getUrl(resources, CLOUD_TASKS_API_URL_FORMAT);
            const taskPayload = await this.updateTaskPayload(task, resources, extensionId);
            const request = {
                method: 'POST',
                url: serviceUrl,
                headers: FIREBASE_FUNCTIONS_CONFIG_HEADERS,
                data: {
                    task: taskPayload,
                }
            };
            await this.httpClient.send(request);
        }
        catch (err) {
            if (err instanceof api_request_1.HttpError) {
                if (err.response.status === 409) {
                    throw new FirebaseFunctionsError('task-already-exists', `A task with ID ${opts?.id} already exists`);
                }
                else {
                    throw this.toFirebaseError(err);
                }
            }
            else {
                throw err;
            }
        }
    }
    getUrl(resourceName, urlFormat) {
        let { locationId } = resourceName;
        const { projectId, resourceId } = resourceName;
        if (typeof locationId === 'undefined' || !validator.isNonEmptyString(locationId)) {
            locationId = DEFAULT_LOCATION;
        }
        return Promise.resolve()
            .then(() => {
            if (typeof projectId !== 'undefined' && validator.isNonEmptyString(projectId)) {
                return projectId;
            }
            return this.getProjectId();
        })
            .then((projectId) => {
            const urlParams = {
                projectId,
                locationId,
                resourceId,
            };
            // Formats a string of form 'project/{projectId}/{api}' and replaces
            // with corresponding arguments {projectId: '1234', api: 'resource'}
            // and returns output: 'project/1234/resource'.
            return utils.formatString(urlFormat, urlParams);
        });
    }
    getProjectId() {
        if (this.projectId) {
            return Promise.resolve(this.projectId);
        }
        return utils.findProjectId(this.app)
            .then((projectId) => {
            if (!validator.isNonEmptyString(projectId)) {
                throw new FirebaseFunctionsError('unknown-error', 'Failed to determine project ID. Initialize the '
                    + 'SDK with service account credentials or set project ID as an app option. '
                    + 'Alternatively, set the GOOGLE_CLOUD_PROJECT environment variable.');
            }
            this.projectId = projectId;
            return projectId;
        });
    }
    getServiceAccount() {
        if (this.accountId) {
            return Promise.resolve(this.accountId);
        }
        return utils.findServiceAccountEmail(this.app)
            .then((accountId) => {
            if (!validator.isNonEmptyString(accountId)) {
                throw new FirebaseFunctionsError('unknown-error', 'Failed to determine service account. Initialize the '
                    + 'SDK with service account credentials or set service account ID as an app option.');
            }
            this.accountId = accountId;
            return accountId;
        });
    }
    validateTaskOptions(data, resources, opts) {
        const task = {
            httpRequest: {
                url: '',
                oidcToken: {
                    serviceAccountEmail: '',
                },
                body: Buffer.from(JSON.stringify({ data })).toString('base64'),
                headers: {
                    'Content-Type': 'application/json',
                    ...opts?.headers,
                }
            }
        };
        if (typeof opts !== 'undefined') {
            if (!validator.isNonNullObject(opts)) {
                throw new FirebaseFunctionsError('invalid-argument', 'TaskOptions must be a non-null object');
            }
            if ('scheduleTime' in opts && 'scheduleDelaySeconds' in opts) {
                throw new FirebaseFunctionsError('invalid-argument', 'Both scheduleTime and scheduleDelaySeconds are provided. '
                    + 'Only one value should be set.');
            }
            if ('scheduleTime' in opts && typeof opts.scheduleTime !== 'undefined') {
                if (!(opts.scheduleTime instanceof Date)) {
                    throw new FirebaseFunctionsError('invalid-argument', 'scheduleTime must be a valid Date object.');
                }
                task.scheduleTime = opts.scheduleTime.toISOString();
            }
            if ('scheduleDelaySeconds' in opts && typeof opts.scheduleDelaySeconds !== 'undefined') {
                if (!validator.isNumber(opts.scheduleDelaySeconds) || opts.scheduleDelaySeconds < 0) {
                    throw new FirebaseFunctionsError('invalid-argument', 'scheduleDelaySeconds must be a non-negative duration in seconds.');
                }
                const date = new Date();
                date.setSeconds(date.getSeconds() + opts.scheduleDelaySeconds);
                task.scheduleTime = date.toISOString();
            }
            if (typeof opts.dispatchDeadlineSeconds !== 'undefined') {
                if (!validator.isNumber(opts.dispatchDeadlineSeconds) || opts.dispatchDeadlineSeconds < 15
                    || opts.dispatchDeadlineSeconds > 1800) {
                    throw new FirebaseFunctionsError('invalid-argument', 'dispatchDeadlineSeconds must be a non-negative duration in seconds '
                        + 'and must be in the range of 15s to 30 mins.');
                }
                task.dispatchDeadline = `${opts.dispatchDeadlineSeconds}s`;
            }
            if ('id' in opts && typeof opts.id !== 'undefined') {
                if (!validator.isTaskId(opts.id)) {
                    throw new FirebaseFunctionsError('invalid-argument', 'id can contain only letters ([A-Za-z]), numbers ([0-9]), '
                        + 'hyphens (-), or underscores (_). The maximum length is 500 characters.');
                }
                const resourcePath = utils.formatString(CLOUD_TASKS_API_RESOURCE_PATH, {
                    projectId: resources.projectId,
                    locationId: resources.locationId,
                    resourceId: resources.resourceId,
                });
                task.name = resourcePath.concat('/', opts.id);
            }
            if (typeof opts.uri !== 'undefined') {
           ,p=n(i,["autoFocus","disabled","form","formAction","formEncType","formMethod","formNoValidate","formTarget","type","value"]),h=n(p,["accept","alt","autoCapitalize","autoComplete","checked","dirname","form","height","inputMode","list","max","maxLength","min","minLength","multiple","pattern","placeholder","readOnly","required","src","step","size","type","value","width"]),g=n(p,["autoCapitalize","cols","dirname","form","maxLength","minLength","placeholder","readOnly","required","rows","wrap"]),m=n(p,["form","multiple","required"]),v=n(i,["selected","value"]),b=n(i,["cellPadding","cellSpacing"]),y=i,w=n(i,["rowSpan","scope"]),k=n(i,["colSpan","headers","rowSpan","scope"]),C=n(i,["span"]),S=n(i,["span"]),x=n(i,["acceptCharset","action","encType","encType","method","noValidate","target"]),E=n(i,["allow","allowFullScreen","allowPaymentRequest","allowTransparency","csp","height","importance","referrerPolicy","sandbox","src","srcDoc","width"]),_=n(i,["alt","crossOrigin","height","src","srcSet","useMap","width"]);function T(e,t,r){for(var n=Array.isArray(t),o={},a=0,i=Object.keys(e);a<i.length;a++){var l=i[a];!(!n&&t[l]||n&&t.indexOf(l)>=0||0===l.indexOf("data-")||0===l.indexOf("aria-"))||r&&-1!==(null==r?void 0:r.indexOf(l))||(o[l]=e[l])}return o}},88068:(e,t,r)=>{"use strict";r.d(t,{L:()=>a,r:()=>o});var n=r(18630);function o(e){var t=null;try{var r=(0,n.J)();t=r?r.sessionStorage.getItem(e):null}catch(e){}return t}function a(e,t){var r;try{null===(r=(0,n.J)())||void 0===r||r.sessionStorage.setItem(e,t)}catch(e){}}},83362:(e,t,r)=>{"use strict";r.d(t,{s:()=>a});var n=r(19543),o=r(55141);function a(e,t,r=n.F){const a=r();let i=null,l=null;return function(r){const{dir:n,renderer:s}=r,c="ltr"===n;return c?null===i&&(i=(0,o.V)(e,n)):null===l&&(l=(0,o.V)(e,n)),a(s,t),c?i:l}}},53536:(e,t,r)=>{"use strict";r.d(t,{$Q:()=>l,C_:()=>g,Hf:()=>s,JM:()=>p,M_:()=>d,Qz:()=>u,de:()=>h,gk:()=>c,jD:()=>f,xR:()=>i});const n="undefined"==typeof window?r.g:window,o="@griffel/";function a(e,t){return n[Symbol.for(o+e)]||(n[Symbol.for(o+e)]=t),n[Symbol.for(o+e)]}const i=a("DEFINITION_LOOKUP_TABLE",{}),l="data-make-styles-bucket",s="f",c=7,u="___",d="_",f=u.length+c,p=0,h=1,g={all:1,animation:1,background:1,backgroundPosition:1,border:1,borderBlock:1,borderBlockEnd:1,borderBlockStart:1,borderBottom:1,borderColor:1,borderImage:1,borderInline:1,borderInlineEnd:1,borderInlineStart:1,borderLeft:1,borderRadius:1,borderRight:1,borderStyle:1,borderTop:1,borderWidth:1,caret:1,columns:1,columnRule:1,containIntrinsicSize:1,container:1,flex:1,flexFlow:1,font:1,gap:1,grid:1,gridArea:1,gridColumn:1,gridRow:1,gridTemplate:1,inset:1,insetBlock:1,insetInline:1,lineClamp:1,listStyle:1,margin:1,marginBlock:1,marginInline:1,mask:1,maskBorder:1,motion:1,offset:1,outline:1,overflow:1,overscrollBehavior:1,padding:1,paddingBlock:1,paddingInline:1,placeItems:1,placeContent:1,placeSelf:1,scrollMargin:1,scrollMarginBlock:1,scrollMarginInline:1,scrollPadding:1,scrollPaddingBlock:1,scrollPaddingInline:1,scrollSnapMargin:1,scrollTimeline:1,textDecoration:1,textEmphasis:1,transition:1}},96698:(e,t,r)=>{"use strict";r.d(t,{q5:()=>w});const n=["Top","Right","Bottom","Left"];function o(e,t,...r){const[o,a=o,i=o,l=a]=r,s=[o,a,i,l],c={};for(let r=0;r<s.length;r+=1)(s[r]||0===s[r])&&(c[