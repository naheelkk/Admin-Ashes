{"v":"5.6.5","fr":25,"ip":0,"op":100,"w":640,"h":540,"nm":"TB banner","ddd":0,"assets":[{"id":"image_0","w":640,"h":540,"u":"images/","p":"img_0.png","e":0},{"id":"image_1","w":640,"h":540,"u":"images/","p":"img_1.png","e":0},{"id":"image_2","w":65,"h":37,"u":"images/","p":"img_2.png","e":0},{"id":"image_3","w":640,"h":540,"u":"images/","p":"img_3.png","e":0},{"id":"image_4","w":48,"h":31,"u":"images/","p":"img_4.png","e":0},{"id":"image_5","w":640,"h":540,"u":"images/","p":"img_5.png","e":0},{"id":"image_6","w":640,"h":540,"u":"images/","p":"img_6.png","e":0},{"id":"image_7","w":640,"h":540,"u":"images/","p":"img_7.png","e":0},{"id":"image_8","w":640,"h":540,"u":"images/","p":"img_8.png","e":0},{"id":"image_9","w":640,"h":540,"u":"images/","p":"img_9.png","e":0},{"id":"image_10","w":640,"h":540,"u":"images/","p":"img_10.png","e":0},{"id":"image_11","w":640,"h":540,"u":"images/","p":"img_11.png","e":0},{"id":"image_12","w":640,"h":540,"u":"images/","p":"img_12.png","e":0},{"id":"image_13","w":640,"h":540,"u":"images/","p":"img_13.png","e":0},{"id":"image_14","w":640,"h":540,"u":"images/","p":"img_14.png","e":0},{"id":"image_15","w":640,"h":540,"u":"images/","p":"img_15.png","e":0},{"id":"image_16","w":640,"h":540,"u":"images/","p":"img_16.png","e":0},{"id":"image_17","w":12,"h":27,"u":"images/","p":"img_17.png","e":0},{"id":"image_18","w":640,"h":540,"u":"images/","p":"img_18.png","e":0},{"id":"image_19","w":54,"h":32,"u":"images/","p":"img_19.png","e":0},{"id":"image_20","w":640,"h":540,"u":"images/","p":"img_20.png","e":0},{"id":"image_21","w":12,"h":27,"u":"images/","p":"img_21.png","e":0},{"id":"image_22","w":640,"h":540,"u":"images/","p":"img_22.png","e":0},{"id":"image_23","w":54,"h":32,"u":"images/","p":"img_23.png","e":0},{"id":"image_24","w":640,"h":540,"u":"images/","p":"img_24.png","e":0},{"id":"image_25","w":640,"h":540,"u":"images/","p":"img_25.png","e":0},{"id":"image_26","w":640,"h":540,"u":"images/","p":"img_26.png","e":0},{"id":"image_27","w":640,"h":540,"u":"images/","p":"img_27.png","e":0},{"id":"image_28","w":640,"h":540,"u":"images/","p":"img_28.png","e":0},{"id":"image_29","w":640,"h":540,"u":"images/","p":"img_29.png","e":0},{"id":"image_30","w":640,"h":540,"u":"images/","p":"img_30.png","e":0},{"id":"image_31","w":240,"h":197,"u":"images/","p":"img_31.png","e":0},{"id":"image_32","w":640,"h":540,"u":"images/","p":"img_32.png","e":0},{"id":"image_33","w":49,"h":33,"u":"images/","p":"img_33.png","e":0},{"id":"image_34","w":640,"h":540,"u":"images/","p":"img_34.png","e":0},{"id":"image_35","w":640,"h":540,"u":"images/","p":"img_35.png","e":0},{"id":"image_36","w":640,"h":540,"u":"images/","p":"img_36.png","e":0},{"id":"image_37","w":640,"h":540,"u":"images/","p":"img_37.png","e":0},{"id":"comp_0","layers":[{"ddd":0,"ind":1,"ty":4,"nm":"“摄像头”轮廓","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":0,"s":[0]},{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":8.334,"s":[-15.724]},{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":25,"s":[-15.724]},{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":33.334,"s":[0]},{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":50,"s":[0]},{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":58.334,"s":[12.877]},{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":75,"s":[12.877]},{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":83.334,"s":[0]},{"t":100,"s":[0]}],"ix":10},"p":{"a":0,"k":[389.854,63.075,0],"ix":2},"a":{"a":0,"k":[49.584,20.986,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[-0.919,-2.601],[0,0],[11.852,1.235]],"o":[[1.093,1.669],[0,0],[0,0],[0,0]],"v":[[15.711,-10.756],[18.762,-4.4],[-3.123,8.753],[-18.762,9.52]],"c":true},"ix":2},"nm":"路径 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.910000011968,0.936999990426,0.936999990426,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"填充 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[30.822,19.777],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"变换"}],"nm":"组 1","np":4,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[-1.757,4.823],[0,0],[-5.344,-15.127],[0,0],[16.396,2.631]],"o":[[0,0],[0,0],[0,0],[0,0],[0,0]],"v":[[-22.91,5.736],[9.881,-13.117],[24.667,-0.328],[2.781,12.824],[-18.592,12.824]],"c":true},"ix":2},"nm":"路径 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.952999997606,0.984000052658,0.984000052658,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"填充 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[24.917,15.706],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"变换"}],"nm":"组 2","np":4,"cix":2,"bm":0,"ix":2,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[-0.951,-0.511],[0,-1.023],[0.879,0.512],[0,1.023]],"o":[[0.879,0.512],[0,1.023],[-0.878,-0.512],[-0.074,-1.023]],"v":[[0.037,-1.864],[1.647,0.913],[0.037,1.863],[-1.573,-0.914]],"c":true},"ix":2},"nm":"路径 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.808000033509,0.944999964097,1,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"填充 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[11.778,32.294],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"变换"}],"nm":"组 3","np":4,"cix":2,"bm":0,"ix":3,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[-1.244,-0.731],[0,-1.461],[1.245,0.731],[0,1.462]],"o":[[1.245,0.73],[0,1.388],[-1.244,-0.731],[0,-1.388]],"v":[[0.037,-2.558],[2.232,1.316],[-0.037,2.558],[-2.232,-1.316]],"c":true},"ix":2},"nm":"路径 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.090000002992,0.176000004189,0.416000007181,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"填充 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[11.778,32.257],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"变换"}],"nm":"组 4","np":4,"cix":2,"bm":0,"ix":4,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0.439,-0.292],[0,0],[0,0.73],[1.172,0.731],[0,0],[0,-1.462]],"o":[[0,0],[0.366,-0.219],[0,-1.389],[0,0],[1.245,0.73],[0,0.731]],"v":[[1.208,2.228],[-0.33,3.105],[0.329,1.645],[-1.867,-2.229],[-0.33,-3.105],[1.867,0.767]],"c":true},"ix":2},"nm":"路径 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.310000011968,0.458999992819,0.689999988032,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"填充 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[13.681,31.856],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"变换"}],"nm":"组 5","np":4,"cix":2,"bm":0,"ix":5,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0.439,-0.292],[0,0],[-0.658,-0.366],[0,0]],"o":[[0,0],[0.44,-0.219],[0,0],[-0.658,-0.365]],"v":[[-1.573,0.475],[-0.036,-0.402],[1.573,-0.255],[0.036,0.621]],"c":true},"ix":2},"nm":"路径 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.310000011968,0.458999992819,0.689999988032,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"填充 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[11.778,29.078],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"变换"}],"nm":"组 6","np":4,"cix":2,"bm":0,"ix":6,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[-0.22,-0.073],[-0.22,-0.293],[0.293,-0.146],[0.22,0.146],[0.22,0.292],[-0.293,0.146]],"o":[[0.22,0.146],[0.293,0.511],[-0.147,0.073],[-0.22,-0.146],[-0.293,-0.511],[0.147,-0.073]],"v":[[0.001,-0.877],[0.586,-0.292],[0.586,0.95],[0.001,0.877],[-0.586,0.292],[-0.586,-0.95]],"c":true},"ix":2},"nm":"路径 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[1,0.902000038297,0.635000011968,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"填充 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[17.451,36.934],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"变换"}],"nm":"组 7","np":4,"cix":2,"bm":0,"ix":7,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[-0.439,-0.292],[0,-0.511],[0.438,0.292],[0,0.512]],"o":[[0.438,0.219],[0,0.512],[-0.439,-0.22],[0,-0.511]],"v":[[0.001,-0.914],[0.806,0.474],[0.001,0.914],[-0.806,-0.475]],"c":true},"ix":2},"nm":"路径 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[1,0.902000038297,0.635000011968,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"填充 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[8.448,27.544],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"变换"}],"nm":"组 8","np":4,"cix":2,"bm":0,"ix":8,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[-0.439,-0.292],[0,-0.511],[0.438,0.292],[0,0.512]],"o":[[0.438,0.219],[0,0.512],[-0.439,-0.22],[0,-0.511]],"v":[[0.001,-0.914],[0.806,0.474],[0.001,0.914],[-0.806,-0.475]],"c":true},"ix":2},"nm":"路径 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[1,0.902000038297,0.635000011968,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"填充 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[18.988,33.609],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"变换"}],"nm":"组 9","np":4,"cix":2,"bm":0,"ix":9,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[-0.22,-0.146],[-0.22,-0.292],[0.293,-0.146],[0.22,0.146],[0.22,0.292],[-0.293,0.146]],"o":[[0.22,0.146],[0.293,0.512],[-0.147,0.073],[-0.22,-0.147],[-0.293,-0.511],[0.22,-0.073]],"v":[[0.001,-0.877],[0.586,-0.293],[0.586,0.95],[0.001,0.877],[-0.586,0.292],[-0.586,-0.95]],"c":true},"ix":2},"nm":"路径 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[1,0.902000038297,0.635000011968,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"填充 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[17.451,28.384],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"变换"}],"nm":"组 10","np":4,"cix":2,"bm":0,"ix":10,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[-0.439,-0.219],[0,-0.512],[0.439,0.292],[0,0.512]],"o":[[0.439,0.219],[0,0.511],[-0.439,-0.219],[0,-0.511]],"v":[[0,-0.95],[0.806,0.439],[0,0.877],[-0.806,-0.512]],"c":true},"ix":2},"nm":"路径 1","mn":"ADBE Vector Shape - G.037,-8.222],[7.21,4.201],[-0.036,8.295],[-7.21,-4.13]],"c":true},"ix":2},"nm":"路径 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.654999976065,0.783999992819,0.984000052658,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"填充 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[14.194,30.248],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"变换"}],"nm":"组 16","np":4,"cix":2,"bm":0,"ix":16,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[1.244,-0.804],[0,0],[0,2.265],[3.952,2.338],[0,0],[0,-4.604]],"o":[[0,0],[1.319,-0.73],[0,-4.531],[0,0],[3.952,2.265],[-0.073,2.192]],"v":[[14.347,1.023],[-11.42,16.003],[-9.296,11.4],[-16.468,-1.023],[9.295,-16.003],[16.468,-3.58]],"c":true},"ix":2},"nm":"路径 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.866999966491,0.922000002394,0.972999961703,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"填充 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[30.773,23.049],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"变换"}],"nm":"组 17","np":4,"cix":2,"bm":0,"ix":17,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[1.317,-0.731],[0,0],[-1.977,-1.17],[0,0]],"o":[[0,0],[1.318,-0.731],[0,0],[-1.977,-1.169]],"v":[[-15.444,7.6],[10.32,-7.381],[15.444,-6.869],[-10.32,8.111]],"c":true},"ix":2},"nm":"路径 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.838999968884,0.838999968884,0.838999968884,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"填充 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[24.551,13.915],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"变换"}],"nm":"组 18","np":4,"cix":2,"bm":0,"ix":18,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":375,"st":0,"bm":0},{"ddd":0,"ind":2,"ty":2,"nm":"摄像支架","refId":"image_0","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[320,270,0],"ix":2},"a":{"a":0,"k":[320,270,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6}},"ao":0,"ip":0,"op":250,"st":0,"bm":0}]},{"id":"comp_1","layers":[{"ddd":0,"ind":1,"ty":2,"nm":"装饰","refId":"image_1","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[320,270,0],"ix":2},"a":{"a":0,"k":[320,270,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6}},"ao":0,"ip":0,"op":250,"st":0,"bm":0},{"ddd":0,"ind":2,"ty":2,"nm":"装饰阴影","refId":"image_2","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[294.332,478.876,0],"ix":2},"a":{"a":0,"k":[32.118,18.126,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6}},"ao":0,"ip":0,"op":375,"st":0,"bm":0}]},{"id":"comp_2","layers":[{"ddd":0,"ind":1,"ty":2,"nm":"1号人","refId":"image_3","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[320,270,0],"ix":2},"a":{"a":0,"k":[320,270,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6}},"ao":0,"ip":0,"op":250,"st":0,"bm":0},{"ddd":0,"ind":2,"ty":2,"nm":"1号人阴影","refId":"image_4","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[217.999,492.976,0],"ix":2},"a":{"a":0,"k":[23.833,15.122,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6}},"ao":0,"ip":0,"op":375,"st":0,"bm":0}]},{"id":"comp_3","layers":[{"ddd":0,"ind":1,"ty":2,"nm":"盾牌","refId":"image_5","sr":1,"ks":{"o":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":59,"s":[0]},{"t":66,"s":[100]}],"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":1,"k":[{"i":{"x":0.833,"y":0.833},"o":{"x":0.167,"y":0.167},"t":59,"s":[267.55,332.55,0],"to":[3.542,-6.833,0],"ti":[0,29.333,0]},{"t":66,"s":[288.8,291.55,0]}],"ix":2},"a":{"a":0,"k":[320,270,0],"ix":1},"s":{"a":1,"k":[{"i":{"x":[0.833,0.833,0.833],"y":[0.833,0.833,0.833]},"o":{"x":[0.167,0.167,0.167],"y":[0.167,0.167,0.167]},"t":59,"s":[40,40,100]},{"t":66,"s":[100,100,100]}],"ix":6}},"ao":0,"ip":0,"op":250,"st":0,"bm":0},{"ddd":0,"ind":2,"ty":2,"nm":"盾牌阴影","refId":"image_6","sr":1,"ks":{"o":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":63,"s":[0]},{"t":66,"s":[70]}],"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[320,270,0],"ix":2},"a":{"a":0,"k":[320,270,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6}},"ao":0,"ip":0,"op":250,"st":0,"bm":0},{"ddd":0,"ind":3,"ty":2,"nm":"锁 光圈","refId":"image_7","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":1,"k":[{"i":{"x":0.5,"y":1},"o":{"x":0.5,"y":0},"t":53,"s":[65.2,350.706,0],"to":[1.75,-1,0],"ti":[-1.75,1,0]},{"t":57,"s":[75.7,344.706,0]}],"ix":2},"a":{"a":0,"k":[320,270,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6}},"ao":0,"ip":0,"op":250,"st":0,"bm":0},{"ddd":0,"ind":4,"ty":4,"nm":"“锁”轮廓","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":1,"k":[{"i":{"x":0.5,"y":1},"o":{"x":0.5,"y":0},"t":53,"s":[78.03,350.441,0],"to":[1.75,-1,0],"ti":[-1.75,1,0]},{"t":57,"s":[88.53,344.441,0]}],"ix":2},"a":{"a":0,"k":[72.58,46.591,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[-3.108,5.348],[-3.104,-1.804],[3.108,-5.347],[3.104,1.804]],"o":[[3.108,-5.349],[3.104,1.805],[-3.108,5.348],[-3.104,-1.803]],"v":[[-5.62,-3.266],[5.628,-9.684],[5.62,3.267],[-5.628,9.684]],"c":true},"ix":2},"nm":"路径 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.980000035903,0.677999997606,0.078000005086,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"填充 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[136.178,81.445],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"变换"}],"nm":"组 1","np":4,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[2.2,-1.3],[0,-5.099],[-1.4,-0.801],[0,0],[0,2.5],[-4.5,2.601],[-1.5,-0.8]],"o":[[-1.5,-0.801],[-4.4,2.5],[0,2.5],[0,0],[-1.4,-0.8],[0,-5.101],[2.2,-1.3],[0,0]],"v":[[1.55,-12.4],[-4.15,-11.799],[-12.15,1.999],[-9.85,7.1],[0.75,13.201],[-1.55,8.1],[6.45,-5.701],[12.15,-6.299]],"c":true},"ix":2},"nm":"路径 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[1,0.773000021542,0.238999998803,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"填充 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[129.6,77.95],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"变换"}],"nm":"组 2","np":4,"cix":2,"bm":0,"ix":2,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[-3.1,1.8],[0,-3.6],[3.1,-1.8],[0,3.6]],"o":[[3.1,-1.8],[0,3.6],[-3.1,1.8],[0,-3.5]],"v":[[0,-6.45],[5.6,-3.25],[0,6.45],[-5.6,3.25]],"c":true},"ix":2},"nm":"路径 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.980000035903,0.677999997606,0.078000005086,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"填充 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[123.45,73.6],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"变换"}],"nm":"组 3","np":4,"cix":2,"bm":0,"ix":3,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[1.6,-0.899],[0,-3.5],[-1,-0.6],[0,0],[0,1.801],[-3.1,1.7],[-1,-0.599]],"o":[[-1,-0.601],[-3.1,1.8],[0,1.8],[0,0],[-1,-0.601],[0,-3.5],[1.6,-0.901],[0,0]],"v":[[-7.9,-13.85],[-11.9,-13.451],[-17.5,-3.85],[-15.9,-0.249],[9.5,14.451],[7.9,10.85],[13.5,1.251],[17.5,0.85]],"c":true},"ix":2},"nm":"路径 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[1,0.898000021542,0.560999971278,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"填充 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[109.95,65.9],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"变换"}],"nm":"组 4","np":4,"cix":2,"bm":0,"ix":4,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[-4.2,2.5],[0,-4.9],[4.3,-2.5],[0,4.9]],"o":[[4.3,-2.5],[0,4.9],[-4.3,2.5],[0,-4.9]],"v":[[-0.05,-8.9],[7.75,-4.5],[0.05,8.9],[-7.75,4.5]],"c":true},"ix":2},"nm":"路径 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[1,0.984000052658,0.560999971278,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"填充 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[96.2,57.55],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"变换"}],"nm":"组 5","np":4,"cix":2,"bm":0,"ix":5,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[-3,4.917],[2.963,8.5],[3,-4.916],[-2.964,-8.5]],"c":true},"ix":2},"nm":"路径 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"st","c":{"a":0,"k":[1,0.984000052658,0.902000038297,1],"ix":3},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":1,"ix":5},"lc":1,"lj":1,"ml":4,"bm":0,"nm":"描边 1","mn":"ADBE Vector Graphic - Stroke","hd":false},{"ty":"tr","p":{"a":0,"k":[65.9,55.166],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"变换"}],"nm":"组 6","np":2,"cix":2,"bm":0,"ix":6,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[-3,4.917],[2.963,8.5],[3,-4.916],[-2.964,-8.5]],"c":true},"ix":2},"nm":"路径 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[0.57599995931,0.435000011968,0.885999971278,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"填充 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[65.9,55.166],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"变换"}],"nm":"组 7","np":4,"cix":2,"bm":0,"ix":7,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[0.881,-0.501],[0.876,1.516],[-0.881,0.502],[-0.876,-1.516]],"c":true},"ix":2},"nm":"路径 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[1,0.984000052658,0.902000038297,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"填充 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[57.408,54.033],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"变换"}],"nm":"组 8","np":4,"cix":2,"bm":0,"ix":8,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[0.881,-0.502],[0.875,1.517],[-0.881,0.502],[-0.875,-1.517]],"c":true},"ix":2},"nm":"路径 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[1,0.984000052658,0.902000038297,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"填充 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[53.509,55.669],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"变换"}],"nm":"组 9","np":4,"cix":2,"bm":0,"ix":9,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[0.881,-0.502],[0.875,1.517],[-0.881,0.503],[-0.875,-1.517]],"c":true},"ix":2},"nm":"路径 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[1,0.984000052658,0.902000038297,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"填充 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[53.519,51.788],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"变换"}],"nm":"组 10","np":4,"cix":2,"bm":0,"ix":10,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[0.881,-0.502],[0.875,1.517],[-0.881,0.502],[-0.875,-1.517]],"c":true},"ix":2},"nm":"路径 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[1,0.984000052658,0.902000038297,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"填充 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[57.419,49.976],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"变换"}],"nm":"组 11","np":4,"cix":2,"bm":0,"ix":11,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[0.881,-0.503],[0.875,1.517],[-0.881,0.503],[-0.875,-1.517]],"c":true},"ix":2},"nm":"路径 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[1,0.984000052658,0.902000038297,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"填充 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[53.531,47.731],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"变换"}],"nm":"组 12","np":4,"cix":2,"bm":0,"ix":12,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[0.881,-0.502],[0.875,1.517],[-0.881,0.503],[-0.875,-1.517]],"c":true},"ix":2},"nm":"路径 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[1,0.984000052658,0.902000038297,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"填充 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[57.431,45.911],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"变换"}],"nm":"组 13","np":4,"cix":2,"bm":0,"ix":13,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[-12.491,-10],[-12.506,-4.432],[12.489,10],[12.506,4.433]],"c":true},"ix":2},"nm":"路径 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"fl","c":{"a":0,"k":[1,0.984000052658,0.902000038297,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"填充 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[59.406,35.666],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k if (toSegment.allPrevSegments.length >= 2) {
            CodePathSegment.markPrevSegmentAsLooped(toSegment, fromSegment);
        }

        // let the code path analyzer know that there's been a loop created
        state.notifyLooped(fromSegment, toSegment);
    }
}

/**
 * Finalizes segments of `test` chunk of a ForStatement.
 *
 * - Adds `false` paths to paths which are leaving from the loop.
 * - Sets `true` paths to paths which go to the body.
 * @param {LoopContext} context A loop context to modify.
 * @param {ChoiceContext} choiceContext A choice context of this loop.
 * @param {CodePathSegment[]} head The current head paths.
 * @returns {void}
 */
function finalizeTestSegmentsOfFor(context, choiceContext, head) {

    /*
     * If this choice context doesn't already contain paths from a
     * child context, then add the current head to each potential path.
     */
    if (!choiceContext.processed) {
        choiceContext.trueForkContext.add(head);
        choiceContext.falseForkContext.add(head);
        choiceContext.nullishForkContext.add(head);
    }

    /*
     * If the test condition isn't a hardcoded truthy value, then `break`
     * must follow the same path as if the test condition is false. To represent
     * that, we append the path for when the loop test is false (represented by
     * `falseForkContext`) to the `brokenForkContext`.
     */
    if (context.test !== true) {
        context.brokenForkContext.addAll(choiceContext.falseForkContext);
    }

    context.endOfTestSegments = choiceContext.trueForkContext.makeNext(0, -1);
}

//------------------------------------------------------------------------------
// Public Interface
//------------------------------------------------------------------------------

/**
 * A class which manages state to analyze code paths.
 */
class CodePathState {

    /**
     * Creates a new instance.
     * @param {IdGenerator} idGenerator An id generator to generate id for code
     *   path segments.
     * @param {Function} onLooped A callback function to notify looping.
     */
    constructor(idGenerator, onLooped) {

        /**
         * The ID generator to use when creating new segments.
         * @type {IdGenerator}
         */
        this.idGenerator = idGenerator;

        /**
         * A callback function to call when there is a loop.
         * @type {Function}
         */
        this.notifyLooped = onLooped;

        /**
         * The root fork context for this state.
         * @type {ForkContext}
         */
        this.forkContext = ForkContext.newRoot(idGenerator);

        /**
         * Context for logical expressions, conditional expressions, `if` statements,
         * and loops.
         * @type {ChoiceContext}
         */
        this.choiceContext = null;

        /**
         * Context for `switch` statements.
         * @type {SwitchContext}
         */
        this.switchContext = null;

        /**
         * Context for `try` statements.
         * @type {TryContext}
         */
        this.tryContext = null;

        /**
         * Context for loop statements.
         * @type {LoopContext}
         */
        this.loopContext = null;

        /**
         * Context for `break` statements.
         * @type {BreakContext}
         */
        this.breakContext = null;

        /**
         * Context for `ChainExpression` nodes.
         * @type {ChainContext}
         */
        this.chainContext = null;

        /**
         * An array that tracks the current segments in the state. The array
         * starts empty and segments are added with each `onCodePathSegmentStart`
         * event and removed with each `onCodePathSegmentEnd` event. Effectively,
         * this is tracking the code path segment traversal as the state is
         * modified.
         * @type {Array<CodePathSegment>}
         */
        this.currentSegments = [];

        /**
         * Tracks the starting segment for this path. This value never changes.
         * @type {CodePathSegment}
         */
        this.initialSegment = this.forkContext.head[0];

        /**
         * The final segments of the code path which are either `return` or `throw`.
         * This is a union of the segments in `returnedForkContext` and `thrownForkContext`.
         * @type {Array<CodePathSegment>}
         */
        this.finalSegments = [];

        /**
         * The final segments of the code path which are `return`. These
         * segments are also contained in `finalSegments`.
         * @type {Array<CodePathSegment>}
         */
        this.returnedForkContext = [];

        /**
         * The final segments of the code path which are `throw`. These
         * segments are also contained in `finalSegments`.
         * @type {Array<CodePathSegment>}
         */
        this.thrownForkContext = [];

        /*
         * We add an `add` method so that these look more like fork contexts and
         * can be used interchangeably when a fork context is needed to add more
         * segments to a path.
         *
         * Ultimately, we want anything added to `returned` or `thrown` to also
         * be added to `final`. We only add reachable and used segments to these
         * arrays.
         */
        const final = this.finalSegments;
        const returned = this.returnedForkContext;
        const thrown = this.thrownForkContext;

        returned.add = addToReturnedOrThrown.bind(null, returned, thrown, final);
        thrown.add = addToReturnedOrThrown.bind(null, thrown, returned, final);
    }

    /**
     * A passthrough property exposing the current pointer as part of the API.
     * @type {CodePathSegment[]}
     */
    get headSegments() {
        return this.forkContext.head;
    }

    /**
     * The parent forking context.
     * This is used for the root of new forks.
     * @type {ForkContext}
     */
    get parentForkContext() {
        const current = this.forkContext;

        return current && current.upper;
    }

    /**
     * Creates and stacks new forking context.
     * @param {boolean} forkLeavingPath A flag which shows being in a
     *   "finally" block.
     * @returns {ForkContext} The created context.
     */
    pushForkContext(forkLeavingPath) {
        this.forkContext = ForkContext.newEmpty(
            this.forkContext,
            forkLeavingPath
        );

        return this.forkContext;
    }

    /**
     * Pops and merges the last forking context.
     * @returns {ForkContext} The last context.
     */
    popForkContext() {
        const lastContext = this.forkContext;

        this.forkContext = lastContext.upper;
        this.forkContext.replaceHead(lastContext.makeNext(0, -1));

        return lastContext;
    }

    /**
     * Creates a new path.
     * @returns {void}
     */
    forkPath() {
        this.forkContext.add(this.parentForkContext.makeNext(-1, -1));
    }

    /**
     * Creates a bypass path.
     * This is used for such as IfStatement which does not have "else" chunk.
     * @returns {void}
     */
    forkBypassPath() {
        this.forkContext.add(this.parentForkContext.head);
    }

    //--------------------------------------------------------------------------
    // ConditionalExpression, LogicalExpression, IfStatement
    //--------------------------------------------------------------------------

    /**
     * Creates a context for ConditionalExpression, LogicalExpression, AssignmentExpression (logical assignments only),
     * IfStatement, WhileStatement, DoWhileStatement, or ForStatement.
     *
     * LogicalExpressions have cases that it goes different paths between the
     * `true` case and the `false` case.
     *
     * For Example:
     *
     *     if (a || b) {
     *         foo();
     *     } else {
     *         bar();
     *     }
     *
     * In this case, `b` is evaluated always in the code path of the `else`
     * block, but it's not so in the code path of the `if` block.
     * So there are 3 paths.
     *
     *     a -> foo();
     *     a -> b -> foo();
     *     a -> b -> bar();
     * @param {string} kind A kind string.
     *   If the new context is LogicalExpression's or AssignmentExpression's, this is `"&&"` or `"||"` or `"??"`.
     *   If it's IfStatement's or ConditionalExpression's, this is `"test"`.
     *   Otherwise, this is `"loop"`.
     * @param {boolean} isForkingAsResult Indicates if the result of the choice
     *      creates a fork.
     * @returns {void}
     */
    pushChoiceContext(kind, isForkingAsResult) {
        this.choiceContext = new ChoiceContext(this.choiceContext, kind, isForkingAsResult, this.forkContext);
    }

    /**
     * Pops the last choice context and finalizes it.
     * This is called upon leaving a node that represents a choice.
     * @throws {Error} (Unreachable.)
     * @returns {ChoiceContext} The popped context.
     */
    popChoiceContext() {
        const poppedChoiceContext = this.choiceContext;
        const forkContext = this.forkContext;
        const head = forkContext.head;

        this.choiceContext = poppedChoiceContext.upper;

        switch (poppedChoiceContext.kind) {
            case "&&":
            case "||":
            case "??":

                /*
                 * The `head` are the path of the right-hand operand.
                 * If we haven't previously added segments from child contexts,
                 * then we add these segments to all possible forks.
                 */
                if (!poppedChoiceContext.processed) {
                    poppedChoiceContext.trueForkContext.add(head);
                    poppedChoiceContext.falseForkContext.add(head);
                    poppedChoiceContext.nullishForkContext.add(head);
                }

                /*
                 * If this context is the left (test) expression for another choice
                 * context, such as `a || b` in the expression `a || b || c`,
                 * then we take the segments for this context and move them up
                 * to the parent context.
                 */
                if (poppedChoiceContext.isForkingAsResult) {
                    const parentContext = this.choiceContext;

                    parentContext.trueForkContext.addAll(poppedChoiceContext.trueForkContext);
                    parentContext.falseForkContext.addAll(poppedChoiceContext.falseForkContext);
                    parentContext.nullishForkContext.addAll(poppedChoiceContext.nullishForkContext);
                    parentContext.processed = true;

                    // Exit early so we don't collapse all paths into one.
                    return poppedChoiceContext;
                }

                break;

            case "test":
                if (!poppedChoiceContext.processed) {

                    /*
                     * The head segments are the path of the `if` block here.
                     * Updates the `true` path with the end of the `if` block.
                     */
                    poppedChoiceContext.trueForkContext.clear();
                    poppedChoiceContext.trueForkContext.add(head);
                } else {

                    /*
                     * The head segments are the path of the `else` block here.
                     * Updates the `false` path with the end of the `else`
                     * block.
                     */
                    poppedChoiceContext.falseForkContext.clear();
                    poppedChoiceContext.falseForkContext.add(head);
                }

                break;

            case "loop":

                /*
                 * Loops are addressed in `popLoopContext()` so just return
                 * the context without modification.
                 */
                return poppedChoiceContext;

            /* c8 ignore next */
            default:
                throw new Error("unreachable");
        }

        /*
         * Merge the true path with the false path to create a single path.
         */
        const combinedForkContext = poppedChoiceContext.trueForkContext;

        combinedForkContext.addAll(poppedChoiceContext.falseForkContext);
        forkContext.replaceHead(combinedForkContext.makeNext(0, -1));

        return poppedChoiceContext;
    }

    /**
     * Creates a code path segment to represent right-hand operand of a logical
     * expression.
     * This is called in the preprocessing phase when entering a node.
     * @throws {Error} (Unreachable.)
     * @returns {void}
     */
    makeLogicalRight() {
        const currentChoiceContext = this.choiceContext;
        const forkContext = this.forkContext;

        if (currentChoiceContext.processed) {

            /*
             * This context was already assigned segments from a child
             * choice context. In this case, we are concerned only about
             * the path that does not short-circuit and so ends up on the
             * right-hand operand of the logical expression.
             */
            let prevForkContext;

            switch (currentChoiceContext.kind) {
                case "&&": // if true then go to the right-hand side.
                    prevForkContext = currentChoiceContext.trueForkContext;
                    break;
                case "||": // if false then go to the right-hand side.
                    prevForkContext = currentChoiceContext.falseForkContext;
                    break;
                case "??": // Both true/false can short-circuit, so needs the third path to go to the right-hand side. That's nullishForkContext.
                    prevForkContext = currentChoiceContext.nullishForkContext;
                    break;
                default:
                    throw new Error("unreachable");
            }

            /*
             * Create the segment for the right-hand operand of the logical expression
             * and adjust the fork context pointer to point there. The right-hand segment
             * is added at the end of all segments in `prevForkContext`.
             */
            forkContext.replaceHead(prevForkContext.makeNext(0, -1));

            /*
             * We no longer need this list of segments.
             *
             * Reset `processed` because we've removed the segments from the child
             * choice context. This allows `popChoiceContext()` to continue adding
             * segments later.
             */
            prevForkContext.clear();
            currentChoiceContext.processed = false;

        } else {

            /*
             * This choice context was not assigned segments from a child
             * choice context, which means that it's a terminal logical
             * expression.
             *
             * `head` is the segments for the left-hand operand of the
             * logical expression.
             *
             * Each of the fork contexts below are empty at this point. We choose
             * the path(s) that will short-circuit and add the segment for the
             * left-hand operand to it. Ultimately, this will be the only segment
             * in that path due to the short-circuting, so we are just seeding
             * these paths to start.
             */
            switch (currentChoiceContext.kind) {
                case "&&":

                    /*
                     * In most contexts, when a && expression evaluates to false,
                     * it short circuits, so we need to account for that by setting
                     * the `falseForkContext` to the left operand.
                     *
                     * When a && expression is the left-hand operand for a ??
                     * expression, such as `(a && b) ?? c`, a nullish value will
                     * also short-circuit in a different way than a false value,
                     * so we also set the `nullishForkContext` to the left operand.
                     * This path is only used with a ?? expression and is thrown
                     * away for any other type of logical expression, so it's safe
                     * to always add.
                     */
                    currentChoiceContext.falseForkContext.add(forkContext.head);
                    currentChoiceContext.nullishForkContext.add(forkContext.head);
                    break;
                case "||": // the true path can short-circuit.
                    currentChoiceContext.trueForkContext.add(forkContext.head);
                    break;
                case "??": // both can short-circuit.
                    currentChoiceContext.trueForkContext.add(forkContext.head);
                    currentChoiceContext.falseForkContext.add(forkContext.head);
                    break;
                default:
                    throw new Error("unreachable");
            }

            /*
             * Create the segment for the right-hand operand of the logical expression
             * and adjust the fork context pointer to point there.
             */
            forkContext.replaceHead(forkContext.makeNext(-1, -1));
        }
    }

    /**
     * Makes a code path segment of the `if` block.
     * @returns {void}
     */
    makeIfConsequent() {
        const context = this.choiceContext;
        const forkContext = this.forkContext;

        /*
         * If any result were not transferred from child contexts,
         * this sets the head segments to both cases.
         * The head segments are the path of the test expression.
         */
        if (!context.processed) {
            context.trueForkContext.add(forkContext.head);
            context.falseForkContext.add(forkContext.head);
            context.nullishForkContext.add(forkContext.head);
        }

        context.processed = false;

        // Creates new path from the `true` case.
        forkContext.replaceHead(
            context.trueForkContext.makeNext(0, -1)
        );
    }

    /**
     * Makes a code path segment of the `else` block.
     * @returns {void}
     */
    makeIfAlternate() {
        const context = this.choiceContext;
        const forkContext = this.forkContext;

        /*
         * The head segments are the path of the `if` block.
         * Updates the `true` path with the end of the `if` block.
         */
        context.trueForkContext.clear();
        context.trueForkContext.add(forkContext.head);
        context.processed = true;

        // Creates new path from the `false` case.
        forkContext.replaceHead(
            context.falseForkContext.makeNext(0, -1)
        );
    }

    //--------------------------------------------------------------------------
    // ChainExpression
    //--------------------------------------------------------------------------

    /**
     * Pushes a new `ChainExpression` context to the stack. This method is
     * called when entering a `ChainExpression` node. A chain context is used to
     * count forking in the optional chain then merge them on the exiting from the
     * `ChainExpression` node.
     * @returns {void}
     */
    pushChainContext() {
        this.chainContext = new ChainContext(this.chainContext);
    }

    /**
     * Pop a `ChainExpression` context from the stack. This method is called on
     * exiting from each `ChainExpression` node. This merges all forks of the
     * last optional chaining.
     * @returns {void}
     */
    popChainContext() {
        const context = this.chainContext;

        this.chainContext = context.upper;

        // pop all choice contexts of this.
        for (let i = context.choiceContextCount; i > 0; --i) {
            this.popChoiceContext();
        }
    }

    /**
     * Create a choice context for optional access.
     * This method is called on entering to each `(Call|Member)Expression[optional=true]` node.
     * This creates a choice context as similar to `LogicalExpression[operator="??"]` node.
     * @returns {void}
     */
    makeOptionalNode() {
        if (this.chainContext) {
            this.chainContext.choiceContextCount += 1;
            this.pushChoiceContext("??", false);
        }
    }

    /**
     * Create a fork.
     * This method is called on entering to the `arguments|property` property of each `(Call|Member)Expression` node.
     * @returns {void}
     */
    makeOptionalRight() {
        if (this.chainContext) {
            this.makeLogicalRight();
        }
    }

    //--------------------------------------------------------------------------
    // SwitchStatement
    //--------------------------------------------------------------------------

    /**
     * Creates a context object of SwitchStatement and stacks it.
     * @param {boolean} hasCase `true` if the switch statement has one or more
     *   case parts.
     * @param {string|null} label The label text.
     * @returns {void}
     */
    pushSwitchContext(hasCase, label) {
        this.switchContext = new SwitchContext(this.switchContext, hasCase);
        this.pushBreakContext(true, label);
    }

    /**
     * Pops the last context of SwitchStatement and finalizes it.
     *
     * - Disposes all forking stack for `case` and `default`.
     * - Creates the next code path segment from `context.brokenForkContext`.
     * - If the last `SwitchCase` node is not a `default` part, creates a path
     *   to the `default` body.
     * @returns {void}
     */
    popSwitchContext() {
        const context = this.switchContext;

        this.switchContext = context.upper;

        const forkContext = this.forkContext;
        const brokenForkContext = this.popBreakContext().brokenForkContext;

        if (context.forkCount === 0) {

            /*
             * When there is only one `default` chunk and there is one or more
             * `break` statements, even if forks are nothing, it needs to merge
             * those.
             */
            if (!brokenForkContext.empty) {
                brokenForkContext.add(forkContext.makeNext(-1, -1));
                forkContext.replaceHead(brokenForkContext.makeNext(0, -1));
            }

            return;
        }

        const lastSegments = forkContext.head;

        this.forkBypassPath();
        const lastCaseSegments = forkContext.head;

        /*
         * `brokenForkContext` is used to make the next segment.
         * It must add the last segment into `brokenForkContext`.
         */
        brokenForkContext.add(lastSegments);

        /*
         * Any value that doesn't match a `case` test should flow to the default
         * case. That happens normally when the default case is last in the `switch`,
         * but if it's not, we need to rewire some of the paths to be correct.
         */
        if (!context.lastIsDefault) {
            if (context.defaultBodySegments) {

                /*
                 * There is a non-empty default case, so remove the path from the `default`
                 * label to its body for an accurate representation.
                 */
                disconnectSegments(context.defaultSegments, context.defaultBodySegments);

                /*
                 * Connect the path from the last non-default case to the body of the
                 * default case.
                 */
                makeLooped(this, lastCaseSegments, context.defaultBodySegments);

            } else {

                /*
                 * There is no default case, so we treat this as if the last case
                 * had a `break` in it.
                 */
                brokenForkContext.add(lastCaseSegments);
            }
        }

        // Traverse up to the original fork context for the `switch` statement
        for (let i = 0; i < context.forkCount; ++i) {
            this.forkContext = this.forkContext.upper;
        }

        /*
         * Creates a path from all `brokenForkContext` paths.
         * This is a path after `switch` statement.
         */
        this.forkContext.replaceHead(brokenForkContext.makeNext(0, -1));
    }

    /**
     * Makes a code path segment for a `SwitchCase` node.
     * @param {boolean} isCaseBodyEmpty `true` if the body is empty.
     * @param {boolean} isDefaultCase `true` if the body is the default case.
     * @returns {void}
     */
    makeSwitchCaseBody(isCaseBodyEmpty, isDefaultCase) {
        const context = this.switchContext;

        if (!context.hasCase) {
            return;
        }

        /*
         * Merge forks.
         * The parent fork context has two segments.
         * Those are from the current `case` and the body of the previous case.
         */
        const parentForkContext = this.forkContext;
        const forkContext = this.pushForkContext();

        forkContext.add(parentForkContext.makeNext(0, -1));

        /*
         * Add information about the default case.
         *
         * The purpose of this is to identify the starting segments for the
         * default case to make sure there is a path there.
         */
        if (isDefaultCase) {

            /*
             * This is the default case in the `switch`.
             *
             * We first save the current pointer as `defaultSegments` to point
             * to the `default` keyword.
             */
            context.defaultSegments = parentForkContext.head;

            /*
             * If the body of the case is empty then we just set
             * `foundEmptyDefault` to true; otherwise, we save a reference
             * to the current pointer as `defaultBodySegments`.
             */
            if (isCaseBodyEmpty) {
                context.foundEmptyDefault = true;
            } else {
                context.defaultBodySegments = forkContext.head;
            }

        } else {

            /*
             * This is not the default case in the `switch`.
             *
             * If it's not empty and there is already an empty default case found,
             * that means the default case actually comes before this case,
             * and that it will fall through to this case. So, we can now
             * ignore the previous default case (reset `foundEmptyDefault` to false)
             * and set `defaultBodySegments` to the current segments because this is
             * effectively the new default case.
             */
            if (!isCaseBodyEmpty && context.foundEmptyDefault) {
                context.foundEmptyDefault = false;
                context.defaultBodySegments = forkContext.head;
            }
        }

        // keep track if the default case ends up last
        context.lastIsDefault = isDefaultCase;
        context.forkCount += 1;
    }

    //--------------------------------------------------------------------------
    // TryStatement
    //--------------------------------------------------------------------------

    /**
     * Creates a context object of TryStatement and stacks it.
     * @param {boolean} hasFinalizer `true` if the try statement has a
     *   `finally` block.
     * @returns {void}
     */
    pushTryContext(hasFinalizer) {
        this.tryContext = new TryContext(this.tryContext, hasFinalizer, this.forkContext);
    }

    /**
     * Pops the last context of TryStatement and finalizes it.
     * @returns {void}
     */
    popTryContext() {
        const context = this.tryContext;

        this.tryContext = context.upper;

        /*
         * If we're inside the `catch` block, that means there is no `finally`,
         * so we can process the `try` and `catch` blocks the simple way and
         * merge their two paths.
         */
        if (context.position === "catch") {
            this.popForkContext();
            return;
        }

        /*
         * The following process is executed only when there is a `finally`
         * block.
         */

        const originalReturnedForkContext = context.returnedForkContext;
        const originalThrownForkContext = context.thrownForkContext;

        // no `return` or `throw` in `try` or `catch` so there's nothing left to do
        if (originalReturnedForkContext.empty && originalThrownForkContext.empty) {
            return;
        }

        /*
         * The following process is executed only when there is a `finally`
         * block and there was a `return` or `throw` in the `try` or `catch`
         * blocks.
         */

        // Separate head to normal paths and leaving paths.
        const headSegments = this.forkContext.head;

        this.forkContext = this.forkContext.upper;
        const normalSegments = headSegments.slice(0, headSegments.length / 2 | 0);
        const leavingSegments = headSegments.slice(headSegments.length / 2 | 0);

        // Forwards the leaving path to upper contexts.
        if (!originalReturnedForkContext.empty) {
            getReturnContext(this).returnedForkContext.add(leavingSegments);
        }
        if (!originalThrownForkContext.empty) {
            getThrowContext(this).thrownForkContext.add(leavingSegments);
        }

        // Sets the normal path as the next.
        this.forkContext.replaceHead(normalSegments);

        /*
         * If both paths of the `try` block and the `catch` block are
         * unreachable, the next path becomes unreachable as well.
         */
        if (!context.lastOfTryIsReachable && !context.lastOfCatchIsReachable) {
            this.forkContext.makeUnreachable();
        }
    }

    /**
     * Makes a code path segment for a `catch` block.
     * @returns {void}
     */
    makeCatchBlock() {
        const context = this.tryContext;
        const forkContext = this.forkContext;
        const originalThrownForkContext = context.thrownForkContext;

        /*
         * We are now in a catch block so we need to update the context
         * with that information. This includes creating a new fork
         * context in case we encounter any `throw` statements here.
         */
        context.position = "catch";
        context.thrownForkContext = ForkContext.newEmpty(forkContext);
        context.lastOfTryIsReachable = forkContext.reachable;

        // Merge the thrown paths from the `try` and `catch` blocks
        originalThrownForkContext.add(forkContext.head);
        const thrownSegments = originalThrownForkContext.makeNext(0, -1);

        // Fork to a bypass and the merged thrown path.
        this.pushForkContext();
        this.forkBypassPath();
        this.forkContext.add(thrownSegments);
    }

    /**
     * Makes a code path segment for a `finally` block.
     *
     * In the `finally` block, parallel paths are created. The parallel paths
     * are used as leaving-paths. The leaving-paths are paths from `return`
     * statements and `throw` statements in a `try` block or a `catch` block.
     * @returns {void}
     */
    makeFinallyBlock() {
        const context = this.tryContext;
        let forkContext = this.forkContext;
        const originalReturnedForkContext = context.returnedForkContext;
        const originalThrownForContext = context.thrownForkContext;
        const headOfLeavingSegments = forkContext.head;

        // Update state.
        if (context.position === "catch") {

            // Merges two paths from the `try` block and `catch` block.
            this.popForkContext();
            forkContext = this.forkContext;

            context.lastOfCatchIsReachable = forkContext.reachable;
        } else {
            context.lastOfTryIsReachable = forkContext.reachable;
        }


        context.position = "finally";

        /*
         * If there was no `return` or `throw` in either the `try` or `catch`
         * blocks, then there's no further code paths to create for `finally`.
         */
        if (originalReturnedForkContext.empty && originalThrownForContext.empty) {

            // This path does not leave.
            return;
        }

        /*
         * Create a parallel segment from merging returned and thrown.
         * This segment will leave at the end of this `finally` block.
         */
        const segments = forkContext.makeNext(-1, -1);

        for (let i = 0; i < forkContext.count; ++i) {
            const prevSegsOfLeavingSegment = [headOfLeavingSegments[i]];

            for (let j = 0; j < originalReturnedForkContext.segmentsList.length; ++j) {
                prevSegsOfLeavingSegment.push(originalReturnedForkContext.segmentsList[j][i]);
            }
            for (let j = 0; j < originalThrownForContext.segmentsList.length; ++j) {
                prevSegsOfLeavingSegment.push(originalThrownForContext.segmentsList[j][i]);
            }

            segments.push(
                CodePathSegment.newNext(
                    this.idGenerator.next(),
                    prevSegsOfLeavingSegment
                )
            );
        }

        this.pushForkContext(true);
        this.forkContext.add(segments);
    }

    /**
     * Makes a code path segment from the first throwable node to the `catch`
     * block or the `finally` block.
     * @returns {void}
     */
    makeFirstThrowablePathInTryBlock() {
        const forkContext = this.forkContext;

        if (!forkContext.reachable) {
            return;
        }

        const context = getThrowContext(this);

        if (context === this ||
            context.position !== "try" ||
            !context.thrownForkContext.empty
        ) {
            return;
        }

        context.thrownForkContext.add(forkContext.head);
        forkContext.replaceHead(forkContext.makeNext(-1, -1));
    }

    //--------------------------------------------------------------------------
    // Loop Statements
    //--------------------------------------------------------------------------

    /**
     * Creates a context object of a loop statement and stacks it.
     * @param {string} type The type of the node which was triggered. One of
     *   `WhileStatement`, `DoWhileStatement`, `ForStatement`, `ForInStatement`,
     *   and `ForStatement`.
     * @param {string|null} label A label of the node which was triggered.
     * @throws {Error} (Unreachable - unknown type.)
     * @returns {void}
     */
    pushLoopContext(type, label) {
        const forkContext = this.forkContext;

        // All loops need a path to account for `break` statements
        const breakContext = this.pushBreakContext(true, label);

        switch (type) {
            case "WhileStatement":
                this.pushChoiceContext("loop", false);
                this.loopContext = new WhileLoopContext(this.loopContext, label, breakContext);
                break;

            case "DoWhileStatement":
                this.pushChoiceContext("loop", false);
                this.loopContext = new DoWhileLoopContext(this.loopContext, label, breakContext, forkContext);
                break;

            case "ForStatement":
                this.pushChoiceContext("loop", false);
                this.loopContext = new ForLoopContext(this.loopContext, label, breakContext);
                break;

            case "ForInStatement":
                this.loopContext = new ForInLoopContext(this.loopContext, label, breakContext);
                break;

            case "ForOfStatement":
                this.loopContext = new ForOfLoopContext(this.loopContext, label, breakContext);
                break;

            /* c8 ignore next */
            default:
                throw new Error(`unknown type: "${type}"`);
        }
    }

    /**
     * Pops the last context of a loop statement and finalizes it.
     * @throws {Error} (Unreachable - unknown type.)
     * @returns {void}
     */
    popLoopContext() {
        const context = this.loopContext;

        this.loopContext = context.upper;

        const forkContext = this.forkContext;
        const brokenForkContext = this.popBreakContext().brokenForkContext;

        // Creates a looped path.
        switch (context.type) {
            case "WhileStatement":
            case "ForStatement":
                this.popChoiceContext();

                /*
                 * Creates the path from the end of the loop body up to the
                 * location where `continue` would jump to.
                 */
                makeLooped(
                    this,
                    forkContext.head,
                    context.continueDestSegments
                );
                break;

            case "DoWhileStatement": {
                const choiceContext = this.popChoiceContext();

                if (!choiceContext.processed) {
                    choiceContext.trueForkContext.add(forkContext.head);
                    choiceContext.falseForkContext.add(forkContext.head);
                }

                /*
                 * If this isn't a hardcoded `true` condition, then `break`
                 * should continue down the path as if the condition evaluated
                 * to false.
                 */
                if (context.test !== true) {
                    brokenForkContext.addAll(choiceContext.falseForkContext);
                }

                /*
                 * When the condition is true, the loop continues back to the top,
                 * so create a path from each possible true condition back to the
                 * top of the loop.
                 */
                const segmentsList = choiceContext.trueForkContext.segmentsList;

                for (let i = 0; i < segmentsList.length; ++i) {
                    makeLooped(
                        this,
                        segmentsList[i],
                        context.entrySegments
                    );
                }
                break;
            }

            case "ForInStatement":
            case "ForOfStatement":
                brokenForkContext.add(forkContext.head);

                /*
                 * Creates the path from the end of the loop body up to the
                 * left expression (left of `in` or `of`) of the loop.
                 */
                makeLooped(
                    this,
                    forkContext.head,
                    context.leftSegments
                );
                break;

            /* c8 ignore next */
            default:
                throw new Error("unreachable");
        }

        /*
         * If there wasn't a `break` statement in the loop, then we're at
         * the end of the loop's path, so we make an unreachable segment
         * to mark that.
         *
         * If there was a `break` statement, then we continue on into the
         * `brokenForkContext`.
         */
        if (brokenForkContext.empty) {
            forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));
        } else {
            forkContext.replaceHead(brokenForkContext.makeNext(0, -1));
        }
    }

    /**
     * Makes a code path segment for the test part of a WhileStatement.
     * @param {boolean|undefined} test The test value (only when constant).
     * @returns {void}
     */
    makeWhileTest(test) {
        const context = this.loopContext;
        const forkContext = this.forkContext;
        const testSegments = forkContext.makeNext(0, -1);

        // Update state.
        context.test = test;
        context.continueDestSegments = testSegments;
        forkContext.replaceHead(testSegments);
    }

    /**
     * Makes a code path segment for the body part of a WhileStatement.
     * @returns {void}
     */
    makeWhileBody() {
        const context = this.loopContext;
        const choiceContext = this.choiceContext;
        const forkContext = this.forkContext;

        if (!choiceContext.processed) {
            choiceContext.trueForkContext.add(forkContext.head);
            choiceContext.falseForkContext.add(forkContext.head);
        }

        /*
         * If this isn't a hardcoded `true` condition, then `break`
         * should continue down the path as if the condition evaluated
         * to false.
         */
        if (context.test !== true) {
            context.brokenForkContext.addAll(choiceContext.falseForkContext);
        }
        forkContext.replaceHead(choiceContext.trueForkContext.makeNext(0, -1));
    }

    /**
     * Makes a code path segment for the body part of a DoWhileStatement.
     * @returns {void}
     */
    makeDoWhileBody() {
        const context = this.loopContext;
        const forkContext = this.forkContext;
        const bodySegments = forkContext.makeNext(-1, -1);

        // Update state.
        context.entrySegments = bodySegments;
        forkContext.replaceHead(bodySegments);
    }

    /**
     * Makes a code path segment for the test part of a DoWhileStatement.
     * @param {boolean|undefined} test The test value (only when constant).
     * @returns {void}
     */
    makeDoWhileTest(test) {
        const context = this.loopContext;
        const forkContext = this.forkContext;

        context.test = test;

        /*
         * If there is a `continue` statement in the loop then `continueForkContext`
         * won't be empty. We wire up the path from `continue` to the loop
         * test condition and then continue the traversal in the root fork context.
         */
        if (!context.continueForkContext.empty) {
            context.continueForkContext.add(forkContext.head);
            const testSegments = context.continueForkContext.makeNext(0, -1);

            forkContext.replaceHead(testSegments);
        }
    }

    /**
     * Makes a code path segment for the test part of a ForStatement.
     * @param {boolean|undefined} test The test value (only when constant).
     * @returns {void}
     */
    makeForTest(test) {
        const context = this.loopContext;
        const forkContext = this.forkContext;
        const endOfInitSegments = forkContext.head;
        const testSegments = forkContext.makeNext(-1, -1);

        /*
         * Update the state.
         *
         * The `continueDestSegments` are set to `testSegments` because we
         * don't yet know if there is an update expression in this loop. So,
         * from what we already know at this point, a `continue` statement
         * will jump back to the test expression.
         */
        context.test = test;
        context.endOfInitSegments = endOfInitSegments;
        context.continueDestSegments = context.testSegments = testSegments;
        forkContext.replaceHead(testSegments);
    }

    /**
     * Makes a code path segment for the update part of a ForStatement.
     * @returns {void}
     */
    makeForUpdate() {
        const context = this.loopContext;
        const choiceContext = this.choiceContext;
        const forkContext = this.forkContext;

        // Make the next paths of the test.
        if (context.testSegments) {
            finalizeTestSegmentsOfFor(
                context,
                choiceContext,
                forkContext.head
            );
        } else {
            context.endOfInitSegments = forkContext.head;
        }

        /*
         * Update the state.
         *
         * The `continueDestSegments` are now set to `updateSegments` because we
         * know there is an update expression in this loop. So, a `continue` statement
         * in the loop will jump to the update expression first, and then to any
         * test expression the loop might have.
         */
        const updateSegments = forkContext.makeDisconnected(-1, -1);

        context.continueDestSegments = context.updateSegments = updateSegments;
        forkContext.replaceHead(updateSegments);
    }

    /**
     * Makes a code path segment for the body part of a ForStatement.
     * @returns {void}
     */
    makeForBody() {
        const context = this.loopContext;
        const choiceContext = this.choiceContext;
        const forkContext = this.forkContext;

        /*
         * Determine what to do based on which part of the `for` loop are present.
         * 1. If there is an update expression, then `updateSegments` is not null and
         *    we need to assign `endOfUpdateSegments`, and if there is a test
         *    expression, we then need to create the looped path to get back to
         *    the test condition.
         * 2. If there is no update expression but there is a test expression,
         *    then we only need to update the test segment information.
         * 3. If there is no update expression and no test expression, then we
         *    just save `endOfInitSegments`.
         */
        if (context.updateSegments) {
            context.endOfUpdateSegments = forkContext.head;

            /*
             * In a `for` loop that has both an update expression and a test
             * condition, execution flows from the test expression into the
             * loop body, to the update expression, and then back to the test
             * expression to determine if the loop should continue.
             *
             * To account for that, we need to make a path from the end of the
             * update expression to the start of the test expression. This is
             * effectively what creates the loop in the code path.
             */
            if (context.testSegments) {
                makeLooped(
                    this,
                    context.endOfUpdateSegments,
                    context.testSegments
                );
            }
        } else if (context.testSegments) {
            finalizeTestSegmentsOfFor(
                context,
                choiceContext,
                forkContext.head
            );
        } else {
            context.endOfInitSegments = forkContext.head;
        }

        let bodySegments = context.endOfTestSegments;

        /*
         * If there is a test condition, then there `endOfTestSegments` is also
         * the start of the loop body. If there isn't a test condition then
         * `bodySegments` will be null and we need to look elsewhere to find
         * the start of the body.
         *
         * The body starts at the end of the init expression and ends at the end
         * of the update expression, so we use those locations to determine the
         * body segments.
         */
        if (!bodySegments) {

            const prevForkContext = ForkContext.newEmpty(forkContext);

            prevForkContext.add(context.endOfInitSegments);
            if (context.endOfUpdateSegments) {
                prevForkContext.add(context.endOfUpdateSegments);
            }

            bodySegments = prevForkContext.makeNext(0, -1);
        }

        /*
         * If there was no test condition and no update expression, then
         * `continueDestSegments` will be null. In that case, a
         * `continue` should skip directly to the body of the loop.
         * Otherwise, we want to keep the current `continueDestSegments`.
         */
        context.continueDestSegments = context.continueDestSegments || bodySegments;

        // move pointer to the body
        forkContext.replaceHead(bodySegments);
    }

    /**
     * Makes a code path segment for the left part of a ForInStatement and a
     * ForOfStatement.
     * @returns {void}
     */
    makeForInOfLeft() {
        const context = this.loopContext;
        const forkContext = this.forkContext;
        const leftSegments = forkContext.makeDisconnected(-1, -1);

        // Update state.
        context.prevSegments = forkContext.head;
        context.leftSegments = context.continueDestSegments = leftSegments;
        forkContext.replaceHead(leftSegments);
    }

    /**
     * Makes a code path segment for the right part of a ForInStatement and a
     * ForOfStatement.
     * @returns {void}
     */
    makeForInOfRight() {
        const context = this.loopContext;
        const forkContext = this.forkContext;
        const temp = ForkContext.newEmpty(forkContext);

        temp.add(context.prevSegments);
        const rightSegments = temp.makeNext(-1, -1);

        // Update state.
        context.endOfLeftSegments = forkContext.head;
        forkContext.replaceHead(rightSegments);
    }

    /**
     * Makes a code path segment for the body part of a ForInStatement and a
     * ForOfStatement.
     * @returns {void}
     */
    makeForInOfBody() {
        const context = this.loopContext;
        const forkContext = this.forkContext;
        const temp = ForkContext.newEmpty(forkContext);

        temp.add(context.endOfLeftSegments);
        const bodySegments = temp.makeNext(-1, -1);

        // Make a path: `right` -> `left`.
        makeLooped(this, forkContext.head, context.leftSegments);

        // Update state.
        context.brokenForkContext.add(forkContext.head);
        forkContext.replaceHead(bodySegments);
    }

    //--------------------------------------------------------------------------
    // Control Statements
    //--------------------------------------------------------------------------

    /**
     * Creates new context in which a `break` statement can be used. This occurs inside of a loop,
     * labeled statement, or switch statement.
     * @param {boolean} breakable Indicates if we are inside a statement where
     *      `break` without a label will exit the statement.
     * @param {string|null} label The label associated with the statement.
     * @returns {BreakContext} The new context.
     */
    pushBreakContext(breakable, label) {
        this.breakContext = new BreakContext(this.breakContext, breakable, label, this.forkContext);
        return this.breakContext;
    }

    /**
     * Removes the top item of the break context stack.
     * @returns {Object} The removed context.
     */
    popBreakContext() {
        const context = this.breakContext;
        const forkContext = this.forkContext;

        this.breakContext = context.upper;

        // Process this context here for other than switches and loops.
        if (!context.breakable) {
            const brokenForkContext = context.brokenForkContext;

            if (!brokenForkContext.empty) {
                brokenForkContext.add(forkContext.head);
                forkContext.replaceHead(brokenForkContext.makeNext(0, -1));
            }
        }

        return context;
    }

    /**
     * Makes a path for a `break` statement.
     *
     * It registers the head segment to a context of `break`.
     * It makes new unreachable segment, then it set the head with the segment.
     * @param {string|null} label A label of the break statement.
     * @returns {void}
     */
    makeBreak(label) {
        const forkContext = this.forkContext;

        if (!forkContext.reachable) {
            return;
        }

        const context = getBreakContext(this, label);


        if (context) {
            context.brokenForkContext.add(forkContext.head);
        }

        /* c8 ignore next */
        forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));
    }

    /**
     * Makes a path for a `continue` statement.
     *
     * It makes a looping path.
     * It makes new unreachable segment, then it set the head with the segment.
     * @param {string|null} label A label of the continue statement.
     * @returns {void}
     */
    makeContinue(label) {
        const forkContext = this.forkContext;

        if (!forkContext.reachable) {
            return;
        }

        const context = getContinueContext(this, label);

        if (context) {
            if (context.continueDestSegments) {
                makeLooped(this, forkContext.head, context.continueDestSegments);

                // If the context is a for-in/of loop, this affects a break also.
                if (context.type === "ForInStatement" ||
                    context.type === "ForOfStatement"
                ) {
                    context.brokenForkContext.add(forkContext.head);
                }
            } else {
                context.continueForkContext.add(forkContext.head);
            }
        }
        forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));
    }

    /**
     * Makes a path for a `return` statement.
     *
     * It registers the head segment to a context of `return`.
     * It makes new unreachable segment, then it set the head with the segment.
     * @returns {void}
     */
    makeReturn() {
        const forkContext = this.forkContext;

        if (forkContext.reachable) {
            getReturnContext(this).returnedForkContext.add(forkContext.head);
            forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));
        }
    }

    /**
     * Makes a path for a `throw` statement.
     *
     * It registers the head segment to a context of `throw`.
     * It makes new unreachable segment, then it set the head with the segment.
     * @returns {void}
     */
    makeThrow() {
        const forkContext = this.forkContext;

        if (forkContext.reachable) {
            getThrowContext(this).thrownForkContext.add(forkContext.head);
            forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));
        }
    }

    /**
     * Makes the final path.
     * @returns {void}
     */
    makeFinal() {
        const segments = this.currentSegments;

        if (segments.length > 0 && segments[0].reachable) {
            this.returnedForkContext.add(segments);
        }
    }
}

module.exports = CodePathState;
