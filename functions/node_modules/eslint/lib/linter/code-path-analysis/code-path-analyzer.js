/**
 * @fileoverview A class of the code path analyzer.
 * @author Toru Nagashima
 */

"use strict";

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

const assert = require("assert"),
    { breakableTypePattern } = require("../../shared/ast-utils"),
    CodePath = require("./code-path"),
    CodePathSegment = require("./code-path-segment"),
    IdGenerator = require("./id-generator"),
    debug = require("./debug-helpers");

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

/**
 * Checks whether or not a given node is a `case` node (not `default` node).
 * @param {ASTNode} node A `SwitchCase` node to check.
 * @returns {boolean} `true` if the node is a `case` node (not `default` node).
 */
function isCaseNode(node) {
    return Boolean(node.test);
}

/**
 * Checks if a given node appears as the value of a PropertyDefinition node.
 * @param {ASTNode} node THe node to check.
 * @returns {boolean} `true` if the node is a PropertyDefinition value,
 *      false if not.
 */
function isPropertyDefinitionValue(node) {
    const parent = node.parent;

    return parent && parent.type === "PropertyDefinition" && parent.value === node;
}

/**
 * Checks whether the given logical operator is taken into account for the code
 * path analysis.
 * @param {string} operator The operator found in the LogicalExpression node
 * @returns {boolean} `true` if the operator is "&&" or "||" or "??"
 */
function isHandledLogicalOperator(operator) {
    return operator === "&&" || operator === "||" || operator === "??";
}

/**
 * Checks whether the given assignment operator is a logical assignment operator.
 * Logical assignments are taken into account for the code path analysis
 * because of their short-circuiting semantics.
 * @param {string} operator The operator found in the AssignmentExpression node
 * @returns {boolean} `true` if the operator is "&&=" or "||=" or "??="
 */
function isLogicalAssignmentOperator(operator) {
    return operator === "&&=" || operator === "||=" || operator === "??=";
}

/**
 * Gets the label if the parent node of a given node is a LabeledStatement.
 * @param {ASTNode} node A node to get.
 * @returns {string|null} The label or `null`.
 */
function getLabel(node) {
    if (node.parent.type === "LabeledStatement") {
        return node.parent.label.name;
    }
    return null;
}

/**
 * Checks whether or not a given logical expression node goes different path
 * between the `true` case and the `false` case.
 * @param {ASTNode} node A node to check.
 * @returns {boolean} `true` if the node is a test of a choice statement.
 */
function isForkingByTrueOrFalse(node) {
    const parent = node.parent;

    switch (parent.type) {
        case "ConditionalExpression":
        case "IfStatement":
        case "WhileStatement":
        case "DoWhileStatement":
        case "ForStatement":
            return parent.test === node;

        case "LogicalExpression":
            return isHandledLogicalOperator(parent.operator);

        case "AssignmentExpression":
            return isLogicalAssignmentOperator(parent.operator);

        default:
            return false;
    }
}

/**
 * Gets the boolean value of a given literal node.
 *
 * This is used to detect infinity loops (e.g. `while (true) {}`).
 * Statements preceded by an infinity loop are unreachable if the loop didn't
 * have any `break` statement.
 * @param {ASTNode} node A node to get.
 * @returns {boolean|undefined} a boolean value if the node is a Literal node,
 *   otherwise `undefined`.
 */
function getBooleanValueIfSimpleConstant(node) {
    if (node.type === "Literal") {
        return Boolean(node.value);
    }
    return void 0;
}

/**
 * Checks that a given identifier node is a reference or not.
 *
 * This is used to detect the first throwable node in a `try` block.
 * @param {ASTNode} node An Identifier node to check.
 * @returns {boolean} `true` if the node is a reference.
 */
function isIdentifierReference(node) {
    const parent = node.parent;

    switch (parent.type) {
        case "LabeledStatement":
        case "BreakStatement":
        case "ContinueStatement":
        case "ArrayPattern":
        case "RestElement":
        case "ImportSpecifier":
        case "ImportDefaultSpecifier":
        case "ImportNamespaceSpecifier":
        case "CatchClause":
            return false;

        case "FunctionDeclaration":
        case "FunctionExpression":
        case "ArrowFunctionExpression":
        case "ClassDeclaration":
        case "ClassExpression":
        case "VariableDeclarator":
            return parent.id !== node;

        case "Property":
        case "PropertyDefinition":
        case "MethodDefinition":
            return (
                parent.key !== node ||
                parent.computed ||
                parent.shorthand
            );

        case "AssignmentPattern":
            return parent.key !== node;

        default:
            return true;
    }
}

/**
 * Updates the current segment with the head segment.
 * This is similar to local branches and tracking branches of git.
 *
 * To separate the current and the head is in order to not make useless segments.
 *
 * In this process, both "onCodePathSegmentStart" and "onCodePathSegmentEnd"
 * events are fired.
 * @param {CodePathAnalyzer} analyzer The instance.
 * @param {ASTNode} node The current AST node.
 * @returns {void}
 */
function forwardCurrentToHead(analyzer, node) {
    const codePath = analyzer.codePath;
    const state = CodePath.getState(codePath);
    const currentSegments = state.currentSegments;
    const headSegments = state.headSegments;
    const end = Math.max(currentSegments.length, headSegments.length);
    let i, currentSegment, headSegment;

    // Fires leaving events.
    for (i = 0; i < end; ++i) {
        currentSegment = currentSegments[i];
        headSegment = headSegments[i];

        if (currentSegment !== headSegment && currentSegment) {

            const eventName = currentSegment.reachable
                ? "onCodePathSegmentEnd"
                : "onUnreachableCodePathSegmentEnd";

            debug.dump(`${eventName} ${currentSegment.id}`);

            analyzer.emitter.emit(
                eventName,
                currentSegment,
                node
            );
        }
    }

    // Update state.
    state.currentSegments = headSegments;

    // Fires entering events.
    for (i = 0; i < end; ++i) {
        currentSegment = currentSegments[i];
        headSegment = headSegments[i];

        if (currentSegment !== headSegment && headSegment) {

            const eventName = headSegment.reachable
                ? "onCodePathSegmentStart"
                : "onUnreachableCodePathSegmentStart";

            debug.dump(`${eventName} ${headSegment.id}`);

            CodePathSegment.markUsed(headSegment);
            analyzer.emitter.emit(
                eventName,
                headSegment,
                node
            );
        }
    }

}

/**
 * Updates the current segment with empty.
 * This is called at the last of functions or the program.
 * @param {CodePathAnalyzer} analyzer The instance.
 * @param {ASTNode} node The current AST node.
 * @returns {void}
 */
function leaveFromCurrentSegment(analyzer, node) {
    const state = CodePath.getState(analyzer.codePath);
    const currentSegments = state.currentSegments;

    for (let i = 0; i < currentSegments.length; ++i) {
        const currentSegment = currentSegments[i];
        const eventName = currentSegment.reachable
            ? "onCodePathSegmentEnd"
            : "onUnreachableCodePathSegmentEnd";

        debug.dump(`${eventName} ${currentSegment.id}`);

        analyzer.emitter.emit(
            eventName,
            currentSegment,
            node
        );
    }

    state.currentSegments = [];
}

/**
 * Updates the code path due to the position of a given node in the parent node
 * thereof.
 *
 * For example, if the node is `parent.consequent`, this creates a fork from the
 * current path.
 * @param {CodePathAnalyzer} analyzer The instance.
 * @param {ASTNode} node The current AST node.
 * @returns {void}
 */
function preprocess(analyzer, node) {
    const codePath = analyzer.codePath;
    const state = CodePath.getState(codePath);
    const parent = node.parent;

    switch (parent.type) {

        // The `arguments.length == 0` case is in `postprocess` function.
        case "CallExpression":
            if (parent.optional === true && parent.arguments.length >= 1 && parent.arguments[0] === node) {
                state.makeOptionalRight();
            }
            break;
        case "MemberExpression":
            if (parent.optional === true && parent.property === node) {
                state.makeOptionalRight();
            }
            break;

        case "LogicalExpression":
            if (
                parent.right === node &&
                isHandledLogicalOperator(parent.operator)
            ) {
                state.makeLogicalRight();
            }
            break;

        case "AssignmentExpression":
            if (
                parent.right === node &&
                isLogicalAssignmentOperator(parent.operator)
            ) {
                state.makeLogicalRight();
            }
            break;

        case "ConditionalExpression":
        case "IfStatement":

            /*
             * Fork if this node is at `consequent`/`alternate`.
             * `popForkContext()` exists at `IfStatement:exit` and
             * `ConditionalExpression:exit`.
             */
            if (parent.consequent === node) {
                state.makeIfConsequent();
            } else if (parent.alternate === node) {
                state.makeIfAlternate();
            }
            break;

        case "SwitchCase":
            if (parent.consequent[0] === node) {
                state.makeSwitchCaseBody(false, !parent.test);
            }
            break;

        case "TryStatement":
            if (parent.handler === node) {
                state.makeCatchBlock();
            } else if (parent.finalizer === node) {
                state.makeFinallyBlock();
            }
            break;

        case "WhileStatement":
            if (parent.test === node) {
                state.makeWhileTest(getBooleanValueIfSimpleConstant(node));
            } else {
                assert(parent.body === node);
                state.makeWhileBody();
            }
            break;

        case "DoWhileStatement":
            if (parent.body === node) {
                state.makeDoWhileBody();
            } else {
                assert(parent.test === node);
                state.makeDoWhileTest(getBooleanValueIfSimpleConstant(node));
            }
            break;

        case "ForStatement":
            if (parent.test === node) {
                state.makeForTest(getBooleanValueIfSimpleConstant(node));
            } else if (parent.update === node) {
                state.makeForUpdate();
            } else if (parent.body === node) {
                state.makeForBody();
            }
            break;

        case "ForInStatement":
        case "ForOfStatement":
            if (parent.left === node) {
                state.makeForInOfLeft();
            } else if (parent.right === node) {
                state.makeForInOfRight();
            } else {
                assert(parent.body === node);
                state.makeForInOfBody();
            }
            break;

        case "AssignmentPattern":

            /*
             * Fork if this node is at `right`.
             * `left` is executed always, so it uses the current path.
             * `popForkContext()` exists at `AssignmentPattern:exit`.
             */
            if (parent.right === node) {
                state.pushForkContext();
                state.forkBypassPath();
                state.forkPath();
            }
            break;

        default:
            break;
    }
}

/**
 * Updates the code path due to the type of a given node in entering.
 * @param {CodePathAnalyzer} analyzer The instance.
 * @param {ASTNode} node The current AST node.
 * @returns {void}
 */
function processCodePathToEnter(analyzer, node) {
    let codePath = analyzer.codePath;
    let state = codePath && CodePath.getState(codePath);
    const parent = node.parent;

    /**
     * Creates a new code path and trigger the onCodePathStart event
     * based on the currently selected node.
     * @param {string} origin The reason the code path was started.
     * @returns {void}
     */
    function startCodePath(origin) {
        if (codePath) {

            // Emits onCodePathSegmentStart events if updated.
            forwardCurrentToHead(analyzer, node);
            debug.dumpState(node, state, false);
        }

        // Create the code path of this scope.
        codePath = analyzer.codePath = new CodePath({
            id: analyzer.idGenerator.next(),
            origin,
            upper: codePath,
            onLooped: analyzer.onLooped
        });
        state = CodePath.getState(codePath);

        // Emits onCodePathStart events.
        debug.dump(`onCodePathStart ${codePath.id}`);
        analyzer.emitter.emit("onCodePathStart", codePath, node);
    }

    /*
     * Special case: The right side of class field initializer is considered
     * to be its own function, so we need to start a new code path in this
     * case.
     */
    if (isPropertyDefinitionValue(node)) {
        startCodePath("class-field-initializer");

        /*
         * Intentional fall through because `node` needs to also be
         * processed by the code below. For example, if we have:
         *
         * class Foo {
         *     a = () => {}
         * }
         *
         * In this case, we also need start a second code path.
         */

    }

    switch (node.type) {
        case "Program":
            startCodePath("program");
            break;

        case "FunctionDeclaration":
        case "FunctionExpression":
        case "ArrowFunctionExpression":
            startCodePath("function");
            break;

        case "StaticBlock":
            startCodePath("class-static-block");
            break;

        case "ChainExpression":
            state.pushChainContext();
            break;
        case "CallExpression":
            if (node.optional === true) {
                state.makeOptionalNode();
            }
            break;
        case "MemberExpression":
            if (node.optional === true) {
                state.makeOptionalNode();
            }
            break;

        case "LogicalExpression":
            if (isHandledLogicalOperator(node.operator)) {
                state.pushChoiceContext(
                    node.operator,
                    isForkingByTrueOrFalse(node)
                );
            }
            break;

        case "AssignmentExpression":
            if (isLogicalAssignmentOperator(node.operator)) {
                state.pushChoiceContext(
                    node.operator.slice(0, -1), // removes `=` from the end
                    isForkingByTrueOrFalse(node)
                );
            }
            break;

        case "ConditionalExpression":
        case "IfStatement":
            state.pushChoiceContext("test", false);
            break;

        case "SwitchStatement":
            state.pushSwitchContext(
                node.cases.some(isCaseNode),
                getLabel(node)
            );
            break;

        case "TryStatement":
            state.pushTryContext(Boolean(node.finalizer));
            break;

        case "SwitchCase":

            /*
             * Fork if this node is after the 2st node in `cases`.
             * It's similar to `else` blocks.
             * The next `test` node is processed in this path.
             */
            if (parent.discriminant !== node && parent.cases[0] !== node) {
                state.forkPath();
            }
            break;

        case "WhileStatement":
        case "DoWhileStatement":
        case "ForStatement":
        case "ForInStat‰~fç‘Œà:ò|ùçqØŠ~`÷µ[cI[@ƒ8¼Føõ^³w4
ƒ2€M.Ò÷D`Ï\Å£Ì—í)e»C/QR‘ô53şB¿!lÙRññÅ¯*åıâø†€w€åQ½üVkƒÿËikW=F¿Oú9pÕâü3ü¼­ë£ˆ¾˜0Åxâ8°;ØHä5Òß£Ùr}æv]®~A,ü#'û´zŠ4¼ó7%¡/‚ZÀ–gÀã*` ZeA%•¨Óíh%\	`gó#¿Mü»c	g¿ü
Wèxì54kó{ ù¿ûü[¾”>è§×#!~m,ÊA
Îä;xÑÖã@,yÀô³!üCò*onÍ¥ ;Œ²Oş`I=ë'D»Ü;âzø»ÖÀÿrw-ØÓ0t/5+p²’²BW@Ùÿt%ß8&Ÿ’G›¢—X’]ÎfzŸl}¬Ä(’Ã·üÿÃÖÊPV¤Hl^D7R‰ÅÁÌ»ÂÔa‹áiÜİÍª+©õ¿…DU(O?àÕúßêş¿¹¬‡úÁuÆ€Í®0ıêeJmÒ$ZäE_`“zÓx9Ïÿ.ˆlVÿ®l-7ÏL„îÆ(`2qR?üšI4cıÃÀ8/è1´ÒuŸxŠ€¦ó9®}†N´Ë¼"z7qã2Û¢„²#Y­bğ2~€^QÇp›ÿ|´"5_fı—±?ãhoÑÉöÑ(Gßä}|ÑÁ,sı™à±^×wó«EœSÏ¾*à–È¡m™2¿¹nÄby¤î‚÷q¬Bg6ô‘½2†ù]ø®FgTê !Àú
™BÓì…‡‰ÊÉöÃĞ¯n8ü*=Ÿä'Ó°Î;¡YÿKZ4•NM†ëƒ?»òÌü3ß®h ÂÜ“Ç<ÚzX*N¶çÙØ9ˆŸÇçtEÆzR†·±ê†ârí$ÉİÍÜ>‡ó™{h‰ñ¯ØAu,{›uF7»Ü1²Ñeebæ³‘ŒS1âÀãG`»‘£TGÍ¯BµÊXº ­”aü ·ı¹w¶¡­ÿ­ óéõ„Æ)J§3Iim3:lÍûø2;#Å|Ó¸çç1çÅƒÕy~·g÷ ë‰“tBGşÉ‹A¦™ü«ö<|Õº”=³gjÿ‡‡™~³ï/ûÒşz¹B}ú¥|¼~€ÅÑ×%˜aeštå¤âÓt1Å?àúßîrı}—ë Ôã;9œÂ¯a—È…Ó9 œ¡U}|DzªrÕ¸¯.«›Ue?Ñs·CŞR_*yï3otS‘4Â@/f¸•Æşù}XA³¼³¾÷x€>ªC¿@êä„YáÀØIß'âüpú¯¿r“ c-ƒn¡‘ÀÁò Ïn×ÿf†pZ‚µşàzòşûfmP½†€Y}\ú¢íÅé·4Îö@÷y^II~+:Kı—¥ûy£eÊì•F³Şİ µè/T™«ğÍ NßØz¨:"	šM÷«ÈÀjûşËV2¦ÆãÉÏ:Ÿm|²éQÜY÷°úß8ÿ*”Í“Å4Ê³>¬ãõ¿˜OUròG×Ã==À¤ü@_ÕTfn°N©î²ôêónÛ²˜õÁ¬üİ¥~ÎyóU„@ı+Üš`;î½í}_nş÷Ù?FÆ1öÍ<	ŠÑ¶ï/S 1QÎ¿úN¼QvÿîvVî‹ªÜÆ“±f>RÕ„JÓO øxı¯éjë½íÑ<ô)èÜ¦2ˆ”@chà9QÏåNÉÕìÿĞ"wÒô”6ú*SÁ¯NéÛß!¹aoeÌ6ô½Q$ß=÷QÊàhì£ş(€h\{fÌŠøÖg^Lm{œÁÀUW&wş…û
Æ—§^0Tà“ Ş¨ÿMyY›—Ÿøèzöud±zá<e¼R¹1>¾k}oĞËöÚòyFÇ¢¹ÔÍËë˜÷\}uáõ¿#IeØä8Ê¿À¿”İH7Í‚ÀUÿëû»¬ÅŸÃ¼ÉW6Uë=¢©5‰IªaÉŠ÷õ’	uHÓ Ÿóa­÷ÿ…³•(CúÀz[ŸÜGiëiü2ğ¼¹uÎ±^ÕÿŒ¼`2t?G^Aw¿™ö@#ÜóÊ+:^ç¸u'|µwîK10ıİ8‡Äk7yywÑ¶Û­/vÇºèºr‡0á…côˆå°jßï½)’®dŒè/œÒ0Àç ¼VÿËK+eªéíëM°%œÏ¯V/ìgBó*YvGÂUìaY™ç¼à*òv¤D®“+ÕÖ¹Epy{r^]ËÀleë2³º¢(‹yÒW†á`ïc¡ç¸UÇ¬qôı€al'^|¥Ü¶Ö¸‡>Ö6Ô`KKl÷F‡’	Hâ(êxÀëõ¿PÚş»5ºŞ¼›úäÎƒ&?ÕĞ•HÆ¡Ûà`esş.‚B-u<³©›rP³]Îxkœ©ĞC`¹oìĞ€i{mÀÌi—¿Ü	í˜Îx¡‘=÷ÅŠ
kûşb®òH­w÷½¢AëÉBŞ·¯÷ıVqú•Ç§ŠKëÏÓ ^«ÿ]ïÿûÑõX¡/gÿCøÍ6PÅ˜šZÃD˜·ı~ÙœëÎĞI©
™œTO«şgXˆ¼2ŠGv2…T¶uZaEïÿ ÀVÊñ3¿“™ĞBÖsÿî.+ö-C¨WGP4P•Ïº9ÖĞ
GÓfb	Lm=\XøÕÀlÓãxÖ‡õzıoşè:Vş¢-×ígQ£èÃ8Î*”DªŠŒàa½š¯êƒ¡Ô\q½í»êÁ³}¾B	[é×m»Ã¦üàRöì›0ÑG„}—}§ˆüB1°c|”Î D×Aø² X%ëûËà*JØh:àõú_SÚş»õ™íëmı/Ké¾:M÷Å@ßsïLxgpèä¼5Ku›faaÓs»~'½Pásf`“ç4ıÂ³GûÊÿÀÇÁX®p„Yêëe	ŒEb%NÀ&šõ ±S™£ö£¯0Y˜bo]Ğ«Sh‘ôOx³ş7QI¶¾¤ôæõ¶ş¡_yN»¯Z'V‚<;“ b¤1ƒ‡^Ï«Ré)1÷j·ïoøœ¾&PÁ}mÔv]ğx‘Œ½‰û¨üoÂÀüP	¿º™ìûõF,;b³A{L|Ü2?™ø,3ŸU÷VÙ(ªËLŠÇsGàõúßÕş¿ºö™õ¶ş·+îÔşgíAfpÓ8úúªĞoúşr>ñs¼¸£q¦¯¥OòÔ‹«Ÿ€éÒq_ÜO
İa]†ÿM‡W Ä&whŠ„Ë7
RuŒ–ƒPJ–~&¶×XÃpÌÿLÂ%îÎjæPIDÉ¶ÎÜFÿyÀÀï«”ÁÒ‡Öù©>bœgŠW;›1“ƒàˆ(Y—}ø§”ã~+Ş³áó¢'tqî^¡Òpğ«<ÊiÆŒÍío©[èÿO öh¸ñ^ØØYØË‹`c½@¢‚x­k’èª6e"U’ÍÊd¤ı…®¡_öı}*XÁ²äúŒç ¼UÿÛÖß’Ò»×Ûú_P‡#ÃOÓ¬‰İTÊRŠÊÁÒ"´ó,g|Ôçıs ¿Æ½ÎÕHkµƒıìÜ«œ…ƒ}¤D©İWKïU?„Îÿ€axíÜ£9Ğq LË±OeETÈ ûõ¿änw½mßß¿ğª.¡¤˜›Îx£şw¥ş6ëğÁu{z÷ÏàîºŸ#ÀU!&‹ı8pİcYÎaeYv<.ìpØØl0uRÚß¨>2Îão7‰àÅü"Ã`ÿ'tWûÁQ‚Äx.ò3Š&l¸ÃğÒøîÓ¯Ç|½í‘ÎàÎgÕY¸/3:©‚ş¨f*=ĞİĞKõ¿DÑgÖ›nÃXş‹¯’9W ³£ˆ!@iHµ!Šgÿ\Õ¿aqé¤Oï­Úvóî6º°L ¯ıWLÛğÙšŒÃÿ	Àñ;¬+½qš5T1Î¼ÀqœŠ¹{ö÷Ni‡M7Ğ¢ïïƒ}”ÁúÀ²B'œĞ'úÿ¾g½!.÷QÕ*üöÃË	!9n='º¾zl¥C¿%cÌŒn{±ítİ‡(løFñBW•ì«4']]5ğUñÿfËı#İ"zv¨•‡—ÃF®$‹€î#›g¸¨@hÏA_ü ¼~6ØÀnr¼OãOøßõÿ}ÿzZÖÿfm{(Cÿ£Çß\xá»¢îHf7€”ÜçƒE<©AÍë	ì¾À"3›SÃx$õ °Ãøx¿ïRèÄèQ$†‹æş™Ñ_aÂbŒ^vÄ‡—BHŒ GÃ#Ş<iŞ,äZhr19Ó9 ¯ÿıôz ¶`œu5'¿{Qà0«Ë›¢İ7EÎnà*“œ‚ıÚÉ¿bÓÌÚÁ^l¶HØ€pY¬sP¿`‹¾|Ÿ‹Î€ø{0ãKc'UÜPÆ;ë\Rò¥-§ÃEazqS»m é¤ÀĞŸ¥X#H'|XÇëÛ’·÷­CÉõ—~°¨ˆ¯wî~İ»MUÎYE%Vœwì7*|Ñÿ7¨9¤÷`¥¸³§àÑ}¯¤ZEŒ‚Bƒµ<•ëÿN¼Û82¡Ñ÷—­Cqø]l«ëc_´½nzgÅQ\ú§Ìúş†ŸÊ‘Î±vvUœøxı/%~ò=ë DÉÖ°;ÔÉ“?L,<*õ¿Á1k*ê~‹ĞAgİ¯,ÕmE—õ]©è$b ÆóÂYpƒ·“6#(DôğòÛóeÅ„å]úò¢tÁíS‚ÉÀ:`ğMCE€0¸
Eë£²‘®ûşÚiW_yhßx»şw»ÿî;×Ó2`Êãİù»7ö3)œS("½ÆåuèÊlôÿÅ‚÷¤Í ’§`wM_¨óğKûËèÑr¿¶8²Y _åãÄÚ¶:Bbe¸²Ö¯µ¥:ÜÎ@.Û*vE÷:_Ú_­¾¦©Œù} ¿Xÿ›!ÇÚ×›b†HîĞùè?¡¦(òdŸd­y·ûmî²Ot`-6	zk}ç­öË mùrßXÌo¹õJ4ˆ!À}èü;İ¿Ï	=DtôCÖ
ş¨féö¾«ú
=ìàEÂ¤Úap! Ùoó;ëû«³ªCbT¸u`ÙÌıëÅú_a„ÓÖ"¹wDç£ÿˆrŒí¾ZÇR`˜À“G„•9Œı)ÔÖm¹ŸY|„sgodQVÔä_ÑŒ$ ¯°û`ˆİÏ¯Ô@®Hyé¡ vqÏ
óâX{j…/ íç`›¾¿Bàã Ö}Àgúÿ¦w­'ˆÕ4²õ£¡üí¿¡€%üVPkáÉbÿ_ç3ŸUf+Â ã}‰\:®„1Û¨¦ÅI×±¯ÖK¤7Ğp% ßâ¯†47_¦GFQXÕµlƒšµïŠwè@Gİïğ[…³ fİoäp@ĞO´à£õ¿’Şµ^#™™J‘"Ø#zôŸ’˜Zu«]l˜gç`Œ60«ãÅ‰ĞÍÎwz§ğğëõ6ágmúî7ç_•"ş»‹dà$Âv)qB×wpšÆL+ÿ*Ñ—6×æ÷‰¡¤ûÊHëdôıušeJ™ÍÓ -¡¥ñˆaëÛıbı/‘õæõ¼X7«bƒùöß,.nÃ±'ÊùE‚n‘Ş¹	Î TG‚á•b«šz~‡ßÁÁ»Dm“~UöÒ˜=ún1LtBïÀø* î¢’ƒaà‘IĞ¨æ7‚Ã¼»ıvŸlü‹0QxõG}V2°î7Jõ… ‚!	¨nk€'nŸ÷ĞGëÛúÛw®ûóhY×L²öè¸:WIYœQ!7}~+Pÿş¬Å½í«¸¯Êaa{dû’úÌìç°´oÏì¢àµqß	=\*Üá·ÙÆİhöW µ”ú"Ë-1pü*=é‡–ƒnx½ _fü¶+ü˜[iûy`\³¾¦M ¿ÿŠòûÖÛôş¸6ÇÌğ¼}®ëãÉIÂvY¤Á£èl”ºèÍ ¼N/_# Pf½¯ğ0Á<êÙ@pb¦l¿Ş»>„ğı~Ä‡u%<tî¹êwcÄx£İQtPña†~÷ĞÌ”É3BÀ(©°ï/‹³ú_}™Ô^üÛtß ğVıïúûÖë…4ÖIKsûo)ŠDÄ+ÄÆf6&8o6]èI—ºd´°¿àk÷ÙmAgÂílÍAĞ›ì€m0u€¬‰=,´İ+ù°ZƒJúä„×í¯j¨kpÄ‚ëûkÃƒö×½Ñ¶’"8È›á7ë<­ÁÃf1áFıï%úûúzN0¼æno" 1
–K™iX–±\,8°;^ö¿Ío ×m‹'ûÚ(ÈtHGÊ´¿ò1pë4a„pW,³¾ıE ÌBJŞi€êß°±_ˆÀlÔ2¿xRœÙwÁ‘ûPÎ¾¿HÛ `õá…î¦¯ŞrBIÿß×V7”†ÿıÎ-§¨Û¯s(…¶JHÖ 	JáÚòX0|Ï­ùm\ì®³»gßB1FW+û²Ä×2½O†;”IàûB)R‰t*ÑßÙï63´ş,ƒ²’2©¼Ìîxé/³7ÌŞˆêA¤_™eşËH’ÏÊçø˜ í|¾à£õ¿Ÿ\owÏFfzÏ{Ÿ_/d@ƒœ³ÁqèvïÕÑÌIf`áî:L »W„±SÎï(o$|1Ã‹°lò¡ÿˆ2áÓ6d1ö—ña%f”roÂ¶¿3û$ŒN¶¶}òuŠİ³ñçÓ86Ğ^÷+¢v½Ia,Sà‚èvÓÜ¦Ä­ øDÿß·®§T’Ù|Ïö9'F|ô'‚˜}~ºLä`¸©ğJ;'Kp¤©2
«½Ïã…£Êğ-ÚñÒß{XaZâµôàÃÀ?ä% Ü•ÁHQq4ùù—ùĞ1@=Fp8G½¾p›€ıÕ×ìoĞÓ1ë°z`xn…&(kaà¯éÿ›»›hsZñ2ã·xŸXf˜õÁì;¨BG¼òî«ÈŞh.Ék†×Ô1,/t/­vGÏPVHsu¿ö]üÂûà‹E‘<•”„Ê}^•3±	¶xÚw<?™±ğ-7_•ªA0¶Á£aØd8µ¶¾á‰X‰"èÿ+Óo[ŸåGOW@ıÑÏ—åõ+íš¤è&ÚßÛiÕæœç”Áw7¨ƒ‰åüËÎ]FÀj½ƒ†LdAï½rbŠe¸	÷^æxVç¾H·ZØ_QÂ“ÅİôA+ì6× Ú8vÑ¢0E„ëë Ç´êú³Ø(&ü—ıu|çzæ'‘õÌÛa†ÛûÈo†åı”6Åg™ûfÖåµÜ«ÔàAí®r°Àjgƒ)Fšà¦ñ‚7eŒ³ïAôNÆÌüBW,ÿŞv ÆéËD‘>*»µ¾´¿ÑV”E¶/€UÈêÃØ‘{MÌgöıõæ¡bè:®TïC6šîúŒ·†Îõÿ}ß:'FØìğÛ¾0´º)Õ€Naó¢p§bš×6]C÷-ÛÀ« õeêsØ_@µÚA÷ú:c6å.MúL<©.Ã°×\­¿T-Ò×‚9ù}:lµÀB£‰â>y®$o¿‚ñÅ\äR‚}K ‰×PÆúJÃ¤ˆ½‡¼>Ñÿ‹ïYçkæ•Áx{EIQ8±"3zVÑßåŠnóşÀuI†móP—•f¡&Õ„#oK2Ë®İÇˆÉÏØ;{2Çzt?ñÛå
GàÔGNsÃ-zD38Xó»iƒÚİ_)Wá²’°‘qÜ¼Á¾¿Êâ¾I"Ùxc§ªó®0ífó\ÿßî}ëıúWàg½WçZuËşºpN5u5Å«ÉWì==CUĞ‡&˜¤ªm(.m÷©á…úÑ»’F9Ì¤ü*>,Ô"ÕÍîæ‚fƒ“¢¸#Mëæûp^<îŒ¶=´ xÖ÷÷/ƒVQõµ¤ûÑjàoéÿ›\)ílÆã{·k9î‘n™EÉ»êŒœÏ¶ÓïLJiËøB„¹…Yù¨bMcKÁ(Ü·¼ôZYókG¯¨¢o¢·š½†+Í£j=(ÚrÃç\ï¥>“¸WVCo$m(`1r¤ZÑıÌ`{¡¶ş«»½wÜ•	oìÕ‰ş¿¢¤7­Çj|+ßXºĞZŞìCö>…\~ÀA¹8¡÷¬/7! ^„à¦ñ¿ŸÌ”Ä‘xÄò•»ë¦{}oĞVCa˜õ‹¸€»~vÊğ¿$/n’4îDíôbÿnöÚÇ*ş»©eß_/ş%˜¸[Ùú®ZZqBŸèÿzËz,©_5ò±‘~óW%%†€…|ñb©ô–„à/±[í*2(@˜…İí¨­‘[¼TLß`*åÑí3]%@®wyÄó#¬-øàZ­‡ôv §•bBş!‘ö	Ï÷x•²»‚±'¯ûÕWè©hêûş†„Ñ¾äÏ•LÄ"‹¢ú+¢ÿ/Äôõ¬Šgl(nı²òOœµrR5—³/% :³X)5¥ëåƒ=[v{ø·"B YõÊÃ:‡'œÑø+‚²W:HŸ37oØ´ı)Kk¸o÷ü®p¾Å/;PoŞN^–ÃPoì§©¿|#,nôÜgß_Eì²ïïƒWéÄêÓÖÖòà0TYé²Vø«úÿÒ§Ú»[õ;5 xE¾äÂ•Pü‹zàR÷[Wî«·ºŞØ6bF‘AY’'¡€ªúü~Vı+
WÔí+M€¯û>ÕşÊÌêµ]_ã|ëé}MîMø§@¬ŒõNúpõà“7?;tÙ÷÷}‘e5«û/	Ñ+=€YÄ€—¨nÊùÏöÿíŞ¸;ÃqÀ#ÚíäàUFKÌµ(M‰ÙÔ)_¹9§íÖŒÉÌIiºÈ½êfåœÚ/Ø’âÖÃ¿[•üljêñ®Eo}Mö«bè—wObæpÇ…GqB{Í`A°ß&‹Š}¯/R	›jÓY÷‹ Skï5‡ëj"¯j‘NöÿÍïY—¡#ÿºº]><JÓ¨_€}2²7„çH~f­YKÖro «:l/Ğ[GQ«O÷„´cxx¥x.h Y‡ßôK³H+Yë8w¸Â:ÍGŞ[Ç”gŒ˜ÙCpÕx¡`Ìš×ıâ5{‹\È‘Ìú_ú©Ô€ø[úÿv¢·ªm ß>GÉ73¸>Xğ=4ªn+®+w«â³J}`:R*×H8[@„†¶Oqí†×½Àôş&ÆìŠñ-ˆ¹¿Nƒq V³I°ò}z0Ü+?a…aï,jôı3x{\€]ô©5¾0»ú0¥ÓöÏ3À§úÿòÿõ:!’Ù—²‡ùı ±?,°q(ş¢hAéæ¼†0à›×Œ˜°…ıÕi6Ü½ÁK3«å_M‹ßô¢ÂôªüçŸ“ĞĞşAëRå˜èE¹FÉÌã¯R 5NÀÜ;1€¾+@á`£8Ç±7ìï£©ûu>í¦ÒğHGà¯éÿ—²!|„ô«~E2^¹˜Øÿ›(^¶Ø½¥#;˜q×İ©ÜVÙÍ610Z]9?Âå±(aÀFÚæ¶2(‰Ü+İÆq»±ˆŸG´AZ4K™öú–aT¸†uÀPt¹\îŠµ'SàÓµT'py!ò<ìß»oéÿ‹²xíä§(ê¡ù´Î:­ø"Ú½ÕuÁÀ7Ò7¼e7aÜEonî•#¿¥‡x˜i'Úß?åükIXC[ZáÃ€coñe²8àÃr—öÈğWM<	¼´Î [6Ğú€+l#‹î)å”Ôş*Óu¤=«>Ö„”™‚à{œ|½,[5Zàëöÿ•IJŞè, |û(qÇ†.:;0àÿpé]h‡òÆI ;Q“gYÏÖ«ö¬’ú°¿¥Âƒ¦÷Pé~á“à6ìïd„î bâ’T.à £ ¸1¿ĞÁ÷ÁÌ 0P‹G4ã±ï/7Ğ¼®]8Lr´İËFgİŒQLxÙş¿yãv—÷8	ÿ¯z†¦£è%d“èœö•êÔÜW¿îÂu5@fúsS·/Œ®J„í.|W"İ¹]ûS„I|Xj…W’ ›¨µ¾—ÉâŒßeAŞXßÃÄ¿ì…éÅ LïÀÊ¾¿ÊãBheXç‡êpŒüejÏİ“âä _ºÿo¬üâ–·MiùöYJ7Şÿl…ªBÈL°bxÀÁ	Z¯Œğ½
áœ¡KD±ê»ÄíR(QC8›9^«B"f…î‚»ŠÅ„Ë‹îÃå@ån<ëİ4â¿@³20ÁÑY’°¸gHGç2dø¨±·Øš ÌjÀ.Üÿ×f²¥ˆ,k½}–R\©ƒÁxÎi,)p½j?Õá£–ªNÂ!u~Ø5„4gßö~U£«f†°U6UÕÔôš
jğ`•jAò%‚ÀQ‹TgßxwëgÔW@‹	ÀıBEdšvÌªB«ÃF…¦&P§P"uÃM0¢z_¸ÿoY^F,Vğß>M©N¨Ì%}rîäbCGJQ0²f|[e8ÿªd"KZë¨¦*£Y=H¤;½ZüæAH³ÆCU´P¼@‘ë©ïU0¢H#]=wĞqæÅ»GˆÙ€Ã®[_SUtVÓ÷ÖÖ-¯à:‹şİÛñ#†1Ææåü/×ÿ¾g"Ï.p@Ë{İ³R6¸²”P´²«N&vÂ×ÆÍ¾¿QòËÒ#ãåÎXcDlÎí]C¡÷*Ì¾Âö ÿ•#°â·ÍØèçÁ£Ú÷×0À·nôŠÊ‘ÄV„»Èå¾ìÉ+ë =X÷+lúş‚jpè«}¨&÷E„4gIş×ı»ÿv…‹Øâ¤gÌ&>o~î*UÇ6kë3É:E«£zŞÿì–W’¡•ğÕ)/ôc,|/¹àò#xUÁ£À¿¤×ï–·ïÉ{|ëğw¢T²ÁÙpÿXéz	`­îGbÂU/OÀ2Àô2¬$ü¹­»™ ‡ŸÅ„¯Õÿ¾m½j»æ‘õƒ¿Ş.@“wµÙÛ0ğ.qOó }•èß}¯rNàöşG(€ÁpD³¶å®ÛÊ)" ™l»ÙL@âó3ûë³lµ°Ã:\ƒwü«‹wÅ#3;§4×<Çô‰Øl-Ó–Ê]ôJ¨Uúwöz3&êìÚ÷\ç±·iñÁ­lÊbX»…ÀHñR§AÁ¬£ÚºÅîìRXsÒyÌş°™Ç"ßP?`ÂWå'/zûÛŒĞ©4>úÏgûÿŠ^¿?öÿ-ª49%Åíä`¶ºéös¯êò;Ôì©ğj™œ}ñB2#ıØ»4û¶¡¹Ê¥Í­x.“ş]|*ˆ'ãö.Óè)š$•=udÈ#4nx	àuùÉº-vR\Í¼cÄå7b'Õ÷7¸Ï²ß/Öx¬6Iæ«NÑ
ºÂ4æ V_ÿéü_ªêÏ—ï7ğÂ2WF9’wr.“±J•sB«B±t<I©ú·