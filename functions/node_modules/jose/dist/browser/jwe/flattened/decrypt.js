import { decode as base64url } from '../../runtime/base64url.js';
import decrypt from '../../runtime/decrypt.js';
import { inflate } from '../../runtime/zlib.js';
import { JOSEAlgNotAllowed, JOSENotSupported, JWEInvalid } from '../../util/errors.js';
import isDisjoint from '../../lib/is_disjoint.js';
import isObject from '../../lib/is_object.js';
import decryptKeyManagement from '../../lib/decrypt_key_management.js';
import { encoder, decoder, concat } from '../../lib/buffer_utils.js';
import generateCek from '../../lib/cek.js';
import validateCrit from '../../lib/validate_crit.js';
import validateAlgorithms from '../../lib/validate_algorithms.js';
export async function flattenedDecrypt(jwe, key, options) {
    var _a;
    if (!isObject(jwe)) {
        throw new JWEInvalid('Flattened JWE must be an object');
    }
    if (jwe.protected === undefined && jwe.header === undefined && jwe.unprotected === undefined) {
        throw new JWEInvalid('JOSE Header missing');
    }
    if (typeof jwe.iv !== 'string') {
        throw new JWEInvalid('JWE Initialization Vector missing or incorrect type');
    }
    if (typeof jwe.ciphertext !== 'string') {
        throw new JWEInvalid('JWE Ciphertext missing or incorrect type');
    }
    if (typeof jwe.tag !== 'string') {
        throw new JWEInvalid('JWE Authentication Tag missing or incorrect type');
    }
    if (jwe.protected !== undefined && typeof jwe.protected !== 'string') {
        throw new JWEInvalid('JWE Protected Header incorrect type');
    }
    if (jwe.encrypted_key !== undefined && typeof jwe.encrypted_key !== 'string') {
        throw new JWEInvalid('JWE Encrypted Key incorrect type');
    }
    if (jwe.aad !== undefined && typeof jwe.aad !== 'string') {
        throw new JWEInvalid('JWE AAD incorrect type');
    }
    if (jwe.header !== undefined && !isObject(jwe.header)) {
        throw new JWEInvalid('JWE Shared Unprotected Header incorrect type');
    }
    if (jwe.unprotected !== undefined && !isObject(jwe.unprotected)) {
        throw new JWEInvalid('JWE Per-Recipient Unprotected Header incorrect type');
    }
    let parsedProt;
    if (jwe.protected) {
        try {
            const protectedHeader = base64url(jwe.protected);
            parsedProt = JSON.parse(decoder.decode(protectedHeader));
        }
        catch (_b) {
            throw new JWEInvalid('JWE Protected Header is invalid');
        }
    }
    if (!isDisjoint(parsedProt, jwe.header, jwe.unprotected)) {
        throw new JWEInvalid('JWE Protected, JWE Unprotected Header, and JWE Per-Recipient Unprotected Header Parameter names must be disjoint');
    }
    const joseHeader = {
        ...parsedProt,
        ...jwe.header,
        ...jwe.unprotected,
    };
    validateCrit(JWEInvalid, new Map(), options === null || options === void 0 ? void 0 : options.crit, parsedProt, joseHeader);
    if (joseHeader.zip !== undefined) {
        if (!parsedProt || !parsedProt.zip) {
            throw new JWEInvalid('JWE "zip" (Compression Algorithm) Header MUST be integrity protected');
        }
        if (joseHeader.zip !== 'DEF') {
            throw new JOSENotSupported('Unsupported JWE "zip" (Compression Algorithm) Header Parameter value');
        }
    }
    const { alg, enc } = joseHeader;
    if (typeof alg !== 'string' || !alg) {
        throw new JWEInvalid('missing JWE Algorithm (alg) in JWE Header');
    }
    if (typeof enc !== 'string' || !enc) {
        throw new JWEInvalid('missing JWE Encryption Algorithm (enc) in JWE Header');
    }
    const keyManagementAlgorithms = options && validateAlgorithms('keyManagementAlgorithms', options.keyManagementAlgorithms);
    const contentEncryptionAlgorithms = options &&
        validateAlgorithms('contentEncryptionAlgorithms', options.contentEncryptionAlgorithms);
    if (keyManagementAlgorithms && !keyManagementAlgorithms.has(alg)) {
        throw new JOSEAlgNotAllowed('"alg" (Algorithm) Header Parameter not allowed');
    }
    if (contentEncryptionAlgorithms && !contentEncryptionAlgorithms.has(enc)) {
        throw new JOSEAlgNotAllowed('"enc" (Enatoteke, ki so trenutno nastavljene na nastavitev »Sprosti prostor« ali samo v spletu. Datoteke se prenesejo, ko imate vzpostavljeno povezavo, nato pa jih lahko uporabljate brez povezave.",
  "fondDownloadAllFilesDialogBodyNoSizeV2": "To bo uporabilo dodaten prostor v tem računalniku in vključuje tudi datoteke, ki so trenutno nastavljene na nastavitev »Sprosti prostor« ali samo v spletu. Datoteke se prenesejo, ko imate vzpostavljeno povezavo, nato pa jih lahko uporabljate brez povezave.",
  "kfmOptOutDialogHydratedKeepOnedriveOptionV2": "Ohrani datoteke le v storitvi OneDrive",
  "kfmOptOutDialogHydratedKeepThisPcOptionV2": "Ohrani datoteke le v tem računalniku",
  "kfmOptOutDialogHydratedContinueBackingOptionSubV2": "Datoteke bodo še naprej varnostno kopirane v OneDrive in bodo še naprej na voljo v tem računalniku.",
  "kfmOptOutDialogHydratedKeepThisPcOptionSubV2": "Datoteke ne bodo varnostno kopirane ali na voljo v drugih napravah.",
  "odignoreGpoInfoText": "Te nastavitve upravlja vaša organizacija.",
  "odignoreSectionTitleV2": "Izključi določene datoteke, mape ali pripone",
  "odignoreNewRuleInfoText": "Izključeni elementi ne bodo varnostno kopirani v OneDrive, vendar bodo elementi v oblaku še vedno sinhronizirani s tem računalnikom",
  "odignoreButtonText": "Izključi",
  "odignoreSectionTitle": "Izključene datotečne pripone",
  "odignoreOkButtonText": "V redu",
  "odignoreConfirmDeleteText": "Ali želite zagnati varnostno kopiranje?",
  "odignoreExtensionModalText": "Izključi določeno datotečno pripono",
  "odignoreAddRuleText": "Izključi",
  "odignoreModalBodyText": "Vnesite pripono, da preprečite varnostno kopiranje datotek v storitvi OneDrive.",
  "odignoreDeleteModalBodyText": "Storitev OneDrive bo začela varnostno kopirati to vsebino: {1}",
  "odignoreExtensionLabel": "Pripona",
  "odignoreInvalidRuleText": "Vnesite veljavno pravilo razširitve",
  "odignoreRemoveRuleLabel": "Odstrani pravilo",
  "odignoreRuleErrorInfoText": "Vnesite veljavno pravilo, kot je *.txt ali *.docx, če želite prezreti vse datoteke s to pripono.",
  "odignoreNewRuleSecondaryText": "Opomba: to pravilo ne bo veljalo za datoteke, ki so bile že varnostno kopirane v OneDrive.",
  "odignoreNewRuleExampleText": "primer: exe",
  "kfmOptOutErrorOkButtonV2": "V redu",
  "kfmOptoutHydratedDialogBodyParagraph": "Ta mapa varnostno kopira v OneDrive. Če ustavite varnostno kopiranje, morate izbra