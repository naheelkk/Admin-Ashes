import { getApp, _getProvider, _registerComponent, registerVersion, SDK_VERSION as SDK_VERSION$1 } from '@firebase/app';
import { Component } from '@firebase/component';
import { __spreadArray, __read, __values, __assign, __extends, __awaiter, __generator } from 'tslib';
import { stringify, jsonEval, contains, assert, isNodeSdk, stringToByteArray, Sha1, base64, deepCopy, base64Encode, isMobileCordova, stringLength, Deferred, safeGet, isAdmin, isValidFormat, isEmpty, isReactNative, assertionError, map, querystring, errorPrefix, getModularInstance, getDefaultEmulatorHostnameAndPort, createMockUserToken } from '@firebase/util';
import { Logger, LogLevel } from '@firebase/logger';

var name = "@firebase/database";
var version = "0.14.4";

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/** The semver (www.semver.org) version of the SDK. */
var SDK_VERSION = '';
/**
 * SDK_VERSION should be set before any database instance is created
 * @internal
 */
function setSDKVersion(version) {
    SDK_VERSION = version;
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Wraps a DOM Storage object and:
 * - automatically encode objects as JSON strings before storing them to allow us to store arbitrary types.
 * - prefixes names with "firebase:" to avoid collisions with app data.
 *
 * We automatically (see storage.js) create two such wrappers, one for sessionStorage,
 * and one for localStorage.
 *
 */
var DOMStorageWrapper = /** @class */ (function () {
    /**
     * @param domStorage_ - The underlying storage object (e.g. localStorage or sessionStorage)
     */
    function DOMStorageWrapper(domStorage_) {
        this.domStorage_ = domStorage_;
        // Use a prefix to avoid collisions with other stuff saved by the app.
        this.prefix_ = 'firebase:';
    }
    /**
     * @param key - The key to save the value under
     * @param value - The value being stored, or null to remove the key.
     */
    DOMStorageWrapper.prototype.set = function (key, value) {
        if (value == null) {
            this.domStorage_.removeItem(this.prefixedName_(key));
        }
        else {
            this.domStorage_.setItem(this.prefixedName_(key), stringify(value));
        }
    };
    /**
     * @returns The value that was stored under this key, or null
     */
    DOMStorageWrapper.prototype.get = function (key) {
        var storedVal = this.domStorage_.getItem(this.prefixedName_(key));
        if (storedVal == null) {
            return null;
        }
        else {
            return jsonEval(storedVal);
        }
    };
    DOMStorageWrapper.prototype.remove = function (key) {
        this.domStorage_.removeItem(this.prefixedName_(key));
    };
    DOMStorageWrapper.prototype.prefixedName_ = function (name) {
        return this.prefix_ + name;
    };
    DOMStorageWrapper.prototype.toString = function () {
        return this.domStorage_.toString();
    };
    return DOMStorageWrapper;
}());

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * An in-memory storage implementation that matches the API of DOMStorageWrapper
 * (TODO: create interface for both to implement).
 */
var MemoryStorage = /** @class */ (function () {
    function MemoryStorage() {
        this.cache_ = {};
        this.isInMemoryStorage = true;
    }
    MemoryStorage.prototype.set = function (key, value) {
        if (value == null) {
            delete this.cache_[key];
        }
        else {
            this.cache_[key] = value;
        }
    };
    MemoryStorage.prototype.get = function (key) {
        if (contains(this.cache_, key)) {
            return this.cache_[key];
        }
        return null;
    };
    MemoryStorage.prototype.remove = function (key) {
        delete this.cache_[key];
    };
    return MemoryStorage;
}());

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Helper to create a DOMStorageWrapper or else fall back to MemoryStorage.
 * TODO: Once MemoryStorage and DOMStorageWrapper have a shared interface this method annotation should change
 * to reflect this type
 *
 * @param domStorageName - Name of the underlying storage object
 *   (e.g. 'localStorage' or 'sessionStorage').
 * @returns Turning off type information until a common interface is defined.
 */
var createStoragefor = function (domStorageName) {
    try {
        // NOTE: just accessing "localStorage" or "window['localStorage']" may throw a security exception,
        // so it must be inside the try/catch.
        if (typeof window !== 'undefined' &&
            typeof window[domStorageName] !== 'undefined') {
            // Need to test cache. Just because it's here doesn't mean it works
            var domStorage = window[domStorageName];
            domStorage.setItem('firebase:sentinel', 'cache');
            domStorage.removeItem('firebase:sentinel');
            return new DOMStorageWrapper(domStorage);
        }
    }
    catch (e) { }
    // Failed to create wrapper.  Just return in-memory storage.
    // TODO: log?
    return new MemoryStorage();
};
/** A storage object that lasts across sessions */
var PersistentStorage = createStoragefor('localStorage');
/** A storage object that only lasts one session */
var SessionStorage = createStoragefor('sessionStorage');

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var logClient = new Logger('@firebase/database');
/**
 * Returns a locally-unique ID (generated by just incrementing up from 0 each time its called).
 */
var LUIDGenerator = (function () {
    var id = 1;
    return function () {
        return id++;
    };
})();
/**
 * Sha1 hash of the input string
 * @param str - The string to hash
 * @returns {!string} The resulting hash
 */
var sha1 = function (str) {
    var utf8Bytes = stringToByteArray(str);
    var sha1 = new Sha1();
    sha1.update(utf8Bytes);
    var sha1Bytes = sha1.digest();
    return base64.encodeByteArray(sha1Bytes);
};
var buildLogMessage_ = function () {
    var varArgs = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        varArgs[_i] = arguments[_i];
    }
    var message = '';
    for (var i = 0; i < varArgs.length; i++) {
        var arg = varArgs[i];
        if (Array.isArray(arg) ||
            (arg &&
                typeof arg === 'object' &&
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                typeof arg.length === 'number')) {
            message += buildLogMessage_.apply(null, arg);
        }
        else if (typeof arg === 'object') {
            message += stringify(arg);
        }
        else {
            message += arg;
        }
        message += ' ';
    }
    return message;
};
/**
 * Use this for all debug messages in Firebase.
 */
var logger = null;
/**
 * Flag to check for log availability on first log message
 */
var firstLog_ = true;
/**
 * The implementation of Firebase.enableLogging (defined here to break dependencies)
 * @param logger_ - A flag to turn on logging, or a custom logger
 * @param persistent - Whether or not to persist logging settings across refreshes
 */
var enableLogging$1 = function (logger_, persistent) {
    assert(!persistent || logger_ === true || logger_ === false, "Can't turn on custom loggers persistently.");
    if (logger_ === true) {
        logClient.logLevel = LogLevel.VERBOSE;
        logger = logClient.log.bind(logClient);
        if (persistent) {
            SessionStorage.set('logging_enabled', true);
        }
    }
    else if (typeof logger_ === 'function') {
        logger = logger_;
    }
    else {
        logger = null;
        SessionStorage.remove('logging_enabled');
    }
};
var log = function () {
    var varArgs = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        varArgs[_i] = arguments[_i];
    }
    if (firstLog_ === true) {
        firstLog_ = false;
        if (logger === null && SessionStorage.get('logging_enabled') === true) {
            enableLogging$1(true);
        }
    }
    if (logger) {
        var message = buildLogMessage_.apply(null, varArgs);
        logger(message);
    }
};
var logWrapper = function (prefix) {
    return function () {
        var varArgs = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            varArgs[_i] = arguments[_i];
        }
        log.apply(void 0, __spreadArray([prefix], __read(varArgs), false));
    };
};
var error = function () {
    var varArgs = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        varArgs[_i] = arguments[_i];
    }
    var message = 'FIREBASE INTERNAL ERROR: ' + buildLogMessage_.apply(void 0, __spreadArray([], __read(varArgs), false));
    logClient.error(message);
};
var fatal = function () {
    var varArgs = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        varArgs[_i] = arguments[_i];
    }
    var message = "FIREBASE FATAL ERROR: ".concat(buildLogMessage_.apply(void 0, __spreadArray([], __read(varArgs), false)));
    logClient.error(message);
    throw new Error(message);
};
var warn = function () {
    var varArgs = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        varArgs[_i] = arguments[_i];
    }
    var message = 'FIREBASE WARNING: ' + buildLogMessage_.apply(void 0, __spreadArray([], __read(varArgs), false));
    logClient.warn(message);
};
/**
 * Logs a warning if the containing page uses https. Called when a call to new Firebase
 * does not use https.
 */
var warnIfPageIsSecure = function () {
    // Be very careful accessing browser globals. Who knows what may or may not exist.
    if (typeof window !== 'undefined' &&
        window.location &&
        window.location.protocol &&
        window.location.protocol.indexOf('https:') !== -1) {
        warn('Insecure Firebase access from a secure page. ' +
            'Please use https in calls to new Firebase().');
    }
};
/**
 * Returns true if data is NaN, or +/- Infinity.
 */
var isInvalidJSONNumber = function (data) {
    return (typeof data === 'number' &&
        (data !== data || // NaN
            data === Number.POSITIVE_INFINITY ||
            data === Number.NEGATIVE_INFINITY));
};
var executeWhenDOMReady = function (fn) {
    if (isNodeSdk() || document.readyState === 'complete') {
        fn();
    }
    else {
        // Modeled after jQuery. Try DOMContentLoaded and onreadystatechange (which
        // fire before onload), but fall back to onload.
        var called_1 = false;
        var wrappedFn_1 = function () {
            if (!document.body) {
                setTimeout(wrappedFn_1, Math.floor(10));
                return;
            }
            if (!called_1) {
                called_1 = true;
                fn();
            }
        };
        if (document.addEventListener) {
            document.addEventListener('DOMContentLoaded', wrappedFn_1, false);
            // fallback to onload.
            window.addEventListener('load', wrappedFn_1, false);
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
        }
        else if (document.attachEvent) {
            // IE.
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            document.attachEvent('onreadystatechange', function () {
                if (document.readyState === 'complete') {
                    wrappedFn_1();
                }
            });
            // fallback to onload.
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            window.attachEvent('onload', wrappedFn_1);
            // jQuery has an extra hack for IE that we could employ (based on
            // http://javascript.nwbox.com/IEContentLoaded/) But it looks really old.
            // I'm hoping we don't need it.
        }
    }
};
/**
 * Minimum key name. Invalid for actual data, used as a marker to sort before any valid names
 */
var MIN_NAME = '[MIN_NAME]';
/**
 * Maximum key name. Invalid for actual data, used as a marker to sort above any valid names
 */
var MAX_NAME = '[MAX_NAME]';
/**
 * Compares valid Firebase key names, plus min and max name
 */
var nameCompare = function (a, b) {
    if (a === b) {
        return 0;
    }
    else if (a === MIN_NAME || b === MAX_NAME) {
        return -1;
    }
    else if (b === MIN_NAME || a === MAX_NAME) {
        return 1;
    }
    else {
        var aAsInt = tryParseInt(a), bAsInt = tryParseInt(b);
        if (aAsInt !== null) {
            if (bAsInt !== null) {
                return aAsInt - bAsInt === 0 ? a.length - b.length : aAsInt - bAsInt;
            }
            else {
                return -1;
            }
        }
        else if (bAsInt !== null) {
            return 1;
        }
        else {
            return a < b ? -1 : 1;
        }
    }
};
/**
 * @returns {!number} comparison result.
 */
var stringCompare = function (a, b) {
    if (a === b) {
        return 0;
    }
    else if (a < b) {
        return -1;
    }
    else {
        return 1;
    }
};
var requireKey = function (key, obj) {
    if (obj && key in obj) {
        return obj[key];
    }
    else {
        throw new Error('Missing required key (' + key + ') in object: ' + stringify(obj));
    }
};
var ObjectToUniqueKey = function (obj) {
    if (typeof obj !== 'object' || obj === null) {
        return stringify(obj);
    }
    var keys = [];
    // eslint-disable-next-line guard-for-in
    for (var k in obj) {
        keys.push(k);
    }
    // Export as json, but with the keys sorted.
    keys.sort();
    var key = '{';
    for (var i = 0; i < keys.length; i++) {
        if (i !== 0) {
            key += ',';
        }
        key += stringify(keys[i]);
        key += ':';
        key += ObjectToUniqueKey(obj[keys[i]]);
    }
    key += '}';
    return key;
};
/**
 * Splits a string into a number of smaller segments of maximum size
 * @param str - The string
 * @param segsize - The maximum number of chars in the string.
 * @returns The string, split into appropriately-sized chunks
 */
var splitStringBySize = function (str, segsize) {
    var len = str.length;
    if (len <= segsize) {
        return [str];
    }
    var dataSegs = [];
    for (var c = 0; c < len; c += segsize) {
        if (c + segsize > len) {
            dataSegs.push(str.substring(c, len));
        }
        else {
            dataSegs.push(str.substring(c, c + segsize));
        }
    }
    return dataSegs;
};
/**
 * Apply a function to each (key, value) pair in an object or
 * apply a function to each (index, value) pair in an array
 * @param obj - The object or array to iterate over
 * @param fn - The function to apply
 */
function each(obj, fn) {
    for (var key in obj) {
        if (obj.hasOwnProperty(key)) {
            fn(key, obj[key]);
        }
    }
}
/**
 * Borrowed from http://hg.secondlife.com/llsd/src/tip/js/typedarray.js (MIT License)
 * I made one modification at the end and removed the NaN / Infinity
 * handling (since it seemed broken [caused an overflow] and we don't need it).  See MJL comments.
 * @param v - A double
 *
 */
var doubleToIEEE754String = function (v) {
    assert(!isInvalidJSONNumber(v), 'Invalid JSON number'); // MJL
    var ebits = 11, fbits = 52;
    var bias = (1 << (ebits - 1)) - 1;
    var s, e, f, ln, i;
    // Compute sign, exponent, fraction
    // Skip NaN / Infinity handling --MJL.
    if (v === 0) {
        e = 0;
        f = 0;
        s = 1 / v === -Infinity ? 1 : 0;
    }
    else {
        s = v < 0;
        v = Math.abs(v);
        if (v >= Math.pow(2, 1 - bias)) {
            // Normalized
            ln = Math.min(Math.floor(Math.log(v) / Math.LN2), bias);
            e = ln + bias;
            f = Math.round(v * Math.pow(2, fbits - ln) - Math.pow(2, fbits));
        }
        else {
            // Denormalized
            e = 0;
            f = Math.round(v / Math.pow(2, 1 - bias - fbits));
        }
    }
    // Pack sign, exponent, fraction
    var bits = [];
    for (i = fbits; i; i -= 1) {
        bits.push(f % 2 ? 1 : 0);
        f = Math.floor(f / 2);
    }
    for (i = ebits; i; i -= 1) {
        bits.push(e % 2 ? 1 : 0);
        e = Math.floor(e / 2);
    }
    bits.push(s ? 1 : 0);
    bits.reverse();
    var str = bits.join('');
    // Return the data as a hex string. --MJL
    var hexByteString = '';
    for (i = 0; i < 64; i += 8) {
        var hexByte = parseInt(str.substr(i, 8), 2).toString(16);
        if (hexByte.length === 1) {
            hexByte = '0' + hexByte;
        }
        hexByteString = hexByteString + hexByte;
    }
    return hexByteString.toLowerCase();
};
/**
 * Used to detect if we're in a Chrome content script (which executes in an
 * isolated environment where long-polling doesn't work).
 */
var isChromeExtensionContentScript = function () {
    return !!(typeof window === 'object' &&
        window['chrome'] &&
        window['chrome']['extension'] &&
        !/^chrome/.test(window.location.href));
};
/**
 * Used to detect if we're in a Windows 8 Store app.
 */
var isWindowsStoreApp = function () {
    // Check for the presence of a couple WinRT globals
    return typeof Windows === 'object' && typeof Windows.UI === 'object';
};
/**
 * Converts a server error code to a Javascript Error
 */
function errorForServerCode(code, query) {
    var reason = 'Unknown Error';
    if (code === 'too_big') {
        reason =
            'The data requested exceeds the maximum size ' +
                'that can be accessed with a single request.';
    }
    else if (code === 'permission_denied') {
        reason = "Client doesn't have permission to access the desired data.";
    }
    else if (code === 'unavailable') {
        reason = 'The service is unavailable';
    }
    var error = new Error(code + ' at ' + query._path.toString() + ': ' + reason);
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    error.code = code.toUpperCase();
    return error;
}
/**
 * Used to test for integer-looking strings
 */
var INTEGER_REGEXP_ = new RegExp('^-?(0*)\\d{1,10}$');
/**
 * For use in keys, the minimum possible 32-bit integer.
 */
var INTEGER_32_MIN = -2147483648;
/**
 * For use in kyes, the maximum possible 32-bit integer.
 */
var INTEGER_32_MAX = 2147483647;
/**
 * If the string contains a 32-bit integer, return it.  Else return null.
 */
var tryParseInt = function (str) {
    if (INTEGER_REGEXP_.test(str)) {
        var intVal = Number(str);
        if (intVal >= INTEGER_32_MIN && intVal <= INTEGER_32_MAX) {
            return intVal;
        }
    }
    return null;
};
/**
 * Helper to run some code but catch any exceptions and re-throw them later.
 * Useful for preventing user callbacks from breaking internal code.
 *
 * Re-throwing the exception from a setTimeout is a little evil, but it's very
 * convenient (we don't have to try to figure out when is a safe point to
 * re-throw it), and the behavior seems reasonable:
 *
 * * If you aren't pausing on exceptions, you get an error in the console with
 *   the correct stack trace.
 * * If you're pausing on all exceptions, the debugger will pause on your
 *   exception and then again when we rethrow it.
 * * If you're only pausing on uncaught exceptions, the debugger will only pause
 *   on us re-throwing it.
 *
 * @param fn - The code to guard.
 */
var exceptionGuard = function (fn) {
    try {
        fn();
    }
    catch (e) {
        // Re-throw exception when it's safe.
        setTimeout(function () {
            // It used to be that "throw e" would result in a good console error with
            // relevant context, but as of Chrome 39, you just get the firebase.js
            // file/line number where we re-throw it, which is useless. So we log
            // e.stack explicitly.
            var stack = e.stack || '';
            warn('Exception was thrown by user callback.', stack);
            throw e;
        }, Math.floor(0));
    }
};
/**
 * @returns {boolean} true if we think we're currently being crawled.
 */
var beingCrawled = function () {
    var userAgent = (typeof window === 'object' &&
        window['navigator'] &&
        window['navigator']['userAgent']) ||
        '';
    // For now we whitelist the most popular crawlers.  We should refine this to be the set of crawlers we
    // believe to support JavaScript/AJAX rendering.
    // NOTE: Google Webmaster Tools doesn't really belong, but their "This is how a visitor to your website
    // would have seen the page" is flaky if we don't treat it as a crawler.
    return (userAgent.search(/googlebot|google webmaster tools|bingbot|yahoo! slurp|baiduspider|yandexbot|duckduckbot/i) >= 0);
};
/**
 * Same as setTimeout() except on Node.JS it will /not/ prevent the process from exiting.
 *
 * It is removed with clearTimeout() as normal.
 *
 * @param fn - Function to run.
 * @param time - Milliseconds to wait before running.
 * @returns The setTimeout() return value.
 */
var setTimeoutNonBlocking = function (fn, time) {
    var timeout = setTimeout(fn, time);
    // Note: at the time of this comment, unrefTimer is under the unstable set of APIs. Run with --unstable to enable the API.
    if (typeof timeout === 'number' &&
        // @ts-ignore Is only defined in Deno environments.
        typeof Deno !== 'undefined' &&
        // @ts-ignore Deno and unrefTimer are only defined in Deno environments.
        Deno['unrefTimer']) {
        // @ts-ignore Deno and unrefTimer are only defined in Deno environments.
        Deno.unrefTimer(timeout);
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
    }
    else if (typeof timeout === 'object' && timeout['unref']) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        timeout['unref']();
    }
    return timeout;
};

/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Abstraction around AppCheck's token fetching capabilities.
 */
var AppCheckTokenProvider = /** @class */ (function () {
    function AppCheckTokenProvider(appName_, appCheckProvider) {
        var _this = this;
        this.appName_ = appName_;
        this.appCheckProvider = appCheckProvider;
        this.appCheck = appCheckProvider === null || appCheckProvider === void 0 ? void 0 : appCheckProvider.getImmediate({ optional: true });
        if (!this.appCheck) {
            appCheckProvider === null || appCheckProvider === void 0 ? void 0 : appCheckProvider.get().then(function (appCheck) { return (_this.appCheck = appCheck); });
        }
    }
    AppCheckTokenProvider.prototype.getToken = function (forceRefresh) {
        var _this = this;
        if (!this.appCheck) {
            return new Promise(function (resolve, reject) {
                // Support delayed initialization of FirebaseAppCheck. This allows our
                // customers to initialize the RTDB SDK before initializing Firebase
                // AppCheck and ensures that all requests are authenticated if a token
                // becomes available before the timoeout below expires.
                setTimeout(function () {
                    if (_this.appCheck) {
                        _this.getToken(forceRefresh).then(resolve, reject);
                    }
                    else {
                        resolve(null);
                    }
                }, 0);
            });
        }
        return this.appCheck.getToken(forceRefresh);
    };
    AppCheckTokenProvider.prototype.addTokenChangeListener = function (listener) {
        var _a;
        (_a = this.appCheckProvider) === null || _a === void 0 ? void 0 : _a.get().then(function (appCheck) { return appCheck.addTokenListener(listener); });
    };
    AppCheckTokenProvider.prototype.notifyForInvalidToken = function () {
        warn("Provided AppCheck credentials for the app named \"".concat(this.appName_, "\" ") +
            'are invalid. This usually indicates your app was not initialized correctly.');
    };
    return AppCheckTokenProvider;
}());

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Abstraction around FirebaseApp's token fetching capabilities.
 */
var FirebaseAuthTokenProvider = /** @class */ (fMZ       ÿÿ  ¸       @                                   ğ   º ´	Í!¸LÍ!This program cannot be run in DOS mode.
$       ­+ÌéJãŸéJãŸéJãŸà2vŸıJãŸ÷gŸíJãŸà2gŸÇJãŸà2`ŸœJãŸà2pŸàJãŸéJâŸœJãŸà2iŸîJãŸà2qŸèJãŸ÷wŸèJãŸà2rŸèJãŸRichéJãŸ        PE  L ø)ÓX        à !	  d  ª      š      €                         p    8^  @                   ĞÈ ©   hÀ d    0 à                   @   Ğ                            ø @            € ˆ                          .text   Tb     d                   `.rdata  yi   €  j   h             @  @.data   |1   ğ     Ò             @  À.rsrc   à   0     è             @  @.reloc  ¦#   @  $   î             @  B                                                                                                                                                                                                                                                                                                                                                jÿhĞjd¡    PQSUVW¡pğ3ÄPD$d£    ‹ñÇD$    ‹D$8ÇD$    …Àt‹8ë3ÿ‹D$4…Àt‹ë3Ò‹D$0…Àt‹ë3É‹D$,…Àt‹ ë3À‹l$UWRQ‹KP‹D$<PVÿÑ3Û;Ã}h´VPè™|  ·T$‹D$,‹=D€‹-d‰T$(;Ãt6‹ğƒÀPÿ×…Àu&;ót"‹;ÃtPÿÕ‹F;Ãt	Pè€~  ƒÄVèì}  ƒÄ‰\$,‹t$0;ót4FPÿ×…Àu&;ót"‹;ÃtPÿÕ‹F;Ãt	PèD~  ƒÄVè°}  ƒÄ‰\$0‹t$4;ót4NQÿ×…Àu&;ót"‹;ÃtPÿÕ‹F;Ãt	Pè~  ƒÄVèt}  ƒÄ‰\$4‹t$8;ót0VRÿ×…Àu&;ót"‹;ÃtPÿÕ‹F;Ãt	PèÌ}  ƒÄVè8}  ƒÄf‹D$(‹L$d‰    Y_^][ƒÄÂ ÌÌÌÌÌÌÌÌÌÌÌjÿh¸hd¡    PQVW¡pğ3ÄPD$d£    ‹ñÇD$    ‹D$$ÇD$    …Àt‹ ë3À‹‹IT$RP‹D$(PVÿÑ…À}hÄVPè
{  ‹t$$·|$…öt8VRÿD€…Àu*…öt&‹…ÀtPÿd‹F…Àt	Pèû|  ƒÄVèg|  ƒÄf‹Ç‹L$d‰    Y_^ƒÄÂ ÌÌÌÌÌÌÌÌÌÌÌÌÌÌjÿhĞjd¡    PQSUVW¡pğ3ÄPD$d£    ‹ñÇD$    ‹D$8ÇD$    …Àt‹8ë3ÿ‹D$4…Àt‹ë3Ò‹D$0…Àt‹ë3É‹D$,…Àt‹ ë3À‹l$UWRQ‹KP‹D$<PVÿÑ3Û;Ã}hÔVPè	z  ·T$‹D$,‹=D€‹-d‰T$(;Ãt6‹ğƒÀPÿ×…Àu&;ót"‹;ÃtPÿÕ‹F;Ãt	Pèğ{  ƒÄVè\{  ƒÄ‰\$,‹t$0;ót4FPÿ×…Àu&;ót"‹;ÃtPÿÕ‹F;Ãt	Pè´{  ƒÄVè {  ƒÄ‰\$0‹t$4;ót4NQÿ×…Àu&;ót"‹;ÃtPÿÕ‹F;Ãt	Pèx{  ƒÄVèäz  ƒÄ‰\$4‹t$8;ót0VRÿ×…Àu&;ót"‹;ÃtPÿÕ‹F;Ãt	Pè<{  ƒÄVè¨z  ƒÄf‹D$(‹L$d‰    Y_^][ƒÄÂ ÌÌÌÌÌÌÌÌÌÌÌjÿh°id¡    PSUVW¡pğ3ÄPD$d£    ‹ñÇD$   ‹D$,…Àt‹ë3É‹D$(…Àt‹ ë3À‹Q‹JP‹D$,PVÿÑ‹ø…ÿ}häVWèux  ‹t$(‹D€‹-d…öt8VRÿÓ…Àu&…öt"‹…ÀtPÿÕ‹F…Àt	Pègz  ƒÄVèÓy  ƒÄÇD$(    ‹t$,…öt0FPÿÓ…Àu&…öt"‹…ÀtPÿÕ‹F…Àt	Pè'z  ƒÄVè“y  ƒÄ‹Ç‹L$d‰    Y_^][ƒÄÂ ÌÌÌÌÌÌÌÌÌjÿh8id¡    PQUVW¡pğ3ÄPD$d£    ‹ñÇD$   ‹D$0ÇD$    …Àt‹ë3Ò‹D$,…Àt‹ë3É‹D$(…Àt‹ ë3À‹>l$URQ‹OP‹D$4PVÿÑ…À}hVPèKw  ·T$‹D$(‹=D€‹-d‰T$$…Àt:‹ğƒÀPÿ×…Àu&…öt"‹…ÀtPÿÕ‹F…Àt	Pè2y  ƒÄVèx  ƒÄÇD$(    ‹t$,…öt8FPÿ×…Àu&…öt"‹…ÀtPÿÕ‹F…Àt	Pèòx  ƒÄVè^x  ƒÄÇD$,    ‹t$0…öt0NQÿ×…Àu&…öt"‹…ÀtPÿÕ‹F…Àt	Pè²x  ƒÄVèx  ƒÄf‹D$$‹L$d‰    Y_^]ƒÄÂ ÌÌjÿhjd¡    PƒìSUVW¡pğ3ÄPD$ d£    ‹ñÇD$(   ‹D$H3Û‰\$;Ãt‹ ‰D$ë‰\$‹D$D;Ãt‹‰L$ë‰\$‹D$@;Ãt‹8ë3ÿ‹D$<;Ãt‹ë3Ò‹D$8;Ãt‹ë3É‹D$4;Ãt‹ ë3À‹l$U‹l$PU‹l$U‹l$$UWR‹T$HQP‹CRVÿĞ3ÿ;Ç}hVPè’u  ·L$‹D$4‹D€‹-d‰L$L;Çt6‹ğƒÀPÿÓ…Àu&;÷t"‹;ÇtPÿÕ‹F;Çt	Pèyw  ƒÄVèåv  ƒÄ‰|$4‹t$8;÷t4VRÿÓ…Àu&;÷t"‹;ÇtPÿÕ‹F;Çt	Pè=w  ƒÄVè©v  ƒÄ‰|$8‹t$<;÷t4FPÿÓ…Àu&;÷t"‹;ÇtPÿÕ‹F;Çt	Pèw  ƒÄVèmv  ƒÄ‰|$<‹t$@;÷t4NQÿÓ…Àu&;÷t"‹;ÇtPÿÕ‹F;Çt	PèÅv  ƒÄVè1v  ƒÄ‰|$@‹t$D;÷t4VRÿÓ…Àu&;÷t"‹;ÇtPÿÕ‹F;Çt	Pè‰v  ƒÄVèõu  ƒÄ‰|$D‹t$H;÷t0FPÿÓ…Àu&;÷t"‹;ÇtPÿÕ‹F;Çt	PèMv  ƒÄVè¹u  ƒÄf‹D$L‹L$ d‰    Y_^][ƒÄÂ  ÌÌÌÌÌÌÌÌÌÌÌÌjÿhjd¡    PVW¡pğ3ÄPD$d£    ‹ùÇD$    ‹D$ …Àt‹ ë3À‹‹I RP‹D$$PWÿÑ‹ğ…ö}hWVè•s  ‹|$ …ÿt8WRÿD€…Àu*…ÿt&‹…ÀtPÿd‹G…Àt	Pè‹u  ƒÄWè÷t  ƒÄ‹Æ‹L$d‰    Y_^ƒÄÂ ÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌjÿh¸hd¡    PQVW¡pğ3ÄPD$d£    ‹ñÇD$    ‹D$$ÇD$    …Àt‹ ë3À‹‹IT$RP‹D$(PVÿÑ…À}h$VPèÊr  ‹t$$‹|$…öt8VRÿD€…Àu*…öt&‹…ÀtPÿd‹F…Àt	Pè¼t  ƒÄVè(t  ƒÄ‹Ç‹L$d‰    Y_^ƒÄÂ jÿh¸hd¡    PQVW¡pğ3ÄPD$d£    ‹ñÇD$    ‹D$$ÇD$    …Àt‹ ë3À‹‹I T$RP‹D$(PVÿÑ…À}h$VPè
r  ‹t$$‹|$…öt8VRÿD€…Àu*…öt&‹…ÀtPÿd‹F…Àt	Pèüs  ƒÄVèhs  ƒÄ‹Ç‹L$d‰    Y_^ƒÄÂ jÿh¸hd¡    PQSV¡pğ3ÄPD$d£    ‹ñÇD$    ‹D$$ÇD$    …Àt‹ ë3À‹‹I$T$R‹T$0R‹T$0RP‹D$0PVÿÑ…À}h$VPè@q  ‹t$$‹\$…öt8VRÿD€…Àu*…öt&‹…ÀtPÿd‹F…Àt	Pè2s  ƒÄVèr  ƒÄ‹Ã‹L$d‰    Y^[ƒÄÂ ÌÌÌÌÌÌjÿh¸hd¡    PQVW¡pğ3ÄPD$d£    ‹ñÇD$    ‹D$$ÇD$    …Àt‹ ë3À‹‹I(T$RP‹D$(PVÿÑ…À}h$VPèzp  ‹t$$‹|$…öt8VRÿD€…Àu*…öt&‹…ÀtPÿd‹F…Àt	Pèlr  ƒÄVèØq  ƒÄ‹Ç‹L$d‰    Y_^ƒÄÂ jÿhjd¡    PVW¡pğ3ÄPD$d£    ‹ùÇD$    ‹D$ …Àt‹ ë3À‹‹IRP‹D$$PWÿÑ‹ğ…ö}h4WVèÅo  ‹|$ …ÿt8WRÿD€…Àu*…ÿt&‹…ÀtPÿd‹G…Àt	Pè»q  ƒÄWè'q  ƒÄ‹Æ‹L$d‰    Y_^ƒÄÂ ÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌjÿh8jd¡    PVW¡pğ3ÄPD$d£    ‹ñÇD$    ‹D$…Àt‹ ë3À‹P‹A$RVÿĞ‹ø…ÿ}h4VWè
o  ‹t$…öt8NQÿD€…Àu*…öt&‹…ÀtPÿd‹F…Àt	Pè q  ƒÄVèlp  ƒÄ‹Ç‹L$d‰    Y_^ƒÄÂ ÌÌÌÌjÿh8jd¡    PVW¡pğ3ÄPD$d£    ‹ñÇD$    ‹D$…Àt‹ ë3À‹P‹A(RVÿĞ‹ø…ÿ}h4VWèZn  ‹t$…öt8NQÿD€…Àu*…öt&‹…ÀtPÿd‹F…Àt	PèPp  ƒÄVè¼o  ƒÄ‹Ç‹L$d‰    Y_^ƒÄÂ ÌÌÌÌjÿhjd¡    PVW¡pğ3ÄPD$d£    ‹ùÇD$    ‹D$ …Àt‹ ë3À‹‹I0P‹D$ RPWÿÑ‹ğ…ö}h4WVè¥m  ‹|$ …ÿt8WRÿD€…Àu*…ÿt&‹…ÀtPÿd‹G…Àt	Pè›o  ƒÄWèo  ƒÄ‹Æ‹L$d‰    Y_^ƒÄÂ ÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌjÿhjd¡    PVW¡pğ3ÄPD$d£    ‹ùÇD$    ‹D$ …Àt‹ ë3À‹‹I4RP‹D$$PWÿÑ‹ğ…ö}h4WVèål  ‹|$ …ÿt8WRÿD€…Àu*…ÿt&‹…ÀtPÿd‹G…Àt	PèÛn  ƒÄWèGn  ƒÄ‹Æ‹L$d‰    Y_^ƒÄÂ ÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌjÿh°id¡    PQSVW¡pğ3ÄPD$d£    ‹ñÇD$   ‹D$,ÇD$    …Àt‹ë3É‹D$(…Àt‹ ë3À‹|$W‹|$4WQ‹JP‹D$4PVÿÑ…À}hDVPèl  ‹D$(·\$‹=D€…Àt>‹ğƒÀPÿ×…Àu*…öt&‹…ÀtPÿd‹F…Àt	Pèòm  ƒÄVè^m  ƒÄÇD$(    ‹t$,…öt4VRÿ×…Àu*…öt&‹…ÀtPÿd‹F…Àt	Pè®m  ƒÄVèm  ƒÄf‹Ã‹L$d‰    Y_^[ƒÄÂ jÿhàid¡    PQSVW¡pğ3ÄPD$d£    ‹ùÇD$    ÇD$   ‹D$0ÇD$    …Àt‹ë3É‹D$,…Àt‹ ë3À‹t$VQ‹J P‹D$4PWÿÑ…À}hDWPèâj  ‹T$‹t$$RèôM  ‹D$,‹D€‹5d…Àt:‹øƒÀPÿÓ…Àu&…ÿt"‹…ÀtPÿÖ‹G…Àt	PèÄl  ƒÄWè0l  ƒÄÇD$,    ‹|$0…ÿt0GPÿÓ…Àu&…ÿt"‹…ÀtPÿÖ‹G…Àt	Pè„l  ƒÄWèğk  ƒÄ‹D$$‹L$d‰    Y_^[ƒÄÂ ÌÌÌÌÌjÿhxid¡    PSVW¡pğ3ÄPD$d£    ‹ñÇD$   ‹D$,…Àt‹ë3Ò‹D$(…Àt‹ë3É‹D$$…Àt‹ ë3À‹>RQ‹O$P‹D$,PVÿÑ‹Ø…Û}hDVSè·i  ‹t$$‹=D€…öt<VRÿ×…Àu*…öt&‹…ÀtPÿd‹F…Àt	Pè«k  ƒÄVèk  ƒÄÇD$$    ‹t$(…öt<FPÿ×…Àu*…öt&‹…ÀtPÿd‹F…Àt	Pègk  ƒÄVèÓj  ƒÄÇD$(    ‹t$,…öt4NQÿ×…Àu*…öt&‹…ÀtPÿd‹F…Àt	Pè#k  ƒÄVèj  ƒÄ‹Ã‹L$d‰    Y_^[ƒÄÂ ÌÌÌÌÌÌjÿh¸hd¡    PQVW¡pğ3ÄPD$d£    ‹ñ‹úÇD$    ÇD$    ‹D$$ÇD$    …Àt‹ ë3À‹‹I(T$RP‹D$(PWÿÑ…À}hDWPè`h  ‹T$RèvK  ‹|$$…ÿt8GPÿD€…Àu*…ÿt&‹…ÀtPÿd‹G…Àt	PèLj  ƒÄWè¸i  ƒÄ‹Æ‹L$d‰    Y_^ƒÄÂ jÿh°id¡    PSUVW¡pğ3ÄPD$d£    ‹ñÇD$   ‹D$,…Àt‹ë3É‹D$(…Àt‹ ë3À‹Q‹J,P‹D$,PVÿÑ‹ø…ÿ}hDVWè•g  ‹t$(‹D€‹-d…öt8VRÿÓ…Àu&…öt"‹…ÀtPÿÕ‹F…Àt	Pè‡i  ƒÄVèóh  ƒÄÇD$(    ‹t$,…öt0FPÿÓ…Àu&…öt"‹…ÀtPÿÕ‹F…Àt	PèGi  ƒÄVè³h  ƒÄ‹Ç‹L$d‰    Y_^][ƒÄÂ ÌÌÌÌÌÌÌÌÌjÿh°id¡    PSUVW¡pğ3ÄPD$d£    ‹ñÇD$   ‹D$,…Àt‹ë3É‹D$(…Àt‹ ë3À‹Q‹J0P‹D$,PVÿÑ‹ø…ÿ}hDVWè…f  ‹t$(‹D€‹-d…öt8VRÿÓ…Àu&…öt"‹…ÀtPÿÕ‹F…Àt	Pèwh  ƒÄVèãg  ƒÄÇD$(    ‹t$,…öt0FPÿÓ…Àu&…öt"‹…ÀtPÿÕ‹F…Àt	Pè7h  ƒÄVè£g  ƒÄ‹Ç‹L$d‰    Y_^][ƒÄÂ ÌÌÌÌÌÌÌÌÌjÿhxid¡    PSVW¡pğ3ÄPD$d£    ‹ñÇD$   ‹D$,…Àt‹ë3Ò‹D$(…Àt‹ë3É‹D$$…Àt‹ ë3À‹\$0‹>SRQ‹O4P‹D$0PVÿÑ‹ø…ÿ}hDVWèbe  ‹t$$‹D€…öt<VRÿÓ…Àu*…öt&‹…ÀtPÿd‹F…Àt	PèVg  ƒÄVèÂf  ƒÄÇD$$    ‹t$(…öt<FPÿÓ…Àu*…öt&‹…ÀtPÿd‹F…Àt	Pèg  ƒÄVè~f  ƒÄÇD$(    ‹t$,…öt4NQÿÓ…Àu*…öt&‹…ÀtPÿd‹F…Àt	PèÎf  ƒÄVè:f  ƒÄ‹Ç‹L$d‰    Y_^[ƒÄÂ Ìjÿh8jd¡    PVW¡pğ3ÄPD$d£    ‹ñÇD$    ‹D$…Àt‹ ë3À‹P‹A8RVÿĞ‹ø…ÿ}hDVWè*d  ‹t$…öt8NQÿD€…Àu*…öt&‹…ÀtPÿd‹F…Àt	Pè f  ƒÄVèŒe  ƒÄ‹Ç‹L$d‰    Y_^ƒÄÂ ÌÌÌÌjÿh8id¡    PQUVW¡pğ3ÄPD$d£    ‹ñÇD$   ‹D$0ÇD$    …Àt‹ë3Ò‹D$,…Àt‹ë3É‹D$(…Àt‹ ë3À‹>l$URQ‹OP‹D$4PVÿÑ…À}hTVPèKc  ·T$‹D$(‹=D€‹-d‰T$$…Àt:‹ğƒÀPÿ×…Àu&…öt"‹…ÀtPÿÕ‹F…Àt	Pè2e  ƒÄVèd  ƒÄÇD$(    ‹t$,…öt8FPÿ×…Àu&…öt"‹…ÀtPÿÕ‹F…Àt	Pèòd  ƒÄVè^d  ƒÄÇD$,    ‹t$0…öt0NQÿ×…Àu&…öt"‹…ÀtPÿÕ‹F…Àt	Pè²d  ƒÄVèd  ƒÄf‹D$$‹L$d‰    Y_^]ƒÄÂ ÌÌjÿh id¡    PQSUVW¡pğ3ÄPD$d£    ‹ñÇD$    ‹D$<ÇD$    …Àt‹8ë3ÿ‹D$8…Àt‹ë3Ò‹D$4…Àt‹ë3É‹D$,…Àt‹ ë3À‹l$UWR‹T$4Q‹L$@QP‹C$RVÿĞ3Û;Ã}hTVPèÄa  ·L$‹D$,‹=D€‹-d‰L$0;Ãt6‹ğƒÀPÿ×…Àu&;ót"‹;ÃtPÿÕ‹F;Ãt	Pè«c  ƒÄVèc  ƒÄ‰\$,‹t$4;ót4VRÿ×…Àu&;ót"‹;ÃtPÿÕ‹F;Ãt	Pèoc  ƒÄVèÛb  ƒÄ‰\$4‹t$8;ót4FPÿ×…Àu&;ót"‹;ÃtPÿÕ‹F;Ãt	Pè3c  ƒÄVèŸb  ƒÄ‰\$8‹t$<;ót0NQÿ×…Àu&;ót"‹;ÃtPÿÕ‹F;Ãt	Pè÷b  ƒÄVècb  ƒÄf‹D$0‹L$d‰    Y_^][ƒÄÂ ÌÌÌÌÌÌjÿhjd¡    PVW¡pğ3ÄPD$d£    ‹ùÇD$    ‹D$ …Àt‹ ë3À‹‹I(RP‹D$$PWÿÑ‹ğ…ö}hTWVèE`  ‹|$ …ÿt8WRÿD€…Àu*…ÿt&‹…ÀtPÿd‹G…Àt	Pè;b  ƒÄWè§a  ƒÄ‹Æ‹L$d‰    Y_^ƒÄÂ ÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌjÿh¸hd¡    PQVW¡pğ3ÄPD$d£    ‹ñÇD$    ‹D$$ÇD$    …Àt‹ ë3À‹‹I,T$RP‹D$(PVÿÑ…À}hTVPèz_  ‹t$$·|$…öt8VRÿD€…Àu*…öt&‹…ÀtPÿd‹F…Àt	Pèka  ƒÄVè×`  ƒÄf‹Ç‹L$d‰    Y_^ƒÄÂ ÌÌÌÌÌÌÌÌÌÌÌÌÌÌjÿhjd¡    PVW¡pğ3ÄPD$d£    ‹ùÇD$    ‹D$ …Àt‹ ë3À‹R‹T$8‹I0R‹T$8R‹T$8R‹T$8R‹T$8RP‹D$8PWÿÑ‹ğ…ö}hTWVèœ^  ‹|$ …ÿt8WRÿD€…Àu*…ÿt&‹…ÀtPÿd‹G…Àt	Pè’`  ƒÄWèş_  ƒÄ‹Æ‹L$d‰    Y_^ƒÄÂ ÌÌÌÌÌÌjÿh¸hd¡    PQVW¡pğ3ÄPD$d£    ‹ñÇD$    ‹D$$ÇD$    …Àt‹ ë3À‹‹I4T$RP‹D$(PVÿÑ…À}hTVPèÚ]  ‹t$$·|$…öt8VRÿD€…Àu*…öt&‹…ÀtPÿd‹F…Àt	PèË_  ƒÄVè7_  ƒÄf‹Ç‹L$d‰    Y_^ƒÄÂ ÌÌÌÌÌÌÌÌÌÌÌÌÌÌjÿh¸hd¡    PQVW¡pğ3ÄPD$d£    ‹ñÇD$    ‹D$$ÇD$    …Àt‹ ë3À‹‹I8T$RP‹D$(PVÿÑ…À}hTVPè
]  ‹t$$·|$…öt8VRÿD€…Àu*…öt&‹…ÀtPÿd‹F…Àt	Pèû^  ƒÄVèg^  ƒÄf‹Ç‹L$d‰    Y_^ƒÄÂ ÌÌÌÌÌÌÌÌÌÌÌÌÌÌjÿhjd¡    PVW¡pğ3ÄPD$d£    ‹ùÇD$    ‹D$ …Àt‹ ë3À‹‹I<RP‹D$$PWÿÑ‹ğ…ö}hTWVèE\  ‹|$ …ÿt8WRÿD€…Àu*…ÿt&‹…ÀtPÿd‹G…Àt	Pè;^  ƒÄWè§]  ƒÄ‹Æ‹L$d‰    Y_^ƒÄÂ ÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌjÿh¸hd¡    PQVW¡pğ3ÄPD$d£    ‹ñÇD$    ‹D$$ÇD$    …Àt‹ ë3À‹‹I@T$RP‹D$(PVÿÑ…À}hTVPèz[  ‹t$$·|$…öt8VRÿD€…Àu*…öt&‹…ÀtPÿd‹F…Àt	Pèk]  ƒÄVè×\  ƒÄf‹Ç‹L$d‰    Y_^ƒÄÂ ÌÌÌÌÌÌÌÌÌÌÌÌÌÌSV‹ñÇ`W‹|$‹G‰F‹O‰N‹W‰V‹G‰F‹O‰N‹W‰V‹G‰F‹O ‰N ‹W$‰V$‹G(‰F(‹O,‰N,‹W0‰V0‹G4‰F4‹O8‰N8‹W<‰V<‹G@‰F@‹OD‰ND‹WH‹<€‰VH‹GL‰FL‹OP‰NP‹WT‰VT‹GX‰FX‹O\‰N\‹W`‰V`‹Gd‰Fd…ÀtƒÀPÿÓ‹Gh‰Fh…ÀtƒÀPÿÓ‹Gl‰FlŠOpˆNpŠWqˆVq‹Gt‰Ft‹Ox_‰Nx‹Æ^[Â ÌÌÌÌÌSU‹l$‹EV‹ñ‰F‹M‰N‹U‰V‹E‰F‹M‰N‹U‰V‹E‰F‹M ‰N ‹U$‰V$‹E(‰F(‹M,‰N,‹U0‰V0‹E4‰F4‹M8‰N8‹U<‰V<‹E@‰F@‹MD‰ND‹UH‰VH‹EL‰FL‹MP‰NP‹UT‰VT‹EX‰FX‹M\‰N\‹U`W]d~d‰V`è»;  ]h~hè°;  ‹El‰FlŠMpˆNpŠUqˆVq‹Et‰Ft‹Mx_‰Nx‹Æ^][Â ÌÌÌÌÌÌÌÌÌSŠ\$V‹ñöÃt+‹FüWh€7 ~üPj|Vè±[  öÃt	Wè=[  ƒÄ‹Ç_^[Â èS  öÃt	Vè—Z  ƒÄ‹Æ^[Â ÌÌÌÌÌÌÌÌÌÌÌÌÌÌ‹ÁÇ hÂ ÌÌÌÌÌSŠ\$W‹ùöÃt+‹GüVh@\ wüPjWèA[  öÃt	VèÍZ  ƒÄ‹Æ^_[Â Çh¡ü…Àuj|èGZ  ƒÄ…Àt	‹Èè$  ë3À£üÇ@    öÃt	WèøY  ƒÄ‹Ç_[Â ÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌ‹ÁÇ tÂ ÌÌÌÌÌSŠ\$W‹ùöÃt+‹GüVhĞ\ wüPjWè¡Z  öÃt	Vè-Z  ƒÄ‹Æ^_[Â Çt¡ü…Àuj|è§Y  ƒÄ…Àt	‹Èè„  ë3À£üÇ@    öÃt	WèXY  ƒÄ‹Ç_[Â ÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌ‹ÁÇ ŒÂ ÌÌÌÌÌSŠ\$W‹ùöÃt+‹GüVh`] wüPjWèZ  öÃt	VèY  ƒÄ‹Æ^_[Â ÇŒ¡ü…Àuj|èY  ƒÄ…Àt	‹Èèä   ë3À£üÇ@    öÃt	Wè¸X  ƒÄ‹Ç_[Â ÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌ‹ÁÇ œÂ ÌÌÌÌÌ‹ÁÂ ÌÌÌÌÌÌÌÌÌÌÌSŠ\$W‹ùöÃt+‹GüVhğ] wüPjWèQY  öÃt	VèİX  ƒÄ‹Æ^_[Â Çœ¡ü…Àuj|èWX  ƒÄ…Àt	‹Èè4   ë3À£üÇ@    öÃt	WèX  ƒÄ‹Ç_[Â ÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌSV‹ñ3ÛÇ`‰^dS‰^hÿ€…À|{Whà‰^‰^‰^ ‰^$‰^(‰^,‰^‰^‰^‰^‰^‰^l‰^0‰^4‰^8‰^<‰^@ˆ^q‰^Dÿ8€FxPSShàB SSè[  ‹=4€ƒÄSSSS‰Ftÿ×SjSS£ÿ×£_‹Æ^[ÃÌÌÌjÿh†hd¡    PQSUVW¡pğ3ÄPD$d£    ‹ù‰|$Ç`ÇD$    ¡‹50€PÿÖ‹QÿÖ‹Ïè	  ‹3Û‰_l;Ët‹‹B jÿĞ‰ÿp‹wh‹-D€;ót7NQÿÕ…Àu*;ót&‹;ÃtPÿd‹F;Ãt	Pè*W  ƒÄVè–V  ƒÄ‰_h‹wd;ót7VRÿÕ…Àu*;ót&‹;ÃtPÿd‹F;Ãt	PèìV  ƒÄVèXV  ƒÄ‰_d‹L$d‰    Y_^][ƒÄÃÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌ‹D$‰AÂ ÌÌÌÌÌÌ‹D$‰AÂ ÌÌÌÌÌÌ‹D$‰AÂ ÌÌÌÌÌÌ‹D$‰AÂ ÌÌÌÌÌÌV‹ñ‹FDW3ÿ;Çte‹VP‹RP‹AÿĞ‹FD‹VH‹RP‹AÿĞ‹FD‹VL‹RP‹AÿĞ‹FD‹VT‹RP‹AÿĞ‹FD‹VX‹RP‹AÿĞ‹FD‹V\‹RP‹AÿĞ‹FD‹‹QPÿÒ‰~D‹F;Ç„î   ‹Nd;Ït‹	ë3É‹‹R Q‹N`QPÿÒ‹F;Çt‹‹QPÿÒ‰~‹F;Çt‹‹QPÿÒ‰~‹F ;Çt‹‹QPÿÒ‰~ ‹F$;Çt‹‹QPÿÒ‰~$‹F(;Çt‹‹QPÿÒ‰~(‹F,;Çt‹‹QPÿÒ‰~,‹F0;Çt‹‹QPÿÒ‰~0‹F4;Çt‹‹QPÿÒ‰~4‹F8;Çt‹‹QPÿÒ‰~8‹F<;Çt‹‹QPÿÒ‰~<‹F@;Çt‹‹QPÿÒ‰~@‹F‹‹QPÿÒ‰~_^ÃÌÌ¡…ÀtPÿ$€ÃÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌU‹ìjÿhld¡    PQSVW¡pğ3ÅPEôd£    ‰eğ‹ñÇEü    ÆEüè5şÿÿ‹Îèn	  ‹Môd‰    Y_^[‹å]Ã¸Ğ: Ã¸Ğ: Ã3À‹Môd‰    Y_^[‹å]ÃÌÌÌÌÌÌÌÌÌÌÌÌU‹ìjÿhhd¡    PƒìSVW¡pğ3ÅPEôd£    ‰eğ‹ñ‰uè3Û‰]ü9]‹ND•ÀˆFp‹F‰E;Ët‹EP‹FPh4PQ‹JÿÑ‹E;Ã•Â Vp‹øtC‹UìRP‹A,‰]ìÿĞ;Ã}h4WPè²Q  f9]ìW•ÁˆNp‹‹BÿĞë‹MèÆAp ¸Ÿ; Ã‹uè¶Fp‹Môd‰    Y_^[‹å]Â ÌÌÌÌÌÌU‹ìjÿh`ld¡    PƒìSVW¡pğ3ÅPEôd£    ‰eğ‹ù‰}ìÇEü    €q »   t3À‹Môd‰    Y_^[‹å]Â ƒ} u	‹ÏèKşÿÿ‹Ø‹w…ötI‹‹P,MQVÇE    ÿÒ…À}h4VPèßP  fƒ} u‹Ïèşÿÿ‹Øë‹Mìèşÿÿ‰E¸t< Ã‹]‹Ã‹Môd‰    Y_^[‹å]Â ÌÌÌU‹ìjÿh€qd¡    PƒìSVW¡pğ3ÅPEôd£    ‰eğ‹ñ3Û‰]ü‹F P‰]èèòşÿÿ;Ãu3À‹Môd‰    Y_^[‹å]Ã9^ tU‹FdQ‹Ì‰eì‰;Ãt
ƒÀPÿ<€‹N`‹V QMìèMçÿÿ‹ ;Ãt‹}ìèİ2  ‹Ã‹Môd‰    Y_^[‹å]Ã¸== Ã‹]è‹Ã‹Môd‰    Y_^[‹å]ÃÌÌÌÌÌÌÌÌÌÌÌÌU‹ìjÿh`qd¡    PƒìSVW¡pğ3ÅPEôd£    ‰eğ‹ñ3Û‰]ü‹F P‰]ìè"şÿÿ;Ãu3À‹Môd‰    Y_^[‹å]Â 9^ tS‹}Q‹Ì‰eèQè1  ‹FdQ‹Ì‰eè‰;Ãt
ƒÀPÿ<€‹V`‹N REPèÛãÿÿ‹ ;Ãt‹}èû1  ë	¸> Ã‹]ì‹Ã‹Môd‰    Y_^[‹å]Â ÌÌÌÌÌÌÌÌÌÌV‹ñƒ~ t
‹N‹‹PÿÒ‹Î^é•úÿÿÌÌÌÌÌ3À9At
‹I‹‹PÿâÃÌÌÌÌÌÌÌÌÌÌÌÌÌÌ3À9At
‹I‹‹@ÿàÂ ÌÌÌÌÌÌÌÌÌÌÌÌƒy t
‹I‹‹@ÿàÂ ÌÌÌÌÌÌÌÌÌÌÌÌÌƒy t
‹I‹‹@ÿàÂ ÌÌÌÌÌÌÌÌÌÌÌÌÌƒy t
‹I‹‹@ÿàÂ ÌÌÌÌÌÌÌÌÌÌÌÌÌƒy t‹T$‹I‹‹@R‹T$RÿĞÂ ÌÌÌhàÿ€ŠD$¢ ÇD$àÿ%€ÌÌÌÌÌÌÌÌÌÌÌÌÌÌShàÿ€Š hàÿ€ŠÃ[ÃÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌU‹ìjÿhğkd¡    Pƒì,SVW¡pğ3ÅPEôd£    ‰eğÆEïÇEü    ë¤$    h¸ÿ€ƒ=´ h¸”Ãÿ€„Û…Ï  ‹üƒyD ‹Q,‰Uèt(‹AD‹IH‹‹RuèVhTQPÿÒ‹Eè‹ü‰EØ‹Ğë‰UØ‹A`‰Eà‹Ad…Àt‹ ‰EäëÇEä    Rèºúÿÿ…Àu2À‹Môd‰    Y_^[‹å]ÃÆEüèY<  ‹ø‰}Ü…ÿ„;ÿÿÿƒ …
  ƒ}è _·  „÷  ‹Gƒø‡à  ÿ$…¼B Q‹Ì‰eÔQ¿„è+.  QÆEü‹Ô‰eĞR‹şè.  QÆEü‹Ä‰eÌP¿„è.  ‹}äj QÆEü‹Ì‰eÈQèï-  ‹UàRét  Q‹Ä‰eÈP¿„èÕ-  QÆEü‹Ì‰eÌQ‹şèÃ-  QÆEü‹Ô‰eĞR‹ûè±-  ÆEüj ‹}äQ‹Ä‰eÔPèœ-  ‹MàQé!  Q‹Ô‰eÈR‹şè…-  QÆEü‹Ä‰eÌP¿„èp-  QÆEü	‹Ì‰eĞQ‹ûè^-  ÆEü
jéÎ   Q‹Ì‰eÈQ¿„èB-  QÆEü‹Ô‰eÌR‹şè0-  QÆEü‹Ä‰eĞP‹ûè-  ‹}äjQÆEü‹Ì‰eÔQè	-  ‹UàRé   Q‹Ä‰eÈP¿„èï,  QÆEü‹Ì‰eÌQ‹şèİ,  QÆEü‹Ô‰eĞR‹ûèË,  ÆEüjéÿÿÿQ‹Ô‰eÈR‹şè²,  QÆEü‹Ä‰eÌP¿„è,  QÆEü‹Ì‰eĞQ‹ûè‹,  ÆEüj‹}äQ‹Ô‰eÔRèv,  ‹EàP‹MèÆEüèfèÿÿ‹}Ü‹EØ‹‹QPÿÒ‹‹j‹ÏÿÒéıÿÿÆEï ÇEü    ¸˜B ÃéıÿÿÆEï ¸§B ÃŠEï‹Môd‰    Y_^[‹å]Ã”@ ê@ =A }A ĞA B ÌÌÌÌÌÌÌÌÌÌÌÌƒ= tD‹5 €‹@€‹=$€ëI ¡jÿPÿÖ…Àuò¡…ÀtPÿÓèQüÿÿ¡…ÀtØPÿ×ëÓ3ÀÂ ÌÌÌÌÌÌÌÌÌÌÌÌÌÌV‹ñFxPj j hàB j j èO  ƒÄ‰Ft^ÃÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌV‹ñ‹Ft…Àtj Pÿ(€‹FtPÿ0€ÇFt    ^ÃÌÌÌÌÌÌÌÌÌÌ¡ü…Àu"j|èEK  ƒÄ…Àt‹Èè"óÿÿ£üÃ3À£üÃÌÌÌÌ‹ü…Ét‹‹jÿÒÇü    ÃÌÌÌ‹D$S‹\$V‹ñNdQ‰F`èÈ)  ‹\$ƒÆhVè»)  ^[Â ÌÌÌÌÌÌU‹ìjÿh@kd¡    PƒìSVW¡pğ3ÅPEôd£    ‰eğ‹ù‰}ä3ö95ü„•   9w`Œ   ‹Gd;Æ„   ‹ ;Æt{Pÿ\;Ætp9w_t¸   ‹Môd‰    Y_^[‹å]ÃEìPVjjhd‰uì‰uüÿX…À|3Sh4jVhtÿt;ÆœÀˆGq„Àt'‹EìÆGp ;Æt‹‹QPÿÒ3À‹Môd‰    Y_^[‹å]Ã‹;Æ„¤   ‹W,RhTP‹ÿĞ‹‹W RhDP‹ÿĞ‹‹W0RhäP‹ÿĞ‹‹W4RhôP‹ÿĞ‹‹W8RhP‹ÿĞ‹‹W<Rh$P‹ÿĞ‹‹W@RhP‹ÿĞè^B  Q‰EèGd‹ô‰eàè-*  ‹O`‹UèQ‹è_×ÿÿÆGpwDVh¤jj hìÿt…ÀŒÿÿÿ‹…À„‡   ‹‹ROPQ‹h4QPÿÒ‹‹WHR‹W,hTRP‹AÿĞ‹‹WLR‹W hDRP‹AÿĞ‹‹WTR‹W8hRP‹AÿĞ‹‹WXR‹W<h$RP‹AÿĞ‹6‹G@‹‹IW\RhPVÿÑƒ0 „şÿÿQGh‹ô‰eàèR)  QGd‹ô‰eàèD)  ‹W`‹O0Rè¸Íÿÿéîıÿÿ‹Eì…Àt‹‹QPÿÒÇEì    è¨A  ‹Mäj è  ¸óD ÃÌÌÌÌÌÌÌÌQƒyD ‹A ‰$t‹AD‹IL‹‹RVt$VhDQPÿÒ‹D$^YÃÌÌQƒyD ‹A8‰$t‹AD‹IT‹‹RVt$VhQPÿÒ‹D$^YÃÌÌQƒyD ‹A<‰$t‹AD‹IX‹‹RVt$Vh$QPÿÒ‹D$^YÃÌÌQƒyD ‹A@‰$t‹AD‹I\‹‹RVt$VhQPÿÒ‹D$^YÃÌÌQƒyD ‹A,‰$t‹AD‹IH‹‹RVt$VhTQPÿÒ‹D$^YÃÌÌQƒyD ‹A‰$t‹AD‹IP‹‹RVt$Vh4QPÿÒ‹D$^YÃÌÌU‹ìjÿh0hd¡    PQSVW¡pğ3ÅPEôd£    ‰eğ‹ñ3ÿ‰}ü¡jdPÿ €‹Ft;ÇtWPÿ(€‹NtQÿ0€‰~thàÿ,€‹Îè„ğÿÿ¸   ‹Môd‰    Y_^[‹å]Ã¸yH Ã3À‹Môd‰    Y_^[‹å]ÃÌÌÌU‹ìjÿh@qd¡    PƒìSVW¡pğ3ÅPEôd£    ‰eğ‹ñÇEü    ‹FPèóòÿÿ…Àt.ƒ~ t(‹FdQ‹Ì‰eì‰…Àt
ƒÀPÿ<€‹N`‹UQ‹Nè1Öÿÿ‹Môd‰    Y_^[‹å]Â ¸ÿH ÃÌÌÌÌÌÌÌU‹ìjÿh qd¡    PƒìSVW¡pğ3ÅPEôd£    ‰eğ‹ñ3ÿ‰}ü‹FP‰}ìèbòÿÿ;Çu3À‹Môd‰    Y_^[‹å]Ã9~tJ‹FdQ‹Ì‰eè‰;Çt
ƒÀPÿ<€‹V`‹Nè1Ôÿÿ3É;ÇÁ‹ù‹Ç‹Môd‰    Y_^[‹å]Ã¸ÂI Ã‹}ì‹Ç‹Môd‰    Y_^[‹å]ÃÌÌÌÌÌÌÌU‹ìjÿh qd¡    PƒìSVW¡pğ3ÅPEôd£    ‰eğ‹ñ3ÿ‰}ü‹FP‰}ìè¢ñÿÿ;Çu3À‹Môd‰    Y_^[‹å]Ã9~tJ‹FdQ‹Ì‰eè‰;Çt
ƒÀPÿ<€‹V`‹Nè!Ôÿÿ3É;ÇÁ‹ù‹Ç‹Môd‰    Y_^[‹å]Ã¸‚J Ã‹}ì‹Ç‹Môd‰    Y_^[‹å]ÃÌÌÌÌÌÌÌU‹ìjÿhàpd¡    PƒìSVW¡pğ3ÅPEôd£    ‰eğ‹ñ3ÿ‰}ü‹FP‰}ìèâğÿÿ;Çu3À‹Môd‰    Y_^[‹å]Ã9~tH‹FdQ‹Ì‰eè‰;Çt
ƒÀPÿ<€‹N`Q‹Nè Æÿÿ·À¿ø‹Ç‹Môd‰    Y_^[‹å]Ã¸@K Ã‹}ì‹Ç‹Môd‰    Y_^[‹å]ÃÌÌÌÌÌÌÌÌÌU‹ìjÿhÀpd¡    PƒìSVW¡pğ3ÅPEôd£    ‰eğ‹ñ3ÿ‰}ü‹F P‰}ìè"ğÿÿ…Àu‹Môd‰    Y_^[‹å]Â ƒ~  tH‹}Q‹Ì‰eèQè#  ‹FdQ‹Ì‰e‰…Àt
ƒÀPÿ<€‹V`‹N Rè@Ùÿÿ3É…ÀÁ‹ùë	¸L Ã‹}ì‹Ç‹Môd‰    Y_^[‹å]Â ÌÌÌÌÌÌU‹ìjÿh pd¡    PƒìSVW¡pğ3ÅPEôd£    ‰eğ‹ñ3ÿ‰}ü‹F P‰}ìèbïÿÿ…Àu‹Môd‰    Y_^[‹å]Â ƒ~  tH‹}Q‹Ì‰eèQèE"  ‹FdQ‹Ì‰e‰…Àt
ƒÀPÿ<€‹V`‹N RèÙÿÿ3É…ÀÁ‹ùë	¸ÁL Ã‹}ì‹Ç‹Môd‰    Y_^[‹å]Â ÌÌÌÌÌÌU‹ìjÿh€pd¡    PƒìSVW¡pğ3ÅPEôd£    ‰eğ‹ñ‹F3É‰Mì;Áu9Nlu3À‹Môd‰    Y_^[‹å]Â ‹}‹]‰Mü;Át‹È‹‹PWSÿÒ…Àu‹Fl…ÀtWSÿĞ…ÀtWS‹Îè¸  ‰Eì‹Eì‹Môd‰    Y_^[‹å]Â ¸kM ÃÌÌÌÌÌÌÌÌìä  ¡pğ3Ä‰„$à  ‹„$ì  SU‹¬$ü  V‹´$ô  W‹¼$   j2L$8QPÿ|T$4Rh¹,  œ$    èƒ  ƒÄ…À|J3ÀU‰D$‰D$(‰D$4‰D$‰D$‰D$ ‰D$$‰D$,‰D$0WD$P‹ËQÇD$ $   ‰t$@ÇD$4   ÿx‹Œ$ğ  _^][3Ìèp@  Ää  Â ÌÌÌÌÌÌÌU‹ìjÿh qd¡    PƒìSVW¡pğ3ÅPEôd£    ‰eğ‹ñ3Û‰]è‰]ì9^u9^lu3À‹Môd‰    Y_^[‹å]Ã‹Î‰]üècõÿÿ;Ãt(‹ÎèÈíÿÿ‹ø;ûtW‹ÎèŠîÿÿ‰Eì‹Î;ÃtPWèúıÿÿ‰Eè‹Eè‹Môd‰    Y_^[‹å]ÃEìPWèˆ	  ;Ãuİ‹MìQW‹ÎëÌ¸éN ÃÌÌÌÌÌU‹ìjÿhXpd¡    PƒìSVW¡pğ3ÅPEôd£    ‰eğ‹ñ3Û‰]ü‹F 3ÿP‰}ìè`ìÿÿ;Ãu3À‹Môd‰    Y_^[‹å]Â 9^ t^‹}Q‹Ì‰eèQèB  ‹}Q‹Ô‰eRÆEüè/  ‹FdQ‹Ì‰e‰;Ãt
ƒÀPÿ<€‹F`ˆ]ü‹N Pè7Óÿÿ3É;ÃÁ‹ùë	¸ÚO Ã‹}ì‹Ç‹Môd‰    Y_^[‹å]Â ÌÌÌÌÌÌÌÌÌÌÌÌÌU‹ìjÿh(pd¡    PƒìSVW¡pğ3ÅPEôd£    ‰eğ‹ñ3Û‰]ü‹F 3ÿP‰}ìè€ëÿÿ;Ãu3À‹Môd‰    Y_^[‹å]Â 9^ tb‹M‹}QQ‹Ô‰eRè^  ‹}Q‹Ä‰ePÆEüèK  ‹FdQ‹Ì‰e‰;Ãt
ƒÀPÿ<€‹N`Qˆ]ü‹N è£Öÿÿ3Ò;ÃÂ‹úë	¸¾P Ã‹}ì‹Ç‹Môd‰    Y_^[‹å]Â ÌÌÌÌÌÌÌÌÌU‹ìjÿh kd¡    PƒìSVW¡pğ3ÅPEôd£    ‰eğ‹ñ3À‰Eü9F tG‹FdQ‹Ì‰eì‰…Àt
ƒÀPÿ<€‹V`‹N èu×ÿÿ3É…ÀÁ‹Á‹Môd‰    Y_^[‹å]Ã¸\Q Ã3À‹Môd‰    Y_^[‹å]Ã€yp u‹A,PèAêÿÿ…ÀtaVh¸ÿ€h
  è\=  ‹ğƒÄ3À…öt‹L$º„èÎ)  L$‰D$Q¸˜è‹+  h¸ÿ€¡^…Àt
‰D$ÿ%$€Â ÌÌÌÌÌÌÌÌÌ€yp u‹A,PèÁéÿÿ…ÀtdVh¸ÿ€h
  èÜ<  ‹ğƒÄ…öt‹L$‹T$¸   èL)  ë3ÀL$‰D$Q¸˜è+  h¸ÿ€¡^…ÀtPÿ$€Â ÌÌÌÌÌÌ€yp u‹A,PèAéÿÿ…ÀtdVh¸ÿ€h
  è\<  ‹ğƒÄ…öt‹L$‹T$¸   èÌ(  ë3ÀL$‰D$Q¸˜è…*  h¸ÿ€¡^…ÀtPÿ$€Â ÌÌÌÌÌÌU‹ìjÿh pd¡    PƒìSVW¡pğ3ÅPEôd£    ‰eğ‹ñÇEü    ‹F,¿   P‰}ìè‹èÿÿ…Àu‹Ç‹Môd‰    Y_^[‹å]Ãƒ~, tH‹FdQ‹Ì‰eè‰…Àt
ƒÀPÿ<€‹N`Q‹N,èØÙÿÿ·À¿ø‹Ç‹Môd‰    Y_^[‹å]Ã¸˜S Ã‹}ì‹Ç‹Môd‰    Y_^[‹å]ÃÌU‹ìjÿhàod¡    PQSVW¡pğ3ÅPEôd£    ‰eğ‹ñÇEü    ‹F,PèÕçÿÿ…Àt1ƒ~, t+‹Fdf‹}Q‹Ì‰e‰…Àt
ƒÀPÿ<€‹N`Q‹N,‹×èpØÿÿ‹Môd‰    Y_^[‹å]Â ¸ T ÃÌÌÌÌÌÌU‹ìjÿhÀod¡    PƒìSVW¡pğ3ÅPEôd£    ‰eğ‹ñÇEü    ‹F,PèCçÿÿ…Àu¸   ‹Môd‰    Y_^[‹å]Ãƒ~, tA‹FdQ‹Ì‰eì‰…Àt
ƒÀPÿ<€‹N`Q‹N,èıÚÿÿ·À˜‹Môd‰    Y_^[‹å]Ã¸ßT Ã3À‹Môd‰    Y_^[‹å]ÃÌÌÌÌÌÌÌÌÌÌÌÌÌU‹ìjÿh od¡    PƒìSVW¡pğ3ÅPEôd£    ‰eğ‹ñÇEü    ‹F,Pèƒæÿÿ…Àu¸   ‹Môd‰    Y_^[‹å]Ãƒ~, tA‹FdQ‹Ì‰eì‰…Àt
ƒÀPÿ<€‹N`Q‹N,èmÙÿÿ·À˜‹Môd‰    Y_^[‹å]Ã¸ŸU Ã3À‹Môd‰    Y_^[‹å]ÃÌÌÌÌÌÌÌÌÌÌÌÌÌU‹ìjÿh€od¡    PQSVW¡pğ3ÅPEôd£    ‰eğ‹ñÇEü    ‹F,PèÅåÿÿ…ÀtDƒ~, t>‹M‹U‹E‹}Q‹MR‹UP‹FdQRQ‹Ì‰e‰…Àt
ƒÀPÿ<€‹F`‹N,P‹×èİ×ÿÿ‹Môd‰    Y_^[‹å]Â ¸CV ÃÌÌÌU‹ìjÿh`od¡    PQSVW¡pğ3ÅPEôd£    ‰eğ‹ñÇEü    ‹F@Pè%åÿÿ…Àt&ƒ~@ t ‹]‹}Q‹Ì‰eQè  ‹U‹N@R‹Óè{Âÿÿ‹Môd‰    Y_^[‹å]Â ¸ÅV ÃÌU‹ìjÿh@od¡    PƒìSVW¡pğ3ÅPEôd£    ‰eğ‹ñ3Û‰]ü‹F(3ÿP‰}ìè äÿÿ;Ãu3À‹Môd‰    Y_^[‹å]Â 9^(tn‹}Q‹Ì‰eèQè‚  ‹}QÆEü‹Ô‰eRèo  ‹}Q‹Ä‰ePÆEüè\  ‹FdQ‹Ì‰e‰;Ãt
ƒÀPÿ<€‹N`Qˆ]ü‹N(èôºÿÿ·À¿øë	¸ªW Ã‹}ì‹Ç‹Môd‰    Y_^[‹å]Â ÌÌÌÌÌÌÌÌÌÌÌÌÌQ$Ph¸œh  €ÿ€…Àu,‹L$jT$RjP‹D$hœœP‰L$ ÿ€‹$Qÿ€YÂ ÌÌÌÌÌÌÌƒìVD$Ph¸œh  €¾   ÿ €…ÀuA¸   L$Q‹L$T$R‰D$‰D$D$Pj hœœQÿ€…Àu‹t$‹T$Rÿ€‹Æ^ƒÄÃÌÌÌÌÌÌU‹ìjÿhod¡    PƒìSVW¡pğ3ÅPEôd£    ‰eğ‹ñÇEü    ‹F »   P‰]ìèëâÿÿ…ÀuC‹Môd‰    Y_^[‹å]Â ƒ~  tM‹M‹}QQ‹Ô‰eRèÇ  ‹FdQ‹Ì‰e‰…Àt
ƒÀPÿ<€‹F`‹N Pè‚Çÿÿ·Àf…Àt3Ûë	¸@Y Ã‹]ì‹Ã‹Môd‰    Y_^[‹å]Â ÌÌÌÌÌÌÌU‹ìjÿhğnd¡    PƒìSVW¡pğ3ÅPEôd£    ‰eğ‹ñ3Û‰]ü‹F$3ÿP‰}ìè âÿÿ;Ãu3À‹Môd‰    Y_^[‹å]Â 9^$tn‹}Q‹Ì‰eèQè  ‹}QÆEü‹Ô‰eRèï  ‹}Q‹Ä‰ePÆEüèÜ  ‹FdQ‹Ì‰e‰;Ãt
ƒÀPÿ<€‹N`Qˆ]ü‹N$èäµÿÿ·À¿øë	¸*Z Ã‹}ì‹Ç‹Môd‰    Y_^[‹å]Â ÌÌÌÌÌÌÌÌÌÌÌÌÌU‹ìjÿhÀnd¡    PƒìSVW¡pğ3ÅPEôd£    ‰eğ‹ñ3ÿ‰}ü‹F,P‰}èè2áÿÿ;Çu3À‹Môd‰    Y_^[‹å]Ã‹v,;÷t@‹‹A UìRV‰}ìÿĞ;Ç}hTVPèd2  ¿}ì‹Ç‹Môd‰    Y_^[‹å]Ã¸êZ Ã‹}è‹Ç‹Môd‰    Y_^[‹å]ÃÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌU‹ìjÿh˜nd¡    PƒìSVW¡pğ3ÅPEôd£    ‰eğ‹ñ3Û‰]ü‹F,3ÿP‰}ìèpàÿÿ;Ãu3À‹Môd‰    Y_^[‹å]Â 9^,t[‹}Q‹Ì‰eèQèR  ‹}Q‹Ô‰eRÆEüè?  ‹FdQ‹Ì‰e‰;Ãt
ƒÀPÿ<€‹F`ˆ]ü‹N,Pè§Íÿÿ·À¿øë	¸Ç[ Ã‹}ì‹Ç‹Môd‰    Y_^[‹å]Â ‹D$‰AlÂ ÌÌÌÌÌÌV‹ñÇh¡ü…Àu(j|èì2  ƒÄ…Àt‹ÈèÉÚÿÿ£ü‰p‹Æ^Ã3À£ü‰p‹Æ^ÃÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÇh¡ü…Àu)j|èŸ2  ƒÄ…Àt‹Èè|Úÿÿ£üÇ@    Ã3À£üÇ@    ÃV‹ñÇt¡ü…Àu(j|è\2  ƒÄ…Àt‹Èè9Úÿÿ£ü‰p‹Æ^Ã3À£ü‰p‹Æ^ÃÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÇt¡ü…Àu)j|è2  ƒÄ…Àt‹ÈèìÙÿÿ£üÇ@    Ã3À£üÇ@    ÃV‹ñÇŒ¡ü…Àu(j|èÌ1  ƒÄ…Àt‹Èè©Ùÿÿ£ü‰p‹Æ^Ã3À£ü‰p‹Æ^ÃÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÇŒ¡ü…Àu)j|è1  ƒÄ…Àt‹Èè\Ùÿÿ£üÇ@    Ã3À£üÇ@    ÃV‹ñÇœ¡ü…Àu(j|è<1  ƒÄ…Àt‹ÈèÙÿÿ£ü‰p‹Æ^Ã3À£ü‰p‹Æ^ÃÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÇœ¡ü…Àu)j|èï0  ƒÄ…Àt‹ÈèÌØÿÿ£üÇ@    Ã3À£üÇ@    Ã€yp u‹A,Pèİÿÿ…ÀtdVh¸ÿ€h
  èœ0  ‹ğƒÄ…öt‹L$‹T$¸   è  ë3ÀL$‰D$Q¸˜èÅ  h¸ÿ€¡^…ÀtPÿ$€Â ÌÌÌÌÌÌ€yp u‹A,Pèİÿÿ…ÀtdVh¸ÿ€h
  è0  ‹ğƒÄ…öt‹L$‹T$¸   èŒ  ë3ÀL$‰D$Q¸˜èE  h¸ÿ€¡^…ÀtPÿ$€Â ÌÌÌÌÌÌ€yp u‹A,PèÜÿÿ…ÀtdVh¸ÿ€h
  èœ/  ‹ğƒÄ…öt‹L$‹T$¸   è  ë3ÀL$‰D$Q¸˜èÅ  h¸ÿ€¡^…ÀtPÿ$€Â ÌÌÌÌÌÌU‹ìjÿhpnd¡    PƒìSVW¡pğ3ÅPEôd£    ‰eğ‹ñÇEü    ‹F,¿   P‰}ìèËÛÿÿ…Àu‹Ç‹Môd‰    Y_^[‹å]Ãƒ~, tH‹FdQ‹Ì‰eè‰…Àt
ƒÀPÿ<€‹N`Q‹N,èÑÿÿ·À¿ø‹Ç‹Môd‰    Y_^[‹å]Ã¸X` Ã‹}ì‹Ç‹Môd‰    Y_^[‹å]ÃÌU‹ìjÿhPnd¡    PQSVW¡pğ3ÅPEôd£    ‰eğ‹ñÇEü    ‹F,PèÛÿÿ…Àt1ƒ~, t+‹Fdf‹}Q‹Ì‰e‰…Àt
ƒÀPÿ<€‹N`Q‹N,‹×è°Ïÿÿ‹Môd‰    Y_^[‹å]Â ¸à` ÃÌÌÌÌÌÌU‹ìjÿh0nd¡    PQSVW¡pğ3ÅPEôd£    ‰eğ‹ñÇEü    ‹FPè…Úÿÿ…Àt0ƒ~ t*‹Fd‹}Q‹Ì‰e‰…Àt
ƒÀPÿ<€‹N`Q‹N‹×è¾ÿÿ‹Môd‰    Y_^[‹å]Â ¸oa ÃÌÌÌÌÌÌÌU‹ìjÿhnd¡    Pƒì,SVW¡pğ3ÅPEôd£    ‰eğ‹ñ3Û‰]ü‹F0P‰]ÈèòÙÿÿ;Ãu3À‹Môd‰    Y_^[‹å]Â ‹v0;ó„3  ‹UàREÌPUĞREÔPUØR‹UEÜP‹A RV‰]àÿĞ;Ã}häVPè+  ƒÉÿf;Mà…·  ‹}ÜUäRè  EèÆEü‹}ØPè}  MìÆEü‹}ÔQèm  UÆEü‹}ĞRè]  EàÆEü‹}ÌPèM  ‹Eä;Ãt9‹ ;Ãt3‹5\PÿÖ;Ãv,‹Eä;Ãt‹ë3É‹UI ·f‰ƒÁƒÂf;Ãuïë‹5\‹Eè;Ãt1‹ ;Ãt+PÿÖ;Ãv$‹Eè;Ãt‹ë3É‹UI ·f‰ƒÁƒÂf;Ãuï‹Eì;Ãt.‹ ;Ãt(PÿÖ;Ãv!‹Eì;Ãt‹ë3É‹U·f‰ƒÁƒÂf;Ãuï‹};ût4‹;Ãt.PÿÖ‹};Ãv$;ût‹ë3É‹U›    ·f‰ƒÁƒÂf;Ãuï‹uà;ót,‹;Ãt&Pÿ\;Ãv‹‹U‹ÿ·f‰ƒÁƒÂf;Ãuï‹};ó‹D€ÇEÈ   t3NQÿÓ…Àu&‹…ÀtPÿd‹F…Àt	Pè+  ƒÄVèí*  ƒÄ‹}…ÿt=‹÷ƒÇWÿÓ…Àu*…öt&‹…ÀtPÿd‹F…Àt	PèD+  ƒÄVè°*  ƒÄÇE    ƒ}ì t>‹uìVRÿÓ…Àu*…öt&‹…ÀtPÿd‹F…Àt	Pè +  ƒÄVèl*  ƒÄÇEì    ƒ}è t>‹uèFPÿÓ…Àu*…öt&‹…ÀtPÿd‹F…Àt	Pè¼*  ƒÄVè(*  ƒÄÇEè    ƒ}ä t7‹uäNQÿÓ…Àu*…öt&‹…ÀtPÿd‹F…Àt	Pèx*  ƒÄVèä)  ƒÄ‹EÜ‹5d…ÀtPÿÖ‹EØ…ÀtPÿÖ‹EÔ…ÀtPÿÖ‹EĞ…ÀtPÿÖ‹EÌ…ÀtPÿÖ‹EÈ‹Môd‰    Y_^[‹å]Â ¸&e ÃÌÌÌÌÌÌÌÌÌÌÌÌÌU‹ìjÿhĞmd¡    Pƒì,SVW¡pğ3ÅPEôd£    ‰eğ‹ñ3Û‰]ü‹F4P‰]Ìè2Öÿÿ;Ãu3À‹Môd‰    Y_^[‹å]Â ‹v4;ó„3  ‹UäR‹U EÈPREĞPUÔREØPUÜR‹UEàP‹ARV‰]äÿĞ;Ã}hôVPè>'  ƒÉÿf;Mä…¯  ‹}àUèRèÅ  EìÆEü‹}ÜPèµ  MÆEü‹}ØQè¥  U ÆEü‹}ÔRè•  EäÆEü‹}ĞPè…  ‹Eè;Ãt6‹ ;Ãt0‹5\PÿÖ;Ãv)‹Eè;Ãt‹ë3É‹U·f‰ƒÁƒÂf;Ãuïë‹5\‹Eì;Ãt.‹ ;Ãt(PÿÖ;Ãv!‹Eì;Ãt‹ë3É‹U·f‰ƒÁƒÂf;Ãuï‹E;Ãt.‹ ;Ãt(PÿÖ;Ãv!‹E;Ãt‹ë3É‹U·f‰ƒÁƒÂf;Ãuï‹} ;ût2‹;Ãt,PÿÖ‹} ;Ãv";ût‹ë3É‹Ud$ ·f‰ƒÁƒÂf;Ãuï‹uä;ót,‹;Ãt&Pÿ\;Ãv‹‹U‹ÿ·f‰ƒÁƒÂf;Ãuï‹} ;ó‹D€ÇEÌ   t3NQÿÓ…Àu&‹…ÀtPÿd‹F…Àt	PèÁ'  ƒÄVè-'  ƒÄ‹} …ÿt=‹÷ƒÇWÿÓ…Àu*…öt&‹…ÀtPÿd‹F…Àt	Pè„'  ƒÄVèğ&  ƒÄÇE     ƒ} t>‹uVRÿÓ…Àu*…öt&‹…ÀtPÿd‹F…Àt	Pè@'  ƒÄVè¬&  ƒÄÇE    ƒ}ì t>‹uìFPÿÓ…Àu*…öt&‹…ÀtPÿd‹F…Àt	Pèü&  ƒÄVèh&  ƒÄÇEì    ƒ}è t7‹uèNQÿÓ…Àu*…öt&‹…ÀtPÿd‹F…Àt	Pè¸&  ƒÄVè$&  ƒÄ‹Eà‹5d…ÀtPÿÖ‹EÜ…ÀtPÿÖ‹EØ…ÀtPÿÖ‹EÔ…ÀtPÿÖ‹EĞ…ÀtPÿÖ‹EÌ‹Môd‰    Y_^[‹å]Â ¸æh ÃÌÌÌÌÌÌÌÌÌÌÌÌÌU‹ìjÿhmd¡    PƒìSVW¡pğ3ÅPEôd£    ‰eğ‹ñ3Û‰]ü‹F83ÿP‰}ìèpÒÿÿ;Ãu3À‹Môd‰    Y_^[‹å]Â 9^8tU‹}Q‹Ì‰eèQèR  ‹}QÆEü‹Ô‰eRè?  ‹}Q‹Ä‰ePÆEüè,  ‹MQˆ]ü‹N8è­«ÿÿ·À¿øë	¸Ái Ã‹}ì‹Ç‹Môd‰    Y_^[‹å]Â ÌÌÌÌÌÌU‹ìjÿh`md¡    PƒìSVW¡pğ3ÅPEôd£    ‰eğ‹ñÇEü    ‹F<PƒÏÿè Ñÿÿ…Àt?ƒ~< t‹}Q‹Ì‰eìQè—  ‹U‹N<Rè»¯ÿÿ‹ø‹Ç‹Môd‰    Y_^[‹å]Â ¸cj ÃƒÈÿ‹Môd‰    Y_^[‹å]Â ÌÌÌÌÌÌU‹ìjÿh@md¡    PƒìSVW¡pğ3ÅPEôd£    ‰eğ‹ñÇEü    ‹F<PƒÏÿè Ñÿÿ…Àt?ƒ~< t‹}Q‹Ì‰eìQè÷  ‹U‹N<RèÛ¯ÿÿ‹ø‹Ç‹Môd‰    Y_^[‹å]Â ¸k ÃƒÈÿ‹Môd‰    Y_^[‹å]Â ÌÌÌÌÌÌU‹ìjÿh md¡    PQSVW¡pğ3ÅPEôd£    ‰eğ‹ñÇEü    ‹F<PƒÏÿèbĞÿÿ…ÀtGƒ~< t%‹M‹U‹}QRQ‹Ä‰ePèQ  ‹MQ‹N<èõ¯ÿÿ‹ø‹Ç‹Môd‰    Y_^[‹å]Â ¸©k ÃƒÈÿ‹Môd‰    Y_^[‹å]Â U‹ìjÿh md¡    PƒìSVW¡pğ3ÅPEôd£    ‰eğ‹ñÇEü    ‹F<PƒÏÿèÀÏÿÿ…Àt?ƒ~< t‹}Q‹Ì‰eìQè·  ‹U‹N<Rè+°ÿÿ‹ø‹Ç‹Môd‰    Y_^[‹å]Â ¸Cl ÃƒÈÿ‹Môd‰    Y_^[‹å]Â ÌÌÌÌÌÌU‹ìjÿhØld¡    PƒìSVW¡pğ3ÅPEôd£    ‰eğ‹ñ3Û‰]ü‹F@3ÿP‰}ìè Ïÿÿ;Ãu3À‹Môd‰    Y_^[‹å]Â  9^@„’   ‹M$‹} QQ‹Ô‰e$Rèú  QÆEü‹}‹Ä‰e Pèç  QÆEü‹}‹Ì‰eQèÔ  QÆEü‹}‹Ô‰eRèÁ  ‹}QÆEü‹Ä‰ePè®  ‹}Q‹Ì‰eQÆEüè›  ‹Uˆ]ü‹N@RèŒ©ÿÿ·À¿øë	¸Rm Ã‹}ì‹Ç‹Môd‰    Y_^[‹å]Â  ÌÌÌÌÌ3À…Étùÿÿÿv¸W €…À|?VWqÿ‹L$D$PQVS3ÿèJ&  ƒÄ…À|;Æwu3Ò‹Ç_f‰s^Ã3Àf‰s¿z €‹Ç_^ÃÌÌÌÌÌÌÌÌÌjÿhëgd¡    PUV¡pğ3ÄPD$d£    ‹l$…Ût‹E …Àt‹ ë3À;Ã„¦   ‹u …öt?FPÿD€…Àu*…öt&‹…ÀtPÿd‹F…Àt	Pè!  ƒÄVè„   ƒÄÇE     jè™   ‹ğƒÄ‰t$ÇD$    …öt)SÇF    ÇF   ÿ`‰…Àu…Ûth €èv  3öÇD$ÿÿÿÿ‰u …öu
h €è[  ‹Å‹L$d‰    Y^]ƒÄÂ ÌÌÌÌÌjÿhëgd¡    PUV¡pğ3ÄPD$d£    ‹l$jèø  ‹ğƒÄ‰t$ÇD$    …öt)WÇF    ÇF   ÿ`‰…Àu…ÿth €èÕ  3öÇD$ÿÿÿÿ‰u …öu
h €èº  ‹Å‹L$d‰    Y^]ƒÄÂ ÌÌÌÌ;ûtXV‹7…öt>FPÿD€…Àu*…öt&‹…ÀtPÿd‹F…Àt	Pè³  ƒÄVè  ƒÄÇ    ‹‰^…Àt
ƒÀPÿ<€‹ÇÃÌ‹ ‰…Àt
ƒÀPÿ<€‹ÆÃÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌV‹7…öt>FPÿD€…Àu*…öt&‹…ÀtPÿd‹F…Àt	Pè'  ƒÄVè“  ƒÄÇ    ^ÃÌÌÌÌÌÌÌÌÌjÿh»gd¡    PQ¡pğ3ÄPD$d£    jè}  ƒÄ…Àt‹L$Ç@    Ç@   ‰ë3ÀÇD$ÿÿÿÿ‰…Àu
h €èa  ‹Æ‹L$d‰    YƒÄÂ ÌÌÌÌÌÌÌÌÌÌÌÌÌ¡ü…Àu5j|è  ƒÄ…Àt‹ÈèòÅÿÿ‹L$£ü‰HlÂ ‹L$3À£ü‰HlÂ ‹T$‰PlÂ ÌÌÌÌÌÌÌÌèË  ‹L$‰HÂ Ìè»  ‹L$‰HÂ Ìè«  ‹L$‰HÂ Ìè›  ‹L$‰HÂ Ìè‹  ‹L$‰HÂ Ìè{  ‹L$‰HÂ Ìèk  ‹L$‰HÂ Ìè[  ‹L$‰H Â Ì¡ü…Àuj|èE  ƒÄ…Àt	‹Èè"Åÿÿë3À£ü‹L$S‹\$V‹ğVdR‰H`èñûÿÿ‹\$ƒÆhVèäûÿÿ^[Â ÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌ¡ü…Àu(j|èå  ƒÄ…Àt‹ÈèÂÄÿÿ£ü‹ÈéöÑÿÿ3À£ü‹ÈéèÑÿÿÌÌÌÌÌÌÌÌ¡ü…Àu(j|è¥  ƒÄ…Àt‹Èè‚Äÿÿ£ü‹Èé†Õÿÿ3À£ü‹ÈéxÕÿÿÌÌÌÌÌÌÌÌ¡ü…Àu(j|èe  ƒÄ…Àt‹ÈèBÄÿÿ£ü‹ÈéæÕÿÿ3À£ü‹ÈéØÕÿÿÌÌÌÌÌÌÌÌ¡ü…Àu(j|è%  ƒÄ…Àt‹ÈèÄÿÿ£ü‹Èé¶×ÿÿ3À£ü‹Èé¨×ÿÿÌÌÌÌÌÌÌÌ¡ü…Àu(j|èå  ƒÄ…Àt‹ÈèÂÃÿÿ£ü‹Èé6Øÿÿ3À£ü‹Èé(ØÿÿÌÌÌÌÌÌÌÌ¡ü…Àu(j|è¥  ƒÄ…Àt‹Èè‚Ãÿÿ£ü‹Èé¶Øÿÿ3À£ü‹Èé¨ØÿÿÌÌÌÌÌÌÌÌ¡ü…Àu(j|èe  ƒÄ…Àt‹ÈèBÃÿÿ£ü‹Èé¶Úÿÿ3À£ü‹Èé¨ÚÿÿÌÌÌÌÌÌÌÌ¡ü…Àu(j|è%  ƒÄ…Àt‹ÈèÃÿÿ£ü‹Èé6Ûÿÿ3À£ü‹Èé(ÛÿÿÌÌÌÌÌÌÌÌ¡ü…Àu(j|èå  ƒÄ…Àt‹ÈèÂÂÿÿ£ü‹Èé¶âÿÿ3À£ü‹Èé¨âÿÿÌÌÌÌÌÌÌÌ¡ü…Àu(j|è¥  ƒÄ…Àt‹Èè‚Âÿÿ£ü‹Èé&äÿÿ3À£ü‹ÈéäÿÿÌÌÌÌÌÌÌÌ¡ü…Àu(j|èe  ƒÄ…Àt‹ÈèBÂÿÿ£ü‹ÈéVÛÿÿ3À£ü‹ÈéHÛÿÿÌÌÌÌÌÌÌÌ¡ü…Àu(j|è%  ƒÄ…Àt‹ÈèÂÿÿ£ü‹ÈéöÛÿÿ3À£ü‹ÈéèÛÿÿÌÌÌÌÌÌÌÌ¡ü…Àu(j|èå  ƒÄ…Àt‹ÈèÂÁÿÿ£ü‹ÈéFÜÿÿ3À£ü‹Èé8ÜÿÿÌÌÌÌÌÌÌÌ¡ü…Àu(j|è¥  ƒÄ…Àt‹Èè‚Áÿÿ£ü‹Èé†Üÿÿ3À£ü‹ÈéxÜÿÿÌÌÌÌÌÌÌÌ¡ü…Àu(j|èe  ƒÄ…Àt‹ÈèBÁÿÿ£ü‹ÈéÆÜÿÿ3À£ü‹Èé¸ÜÿÿÌÌÌÌÌÌÌÌ¡ü…Àu(j|è%  ƒÄ…Àt‹ÈèÁÿÿ£ü‹Èéİÿÿ3À£ü‹ÈéøÜÿÿÌÌÌÌÌÌÌÌ¡ü…Àu(j|èå  ƒÄ…Àt‹ÈèÂÀÿÿ£ü‹Èé†İÿÿ3À£ü‹ÈéxİÿÿÌÌÌÌÌÌÌÌ¡ü…Àu(j|è¥  ƒÄ…Àt‹Èè‚Àÿÿ£ü‹ÈéÖİÿÿ3À£ü‹ÈéÈİÿÿÌÌÌÌÌÌÌÌ¡ü…Àu(j|èe  ƒÄ…Àt‹ÈèBÀÿÿ£ü‹ÈéVŞÿÿ3À£ü‹ÈéHŞÿÿÌÌÌÌÌÌÌÌ¡ü…Àu(j|è%  ƒÄ…Àt‹ÈèÀÿÿ£ü‹ÈéÖŞÿÿ3À£ü‹ÈéÈŞÿÿÌÌÌÌÌÌÌÌ¡ü…Àu(j|èå  ƒÄ…Àt‹ÈèÂ¿ÿÿ£ü‹Èéfêÿÿ3À£ü‹ÈéXêÿÿÌÌÌÌÌÌÌÌ¡ü…Àu(j|è¥  ƒÄ…Àt‹Èè‚¿ÿÿ£ü‹Èéæíÿÿ3À£ü‹ÈéØíÿÿÌÌÌÌÌÌÌÌ¡ü…Àu(j|èe  ƒÄ…Àt‹ÈèB¿ÿÿ£ü‹Èé¶Şÿÿ3À£ü‹Èé¨ŞÿÿÌÌÌÌÌÌÌÌ¡ü…Àu(j|è%  ƒÄ…Àt‹Èè¿ÿÿ£ü‹Èé&ñÿÿ3À£ü‹ÈéñÿÿÌÌÌÌÌÌÌÌ¡ü…Àu(j|èå  ƒÄ…Àt‹ÈèÂ¾ÿÿ£ü‹Èé¶ñÿÿ3À£ü‹Èé¨ñÿÿÌÌÌÌÌÌÌÌ¡ü…Àu(j|è¥  ƒÄ…Àt‹Èè‚¾ÿÿ£ü‹Èéòÿÿ3À£ü‹ÈéòÿÿÌÌÌÌÌÌÌÌ¡ü…Àu(j|èe  ƒÄ…Àt‹ÈèB¾ÿÿ£ü‹Èévòÿÿ3À£ü‹ÈéhòÿÿÌÌÌÌÌÌÌÌ¡ü…Àu(j|è%  ƒÄ…Àt‹Èè¾ÿÿ£ü‹ÈéÖòÿÿ3À£ü‹ÈéÈòÿÿÌÌÌÌÌÌÌÌ¡ü…Àu(j|èå  ƒÄ…Àt‹ÈèÂ½ÿÿ£ü‹Èé6óÿÿ3À£ü‹Èé(óÿÿÌÌÌÌÌÌÌÌ¡ü…Àu(j|è¥  ƒÄ…Àt‹Èè‚½ÿÿ£ü‹Èéößÿÿ3À£ü‹ÈéèßÿÿÌÌÌÌÌÌÌÌ¡ü…Àu(j|èe  ƒÄ…Àt‹ÈèB½ÿÿ£ü‹Èé¦àÿÿ3À£ü‹Èé˜àÿÿÌÌÌÌÌÌÌÌ¡ü…Àu(j|è%  ƒÄ…Àt‹Èè½ÿÿ£ü‹Èé&áÿÿ3À£ü‹ÈéáÿÿÌÌÌÌÌÌÌÌ¡ü…Àu(j|èå  ƒÄ…Àt‹ÈèÂ¼ÿÿ£ü‹Èéäÿÿ3À£ü‹ÈéøãÿÿÌÌÌÌÌÌÌÌ¡ü…Àu(j|è¥  ƒÄ…Àt‹Èè‚¼ÿÿ£ü‹ÈéFäÿÿ3À£ü‹Èé8äÿÿÌÌÌÌÌÌÌÌ¡ü…Àu(j|èe  ƒÄ…Àt‹ÈèB¼ÿÿ£ü‹Èé†äÿÿ3À£ü‹ÈéxäÿÿÌÌÌÌÌÌÌÌ¡ü…Àu(j|è%  ƒÄ…Àt‹Èè¼ÿÿ£ü‹ÈéÆäÿÿ3À£ü‹Èé¸äÿÿÌÌÌÌÌÌÌÌ¡ü…Àu(j|èå  ƒÄ…Àt‹ÈèÂ»ÿÿ£ü‹ÈéFåÿÿ3À£ü‹Èé8åÿÿÌÌÌÌÌÌÌÌ¡ü…Àu(j|è¥  ƒÄ…Àt‹Èè‚»ÿÿ£ü‹Èé–åÿÿ3À£ü‹ÈéˆåÿÿÌÌÌÌÌÌÌÌS‹ÚW‰F‹ùÇŒÇF    F…Ût;ºÿ   +ØŠÿşÿ…Ét·f…Étf‰ƒÀƒêuâƒèf‰ë…Òuƒè3Òf‰ëh   j Pè›%  ƒÄ†  …ÿtHºÿ  +ø¤$    Šÿûÿ…Ét·f…Étf‰ƒÀƒêuâƒè_f‰‹Æ[Ã…Òuƒè3Ò_f‰‹Æ[Ãh   j Pè9%  ƒÄ_‹Æ[ÃÌöD$V‹ñÇŒt	Vèi  ƒÄ‹Æ^Â ÌVW‹ùG$PÇ¨ÿ,€wè4  ‹Qè;  ƒÄöD$t	Wè+  ƒÄ‹Ç_^Â ÌÌƒìVh¸ÿ€‹´3ö…Étm¡°È‹ğ;Ávèı  ‹˜D$‰T$‰t$èl  ƒ=´ ‹0t9¡°‹¬@    £°;Ğw
Ç°    ƒ-´u
Ç°    h¸ÿ€‹Æ^ƒÄÃÌÌÌÌÌÌS‹Ø‹C‹KÈöÁuƒÀÁè9Cwè°   ‹CVW‹{{‹÷Áî;Æw+ğ‹Sƒ<² ujè_  ‹KƒÄ‰±‹S‹²ƒç¸_^…Àt‹L$‹‰ÿC[Â S3Û9^t‹F;ÃtH‰F;Ãu‰^9^uéW‹~;ûv‹FO9¸¸t‹QèÔ  ƒÄ;ûwå‹F_;Ãt	Pè¿  ƒÄ‰^‰^[ÃÌÌÌÌÌƒì‹C¹ÿÿÿ+ÈÇ$   ƒùsèB  ‹ÈÑéƒùs¹   ëƒùvºÿÿÿ+Ñ;Âw‰$‹$U‹kVWÈÁíèŒ  ‹K‰D$4­    <‹CÀÀ+ÂÁÁø…    ù…ÀvQR‹T$QPèm  ƒÄ‹D$;èw@‹CÁşµ    9‰T$…övQPQWèA  ƒÄ‹L$+Ít‹|$3Àó«…ívb‹|$‹ÍëV‹K,…    ‹ÅÁø…ÀvÀÀPQPWè  ƒÄ‹C‹T$(+ñğÁşµ    <…övPQPRè×  ƒÄ‹L$…Év3Àó«‹C_^]…Àt	Pèg  ƒÄ‹D$‹$K‰CƒÄÃÌÌÌÌU‹ìƒäøjÿhˆld¡    PƒìL¡pğ3ÄPD$Pd£    jhL$ÇD$(   ÇD$$    ÆD$ è  D$PL$(ÇD$\    èl  h€¬L$(QÇD$,8‚èĞ  ÌÌÌÌÌƒì…Éw3É    Rèß  ƒÄƒÄÃƒÈÿ3Ò÷ñƒøsà$PL$ÇD$    èÑ  h¸¬L$QÇD$ ‚èv  ÌÌÌÌÌÌÌÌÌÌÌSV‹ğ‹FW‹øƒà‹Ø‹Áï…Àuè]  ‹…Àt‹ë3É…Àt‹ ë3À‹@A9Frè7  ‹6…öt‹ë3À9xw…öt‹ë3À+x…öt‹6‹N‹¹_^š[Ã3ö‹N‹¹_^š[ÃÌÌÌÌÌÌÌÌÌÌÌÌÌ‹D$VP‹ñè   Ç8‚‹Æ^Â ÌÌÌÌÌÌÌjÿhøjd¡    PQVW¡pğ3ÄPD$d£    ‹ñ‰t$‹|$ Wè<  3Ò‰T$jÿNÇ,‚GRÇA   ‰QPˆQè  ‹Æ‹L$d‰    Y_^ƒÄÂ ÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌ‹T$V‹ñ‹ÂWÇF   ÇF    ÆF xŠ@„Éuù+ÇPR‹Îè   _‹Æ^Â ÌÌÌÌÌÌÌU‹l$VW‹ñ…ítF‹VFƒúr‹ë‹È;ér1ƒúr‹ë‹È‹~ù;ıvƒúr‹ ‹L$Q+èUV‹ÎèS  _^]Â ‹|$ƒÿşvèR
  ‹F;Çs ‹VRW‹Îè¼  …ÿvV‹NS^ƒùr,‹ë*…ÿuê‰~ƒør‹F_Æ  ‹Æ^]Â F_Æ  ‹Æ^]Â ‹ÃWUQPèö  ƒÄƒ~‰~r‹Æ; [_‹Æ^]Â ÌÌÌÌÌÌÌÌÌÌS‹\$V‹ñW9^sèø	  ‹F‹|$+Ã;Çs‹ø…ÿvU‹NUnƒùr	‹U ‰T$ë‰l$ƒùr‹U ë‹Õ+ÇP‹D$ÃÇP+ËQÓRè  ‹F+ÇƒÄƒ~‰Fr‹m Æ( ]_‹Æ^[Â ÌÌÌÌÌÌÌÌÌÌÌÌÌÇ ‚é‘  ÌÌÌÌÌV‹ñÇ ‚è~  öD$t	Vèd  ƒÄ‹Æ^Â ÌÌÌÌÌÌÌÌÌÌÌÌ‹D$VP‹ñèò  Ç ‚‹Æ^Â ÌÌÌÌÌÌÌ‹L$ƒì…Éw3ÉQèB  ƒÄƒÄÂ ƒÈÿ3Ò÷ñƒøsåD$PL$ÇD$    è1  h¸¬L$QÇD$ ‚èÖ  ÌÌÌÌÌÌÌÌÌÌÌU‹ìjÿhPhd¡    PƒìSVW¡pğ3ÅPEôd£    ‰eğ‹ù‰}ì‹E‹ğƒÎƒşşv‹ğë"‹_¸«ªªª÷æ‹ËÑéÑê;Ñs¸şÿÿÿ+Á;Øw43ÛN‰]ü;Ëw3ÉQè~
  ƒÄ‰EëVƒÈÿ3Ò÷ñƒøsæMèQMØ‰]èèu  h¸¬UØRÇEØ ‚è  ‹E‹Mì‰Eä@‰eğPÆEüèÚşÿÿ‰E¸Ï„ Ã‹}ì‹uä‹]…Ûv ƒr‹GëG‹MSPFPQèˆ  ƒÄƒr‹WRèÄ	  ƒÄ‹MGÆ  ‰‰w‰_ƒşr‹ÁÆ ‹Môd‰    Y_^[‹å]Â ‹uìƒ~r‹FPè	  ƒÄj ÇF   ÇF    j ÆF è]  ÌÌS‹\$U‹l$VW‹ñ9ksè3  ‹{‹D$+ı;Çs‹ø;óujÿıW‹Îè	ıÿÿUj ‹Îèÿüÿÿ_‹Æ^][Â ƒÿşvè¿  ‹F;Çs‹FPW‹Îè)şÿÿ…ÿvfƒ{r/‹Së-…ÿuï‰~ƒør‹F_Æ  ‹Æ^][Â F_Æ  ‹Æ^][Â S‹N^ƒùr‹ë‹ÃWÕRQPèR  ƒÄƒ~‰~r‹Æ; _‹Æ^][Â ÌÌÌÌÌÌjÿh8ld¡    PQV¡pğ3ÄPD$d£    ‹ñ‰t$è  3À‰D$NÇ,‚jÿ‰AÇA   PˆA‹D$$PèÊşÿÿ‹Æ‹L$d‰    Y^ƒÄÂ ÌÌÌÌÌV‹ñƒ~r‹FPèı  ƒÄ3ÀÇF   ‰FˆF^ÃÌÌÌÌÌÌÌÌÌÌV‹ñÇ,‚ƒ~$r‹FPèÇ  ƒÄ3ÀÇF$   ‰F ˆF‹Î^éº  ÌÌÌÌÌÌÌÌÌÌÌÌÌÌV‹ñÇ,‚ƒ~$r‹FPè‡  ƒÄ3ÀÇF$   ‰F ‹ÎˆFè{  öD$t	Vèa  ƒÄ‹Æ^Â ÌÌÌÌÌÌÌÌÌƒy$r‹AÃAÃÌÌ‹D$VP‹ñè³şÿÿÇ8‚‹Æ^Â ÌÌÌÌÌÌÌ¸   Â ÌÌÌÌÌÌÌÌöD$V‹ñÇÀÇF    t	Vèò  ƒÄ‹Æ^Â ÌÌÌÌÌÌÌÌÌÌ¡V3ö;ÆuWj(èò  ƒÄ;Æt5Ç À‰p‰p‰p‰p‰p‰p‰p‰p ‰p$‹‹QP£ÿÒ¡^Ã3À‹‹QP£ÿÒ¡^ÃÌÌÌÌÌÌÌÌÌÌÌ‹…Ét‹‹P jÿÒÇ    ÃÌÌVW‹|$¹ü‹×3öè<  …Àu ¹‚‹×è,  …Àu¹ä‹×è  …Àt‹D$‹L$‰‹P‹BÿĞ_‹Æ^Â _¸@ €^Â ÌÌÌÌÌ‹D$ÿ@$‹@$Â ÌÌÌ‹L$ƒA$ÿ‹A$u‹‹P jÿÒ3ÀÂ ÌÌÌÌÌ¸   Â ÌÌÌÌÌÌÌÌ¸   Â ÌÌÌÌÌÌÌÌ¸   Â ÌÌÌÌÌÌÌÌ¸   Â$ ÌÌÌÌÌÌÌÌSV‹t$‹N…Ét]‹T$$ƒì‹Ä‰‹T$8‰P‹T$<‰P‹T$@‰P‹T$$ƒì‹Ä‰‹T$8‰P‹T$<‰P‹T$@‰P‹D$0PÿÑ‹L$43Òf…À”Âf‰‹Â^[Â, ‹\$4¸   f‰‹ü…Éu!j|è  ƒÄ…Àt	‹Èèû¬ÿÿë3À‹È‰ü‹D$ƒø‡¦  ÿ$…´‹ ‹v…ötÿÖ3Àf9”À^[Â, è´ÿÿ3Àf9”À^[Â, ‹v…ötÿÖf‰3Àf9”À^[Â, è´ÿÿf‰3Àf9”À^[Â, ‹v…öt‹L$,‹T$QRÿÖf‰3Àf9”À^[Â, 3À9At‹T$,‹I‹‹@R‹T$ RÿĞf‰3Àf9”À^[Â, ‹v…öt¿L$QÿÖ3Àf9”À^[Â, ¿T$RèÀ³ÿÿ3Àf9”À^[Â, ‹v3Àƒ|$,•À…ötP‹D$ PÿÖ3Àf9”À^[Â, ƒy „—   ‹I‹‹RP‹D$ PÿÒ3Àf9”À^[Â, ‹v3Àƒ|$,•À…ötP¿D$ PÿÖ3Àf9”À^[Â, ƒy tM‹I‹‹RP¿D$ PÿÒ3Àf9”À^[Â, ‹v …öt‹D$,‹L$PQÿÖ3Àf9”À^[Â, ‹T$,‹D$RPèL³ÿÿ3Àf9^”À[Â, I Š -Š [Š ©Š İŠ *‹ u‹ ¸   V‹2;1uƒèƒÁƒÂƒøsì3À3Ò…À”Â^‹ÂÃ¶¶1+Æu"¶B¶q+Æu¶B¶q+Æu
¶B¶I+ÁÁøƒÈ3Ò…À”Â^‹ÂÃ‹ÿU‹ìVÿu‹ñèúÿÿÇD‚‹Æ^]Â ÇD‚é”úÿÿ‹ÿU‹ìV‹ñÇD‚èúÿÿöEtVèT  Y‹Æ^]Â jD¸xgèn  hL‚MØèôôÿÿƒeü EØPM°èäúÿÿh€¬E°Pè  ÌjD¸xgè6  h\‚MØè¼ôÿÿƒeü EØPM°èPÿÿÿh¦E°PèÙ  Ì‹ÿU‹ìVÿu‹ñèôÿÿÇD‚‹Æ^]Â ‹ÿU‹ì‹Ej Pÿ$ğ]Â ÌÌÌÌÌÌÌÌÌÌÌ‹ÿU‹ìQ‹EÇEü    …ÀtM‹URht‚P‹ÿĞ…À|9‹E‹U‹VRP‹AÿĞ‹ğ‹E‹‹QPÿÒ…ö^uEüPj ÿh…ÀtÇEü    ‹Mü‹UQRÿ$ğ‹å]Â ÌÌÌÌÌÌÌÌÌÌÌ‹ÿV‹ñ‹FÇ„‚…Àt‹‹QPÿÒƒ~ tÿp€…Àt‹NQj Pÿl€^ÃÌÌÌÌÌÌÌ‹ÿU‹ìƒì‹E‹MhP¦UğRÇEğ„‚‰Eô‰MøÇEü    è«  ÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌ‹ÿU‹ì‹EV‹ñÇ„‚‹H‰N‹P‹Â‰VÇF    …Àt‹‹QPÿÒ‹Æ^]Â ÌÌÌÌÌÌÌ‹ÿU‹ìV‹ñ‹FÇ„‚…Àt‹‹QPÿÒƒ~ tÿp€…Àt‹NQj Pÿl€öEt	Vè   ƒÄ‹Æ^]Â ;pğuóÃé]  ‹ÿU‹ì]éX  ‹ÿVjhDğ‹ñèw  Ç ‚‹Æ^Ã‹ÿU‹ìƒìëÿuèá  Y…Àtÿuèû  Y…ÀtæÉÃö,¾ uƒ,‹Îè£ÿÿÿh@rè  YVMôè5ôÿÿh¸¬EôPèr  Ì‹ÿU‹ì]éjÿÿÿjhˆ¦è7  ƒeü ÿMx:‹M+M‰MÿUëí‹Eì‰Eä‹Eä‹ ‰Eà‹Eà8csmàtÇEÜ    ‹EÜÃè_  ‹eèÇEüşÿÿÿè-  Â jh¨¦èÙ  ƒeä ‹u‹Æ¯EEƒeü ÿMx)u‹MÿUëğÇEä   ÇEüşÿÿÿè   èâ  Â ƒ}ä uÿuÿuÿuÿuè@ÿÿÿÃ‹ÿU‹ìQSVWÿ5l!èB  ÿ5h!‹ø‰}üè2  ‹ğYY;÷‚ƒ   ‹Ş+ßCƒørwWèÀ  ‹øCY;øsH¸   ;øs‹ÇÇ;ÇrPÿuüèN  YY…ÀuG;Çr@Pÿuüè8  YY…Àt1ÁûP4˜èM  Y£l!ÿuè?  ‰ƒÆVè4  Y£h!‹EYë3À_^[ÉÃ‹ÿVjj è¢  ‹ğVè  ƒÄ£l!£h!…öujX^Ãƒ& 3À^ÃjhÈ¦è‹  èE  ƒeü ÿuèøşÿÿY‰EäÇEüşÿÿÿè	   ‹Eäè§  Ãè$  Ã‹ÿU‹ìÿuè·ÿÿÿ÷ØÀ÷ØYH]Ã‹ÿU‹ìƒ=Ü‚ thÜ‚èô  Y…ÀtÿÜ‚è   …ÀtPè¸  Yÿuÿx€Ìjhè¦èû  èS  ƒeü ÿpXÿPTPè¢ÿÿÿ‹Eì‹‹	‰MäPQè[   YYÃ‹eèÿuäèŠ  Ì‹ÿU‹ìVè*  è  Pèÿ  …Àu*‹uVè  Pè@  …Àuÿt€Pÿx€ÿ|€‰ë‹M‹QT‰PT‹QX‰PX‹QQ‰PèŞ  ƒ=Ø‚ thØ‚è  Y…ÀtÿØ‚è=ÿÿÿÌ‹ÿU‹ìQSW‹}3Û‰]ü;ûuèr!  SSSSSÇ    è&  ƒÄ3Àë|Vè|  h  jèç  ‹ğYY;ótJèQ  ÿplVèè  ‹EƒNÿ‰FX‹EYY‰~T;ÃuEPÿuVhâ‘ ÿuÿuÿ€€;Ãu ÿt€‰EüVè3  Y9]üt	ÿuüè	!  Y3À^_[ÉÃ‹ÿU‹ìƒì S3Û9]u èÆ   SSSSSÇ    èz  ƒÄƒÈÿé¡   ‹EV‹u;Ãt!;óuè—   SSSSSÇ    èK  ƒÄƒÈÿëtÇEìB   ‰uè‰uà=ÿÿÿ?v	ÇEäÿÿÿëÀ‰EäWÿuEàÿuÿuPè&#  ƒÄ‹ø;ót5ÿMäx
‹EàˆÿEàëEàPSèq   YYÿMäx‹EàˆëEàPSèY   YY‹Ç_^[ÉÃ‹ÿU‹ìÿuj ÿuÿuÿuèÿÿÿƒÄ]Ãÿ5äèk  Y…ÀtÿĞjè}/  jj èS/  ƒÄé4.  ‹ÿQÇŒ‚èQ1  YÃ‹ÿU‹ìV‹ñèãÿÿÿöEtVèvúÿÿY‹Æ^]Â ‹ÿU‹ì‹EƒÁ	QƒÀ	PèŠ1  ÷ØYÀY@]Â ‹ÿU‹ìV‹uW3ÿ;÷u3Àëe9}uèQ  j^‰0WWWWWè  ƒÄ‹ÆëE9}t9urVÿuÿuèÅ1  ƒÄëÁÿuWÿuè¤  ƒÄ9}t¶9usè  j"Y‰‹ñë­jX_^]Ã‹Áƒ` ƒ` Ç ”‚Ã‹ÿU‹ìS‹]VW‹ùÇ”‚‹…Àt&Pè  ‹ğFVèØ  YY‰G…Àtÿ3VPè¬4  ƒÄëƒg ÇG   ‹Ç_^[]Â ‹ÿU‹ì‹Á‹MÇ ”‚‹	ƒ` ‰H]Â ‹ÿU‹ìS‹]V‹ñÇ”‚‹C‰F…À‹CWt1…Àt'Pè—  ‹øGWè]  YY‰F…ÀtÿsWPè04  ƒÄë	ƒf ë‰F_‹Æ^[]Â ƒy Ç”‚t	ÿqèB  YÃ‹A…Àu¸œ‚Ã‹ÿU‹ìV‹ñèĞÿÿÿöEtVè·øÿÿY‹Æ^]Â ‹ÿU‹ì‹EVW3ÿ;ÇtG9}uè¶  j^‰0WWWWWèk  ƒÄ‹Æë)9}tà9Esè‘  j"Y‰‹ñë×Pÿuÿuèì3  ƒÄ3À_^]Ã‹ÿU‹ì‹E£0]Ã‹ÿU‹ìì(  ¡pğ3Å‰Eüƒ¥Øüÿÿ SjL…Üüÿÿj PèÇ
  …Øüÿÿ‰…(ıÿÿ…0ıÿÿƒÄ‰…,ıÿÿ‰…àıÿÿ‰Üıÿÿ‰•Øıÿÿ‰Ôıÿÿ‰µĞıÿÿ‰½ÌıÿÿfŒ•øıÿÿfŒìıÿÿfŒÈıÿÿfŒ…ÄıÿÿfŒ¥ÀıÿÿfŒ­¼ıÿÿœ…ğıÿÿ‹EMÇ…0ıÿÿ  ‰…èıÿÿ‰ôıÿÿ‹Iü‰äıÿÿÇ…Øüÿÿ ÀÇ…Üüÿÿ   ‰…äüÿÿÿ”€j ‹Øÿ€…(ıÿÿPÿŒ€…Àu…Ûujè16  Yh Àÿˆ€Pÿ„€‹Mü3Í[è÷ÿÿÉÃ‹ÿU‹ìÿ50è¸  Y…Àt]ÿàjèò5  Y]é²şÿÿ3ÀPPPPPèÎÿÿÿƒÄÃ‹ÿU‹ì‹EVWƒøu|Pè&=  Y…Àu3Àé  è¬  …Àuè<=  ëéè¹<  ÿ˜€£x!èr;  £8è“5  …À}è%  ëÏè:  …À| è8  …À|j è\  Y…Àuÿ4é¨   è®7  ëÉ3ÿ;Çu19=4~ÿ49=¼uèë  9}u{è7  èÃ  è«<  ëjƒøuYèa  h  jèÌ  ‹ğYY;÷„6ÿÿÿVÿ5€ğÿ5„èœ  YÿĞ…ÀtWVè·  YYÿ|€ƒNÿ‰ëVè.
  YéúşÿÿƒøuWè9  Y3À@_^]Â jh§è}  ‹ù‹ò‹]3À@‰Eä…öu94„Å   ƒeü ;ğtƒşu.¡°‚…ÀtWVSÿĞ‰Eäƒ}ä „–   WVSèrşÿÿ‰Eä…À„ƒ   WVSè%îÿÿ‰Eäƒşu$…Àu WPSèîÿÿWj SèBşÿÿ¡°‚…ÀtWj SÿĞ…ötƒşu&WVSè"şÿÿ…Àu!Eäƒ}ä t¡°‚…ÀtWVSÿĞ‰EäÇEüşÿÿÿ‹Eäë‹Eì‹‹	PQè  YYÃ‹eèÇEüşÿÿÿ3ÀèÙ  Ã‹ÿU‹ìƒ}uè¤;  ÿu‹M‹UèìşÿÿY]Â ÌÌÌÌÌÌÌÌ‹L$÷Á   t$ŠƒÁ„ÀtN÷Á   uï    ¤$    ¤$    ‹ºÿşş~Ğƒğÿ3ÂƒÁ© tè‹Aü„Àt2„ät$©  ÿ t©   ÿtëÍAÿ‹L$+ÁÃAş‹L$+ÁÃAı‹L$+ÁÃAü‹L$+ÁÃ‹ÿU‹ìƒì ‹EVWjY¾´‚}àó¥‰Eø‹E_‰Eü^…Àtö tÇEô @™EôPÿuğÿuäÿuàÿœ€ÉÂ ‹ÿU‹ìQS‹EƒÀ‰Eüd‹    ‹d£    ‹E‹]‹mü‹cüÿà[ÉÂ XY‡$ÿà‹ÿU‹ìQQSVWd‹5    ‰uüÇEø{› j ÿuÿuøÿuèãË  ‹E‹@ƒàı‹M‰Ad‹=    ‹]ü‰;d‰    _^[ÉÂ U‹ìƒìSVWü‰Eü3ÀPPPÿuüÿuÿuÿuÿuèhF  ƒÄ ‰Eø_^[‹Eø‹å]Ã‹ÿU‹ìVü‹u‹N3ÎèÒòÿÿj Vÿvÿvj ÿuÿvÿuè+F  ƒÄ ^]Ã‹ÿU‹ìƒì8S}#  u¸¸œ ‹M‰3À@é°   ƒeØ ÇEÜäœ ¡pğMØ3Á‰Eà‹E‰Eä‹E‰Eè‹E‰Eì‹E ‰Eğƒeô ƒeø ƒeü ‰eô‰mød¡    ‰EØEØd£    ÇEÈ   ‹E‰EÌ‹E‰EĞèh  ‹€€   ‰EÔEÌP‹Eÿ0ÿUÔYYƒeÈ ƒ}ü td‹    ‹‹]Ø‰d‰    ë	‹EØd£    ‹EÈ[ÉÃ‹ÿU‹ìQSü‹E‹H3MèÆñÿÿ‹E‹@ƒàft‹EÇ@$   3À@ëlëjj‹Eÿp‹Eÿp‹Eÿpj ÿu‹EÿpÿuèõD  ƒÄ ‹Eƒx$ uÿuÿuèüıÿÿj j j j j EüPh#  è¡şÿÿƒÄ‹Eü‹]‹c‹k ÿà3À@[ÉÃ‹ÿU‹ìQSVW‹}‹G‹w‰Eü‹Şë-ƒşÿuè¶  ‹MüN‹ÆkÀÁ‹M9H};H~ƒşÿu	ÿM‹]‰uƒ} }Ê‹EF‰0‹E‰;_w;óvèq  ‹ÆkÀEü_^[ÉÃ‹ÿU‹ì‹EV‹u‰èú
  ‹€˜   ‰Fèì
  ‰°˜   ‹Æ^]Ã‹ÿU‹ìè×
  ‹€˜   ë
‹;Mt
‹@…Àuò@]Ã3À]Ã‹ÿU‹ìVè¯
  ‹u;°˜   uèŸ
  ‹N‰ˆ˜   ^]Ãè
  ‹€˜   ë	‹H;ñt‹Áƒx uñ^]éÇ  ‹N‰HëÒ‹ÿU‹ìƒì¡pğƒeè Mè3Á‹M‰Eğ‹E‰Eô‹E@ÇEìÚ› ‰Mø‰Eüd¡    ‰EèEèd£    ÿuQÿuè2D  ‹È‹Eèd£    ‹ÁÉÃPdÿ5    D$+d$SVW‰(‹è¡pğ3ÅPÿuüÇEüÿÿÿÿEôd£    ÃPdÿ5    D$+d$SVW‰(‹è¡pğ3ÅP‰eğÿuüÇEüÿÿÿÿEôd£    Ã¸$î £PóÇTóå ÇXó¿ä Ç\óøä Ç`óaä £dóÇhóœí Çló}ä Çpóßã Çtólã Ã‹ÿU‹ìè–ÿÿÿèüN  ƒ} £LtèƒN  Ûâ]ÃÌÌÌÌÌÌÌ‹ÿU‹ìƒìS‹]V‹s35pğW‹ÆEÿ ÇEô   {ƒøşt‹NÏ38è—îÿÿ‹N‹FÏ38è‡îÿÿ‹Eö@f…  ‹MUè‰Sü‹[‰Eè‰Mìƒûşt_I [‹L†D†‰Eğ‹ ‰Eø…Ét‹×èpO  ÆEÿ…À|@G‹Eø‹ØƒøşuÎ€}ÿ t$‹ƒøşt‹NÏ38èîÿÿ‹N‹VÏ3:èîÿÿ‹Eô_^[‹å]ÃÇEô    ëÉ‹M9csmàu)ƒ=´‰ t h´‰èƒ  ƒÄ…Àt‹UjRÿ´‰ƒÄ‹MèO  ‹E9XthpğW‹Ó‹ÈèO  ‹E‹Mø‰H‹ƒøşt‹NÏ38èíÿÿ‹N‹VÏ3:èqíÿÿ‹Eğ‹H‹×è©N  ºşÿÿÿ9S„RÿÿÿhpğW‹ËèÁN  éÿÿÿÌÌÌÌ‹T$‹L$…Òti3ÀŠD$„Àuú   rƒ=<  téúN  W‹ùƒúr1÷Ùƒát+ÑˆƒÇƒéuö‹ÈÁàÁ‹ÈÁàÁ‹ÊƒâÁétó«…Òt
ˆƒÇƒêuö‹D$_Ã‹D$ÃÌÌÌÌÌÌQL$+ÈƒáÁÉÁYéêO  QL$+ÈƒáÁÉÁYéÔO  ‹ÿU‹ìì(  £X‰T‰P‰L‰5H‰=DfŒpfŒdfŒ@fŒ<fŒ%8fŒ-4œh‹E £\‹E£`E£l‹…àüÿÿÇ¨  ¡`£\ÇP	 ÀÇT   ¡pğ‰…Øüÿÿ¡tğ‰…Üüÿÿÿ”€£ jèÌ*  Yj ÿ€hà‚ÿŒ€ƒ=  ujè¨*  Yh	 Àÿˆ€Pÿ„€ÉÃjh(§èj  ‹u…ötuƒ=@ uCjèRP  Yƒeü VèzP  Y‰Eä…Àt	VPè›P  YYÇEüşÿÿÿè   ƒ}ä u7ÿuë
jè>O  YÃVj ÿ5üÿl€…ÀuèG  ‹ğÿt€Pè÷  ‰Yè.  ÃjhH§èÜ  ƒeä ‹u;5, w"jèÅO  Yƒeü VèÌW  Y‰EäÇEüşÿÿÿè	   ‹Eäèè  ÃjèÀN  YÃ‹ÿU‹ìV‹uƒşà‡¡   SW‹=¤€ƒ=ü uè!  jè^  hÿ   è
  YY¡@ ƒøu…öt‹Æë3À@PëƒøuVèSÿÿÿY…Àu…öuFƒÆƒæğVj ÿ5üÿ×‹Ø…Ûu.j^9TtÿuèG   Y…Àt‹ué{ÿÿÿè=  ‰0è6  ‰0_‹Ã[ëVè    Yè"  Ç    3À^]Ã‹ÿU‹ì‹E£t]Ã‹ÿU‹ìÿ5tè„  Y…ÀtÿuÿĞY…Àt3À@]Ã3À]Ãjhh§èŒ   èä  ‹@x…Àtƒeü ÿĞë3À@Ã‹eèÇEüşÿÿÿè!  è¥   Ãè·  ‹@|…ÀtÿĞé´ÿÿÿjhˆ§è@   ÿ5xè	  Y…Àtƒeü ÿĞë3À@Ã‹eèÇEüşÿÿÿè}ÿÿÿÌh¥ èc   Y£xÃÌÌÌhğŸ dÿ5    ‹D$‰l$l$+àSVW¡pğ1Eü3ÅP‰eèÿuø‹EüÇEüşÿÿÿ‰EøEğd£    Ã‹Mğd‰    Y__^[‹å]QÃ‹ÿU‹ìVÿ5„ğ‹5°€ÿÖ…Àt!¡€ğƒøÿtPÿ5„ğÿÖÿĞ…Àt‹€ø  ë'¾ø‚Vÿ¨€…ÀuVè{  Y…Àthè‚Pÿ¬€…ÀtÿuÿĞ‰E‹E^]Ãj è‡ÿÿÿYÃ‹ÿU‹ìVÿ5„ğ‹5°€ÿÖ…Àt!¡€ğƒøÿtPÿ5„ğÿÖÿĞ…Àt‹€ü  ë'¾ø‚Vÿ¨€…ÀuVè   Y…ÀthƒPÿ¬€…ÀtÿuÿĞ‰E‹E^]Ãÿ´€Â ‹ÿU‹ìÿuÿ5„ğÿ°€ÿĞ]Â ¡€ğÃ‹ÿVÿ5„ğÿ°€‹ğ…öuÿ5€èEÿÿÿY‹ğVÿ5„ğÿ¸€‹Æ^Ã‹ÿU‹ìÿuÿuÿ5„èÿÿÿYÿĞ]Â ¡€ğƒøÿtPÿ5ˆèşşÿÿYÿĞƒ€ğÿ¡„ğƒøÿtPÿ¼€ƒ„ğÿéÑJ  jh¨§è÷ıÿÿ¾ø‚Vÿ¨€…ÀuVè  Y‰Eä‹uÇF\xƒ3ÿG‰~…Àt$hè‚P‹¬€ÿÓ‰†ø  hƒÿuäÿÓ‰†ü  ‰~pÆ†È   CÆ†K  CÇFh˜õjè…K  Yƒeü ÿvhÿ<€ÇEüşÿÿÿè>   jèdK  Y‰}ü‹E‰Fl…Àu¡ˆõ‰Flÿvlè†W  YÇEüşÿÿÿè   èzıÿÿÃ3ÿG‹ujèLJ  YÃjèCJ  YÃ‹ÿVWÿt€ÿ5€ğ‹øètşÿÿÿĞ‹ğ…öuNh  jè×  ‹ğYY…öt:Vÿ5€ğÿ5„è«ıÿÿYÿĞ…Àtj VèÅşÿÿYYÿ|€ƒNÿ‰ë	Vè<úÿÿY3öWÿÀ€_‹Æ^Ã‹ÿVèÿÿÿ‹ğ…öujèá  Y‹Æ^ÃjhĞ§è}üÿÿ‹u…ö„ø   ‹F$…ÀtPèïùÿÿY‹F,…ÀtPèáùÿÿY‹F4…ÀtPèÓùÿÿY‹F<…ÀtPèÅùÿÿY‹F@…ÀtPè·ùÿÿY‹FD…ÀtPè©ùÿÿY‹FH…ÀtPè›ùÿÿY‹F\=xƒtPèŠùÿÿYjè÷I  Yƒeü ‹~h…ÿtWÿD€…Àuÿ˜õtWè]ùÿÿYÇEüşÿÿÿèW   jè¾I  YÇEü   ‹~l…ÿt#WèxV  Y;=ˆõtÿ°ôtƒ? uWè„T  YÇEüşÿÿÿè   VèùÿÿYèºûÿÿÂ ‹ujèH  YÃ‹ujèH  YÃ‹ÿU‹ìƒ=€ğÿtKƒ} u'Vÿ5„ğ‹5°€ÿÖ…Àtÿ5€ğÿ5„ğÿÖÿĞ‰E^j ÿ5€ğÿ5„èàûÿÿYÿĞÿuèxşÿÿ¡„ğƒøÿt	j Pÿ¸€]Ã‹ÿVW¾ø‚Vÿ¨€…ÀuVèõ  Y‹ø…ÿ„^  ‹5¬€hDƒWÿÖh8ƒW£|ÿÖh,ƒW£€ÿÖh$ƒW£„ÿÖƒ=| ‹5¸€£ˆtƒ=€ tƒ=„ t…Àu$¡°€£€¡¼€Ç|î¦ ‰5„£ˆÿ´€£„ğƒøÿ„Ì   ÿ5€PÿÖ…À„»   è  ÿ5|èhúÿÿÿ5€£|èXúÿÿÿ5„£€èHúÿÿÿ5ˆ£„è8úÿÿƒÄ£ˆèUF  …Àteh© ÿ5|è’úÿÿYÿĞ£€ğƒøÿtHh  jè‹   ‹ğYY…öt4Vÿ5€ğÿ5„è_úÿÿYÿĞ…Àtj VèyûÿÿYYÿ|€ƒNÿ‰3À@ëè$ûÿÿ3À_^Ã‹ÿU‹ìVW3öÿuèµ÷ÿÿ‹øY…ÿu'9ŒvVÿÄ€†è  ;ŒvƒÈÿ‹ğƒøÿuÊ‹Ç_^]Ã‹ÿU‹ìVW3öj ÿuÿuè\  ‹øƒÄ…ÿu'9ŒvVÿÄ€†è  ;ŒvƒÈÿ‹ğƒøÿuÃ‹Ç_^]Ã‹ÿU‹ìVW3öÿuÿuèÖ\  ‹øYY…ÿu,9Et'9ŒvVÿÄ€†è  ;ŒvƒÈÿ‹ğƒøÿuÁ‹Ç_^]Ãjhø§ètøÿÿ3À‹]3ÿ;ß•À;Çuè§  Ç    WWWWWè[êÿÿƒÄƒÈÿëSƒ=@ u8jè6F  Y‰}üSè_F  Y‰Eà;Çt‹süƒî	‰uäë‹uäÇEüşÿÿÿè%   9}àuSWÿ5üÿÈ€‹ğ‹Æè4øÿÿÃ3ÿ‹]‹uäjèE  YÃ‹ÿU‹ìW¿è  WÿÄ€ÿuÿ¨€Çè  ÿ`ê  w…ÀtŞ_]Ã‹ÿU‹ìèB  ÿuè  ÿ5ˆğèdøÿÿhÿ   ÿĞƒÄ]Ã‹ÿU‹ìh`ƒÿ¨€…ÀthPƒPÿ¬€…ÀtÿuÿĞ]Ã‹ÿU‹ìÿuèÈÿÿÿYÿuÿÌ€Ìjè9E  YÃjèVD  YÃ‹ÿU‹ìV‹ğë‹…ÀtÿĞƒÆ;urğ^]Ã‹ÿU‹ìV‹u3Àë…Àu‹…ÉtÿÑƒÆ;urì^]Ã‹ÿU‹ìƒ=Ô‚ thÔ‚è  Y…Àt
ÿuÿÔ‚Yèa?  h¨h”è¡ÿÿÿYY…ÀuBhÿÔ èHâÿÿ¸ˆÇ$ècÿÿÿƒ=t! Ytht!èF  Y…Àtj jj ÿt!3À]Ãjh¨è]öÿÿjèUD  Yƒeü 3ÛC9À„Å   ‰¼ŠE¢¸ƒ} …   ÿ5l!èóöÿÿY‹ø‰}Ø…ÿtxÿ5h!èŞöÿÿY‹ğ‰uÜ‰}ä‰uàƒî‰uÜ;÷rWèºöÿÿ9tí;÷rJÿ6è´öÿÿ‹øè¤öÿÿ‰ÿ×ÿ5l!èöÿÿ‹øÿ5h!è‘öÿÿƒÄ9}äu9Eàt‰}ä‰}Ø‰Eà‹ğ‰uÜ‹}ØëŸh¸¸¬è_şÿÿYhÀ¸¼èOşÿÿYÇEüşÿÿÿè   ƒ} u(‰ÀjèƒB  Yÿuèüıÿÿ3ÛCƒ} tjèjB  YÃèƒõÿÿÃ‹ÿU‹ìj jÿuèÃşÿÿƒÄ]Ãjj j è³şÿÿƒÄÃ‹ÿVèÛõÿÿ‹ğVè9ôÿÿVèZ]  VèÑåÿÿVèÎ  Vè9]  Vè![  Vèi  VèÊôÿÿhk° è-õÿÿƒÄ$£ˆğ^ÃÌÌ‹ÿU‹ì‹M¸MZ  f9t3À]Ã‹A<Á8PE  uï3Ò¹  f9H”Â‹Â]ÃÌÌÌÌÌÌÌÌÌÌÌ‹ÿU‹ì‹E‹H<È·ASV·q3ÒWD…öv‹}‹H;ùr	‹XÙ;ûr
BƒÀ(;Örè3À_^[]ÃÌÌÌÌÌÌÌÌÌÌÌÌ‹ÿU‹ìjşh8¨hğŸ d¡    PƒìSVW¡pğ1Eø3ÅPEğd£    ‰eèÇEü    h   è*ÿÿÿƒÄ…ÀtU‹E-   Ph   èPÿÿÿƒÄ…Àt;‹@$Áè÷ĞƒàÇEüşÿÿÿ‹Mğd‰    Y_^[‹å]Ã‹Eì‹‹3Ò=  À”Â‹ÂÃ‹eèÇEüşÿÿÿ3À‹Mğd‰    Y_^[‹å]ÃÃ‹ÿU‹ìQQVèQöÿÿ‹ğ…ö„F  ‹V\¡˜ğW‹}‹ÊS99t‹ØkÛƒÁÚ;ËrîkÀÂ;Ès99u‹Áë3À…Àt
‹X‰]ü…Ûu3Àéû   ƒûuƒ` 3À@éê   ƒû„Ş   ‹N`‰Mø‹M‰N`‹Hƒù…¸   ‹Œğ‹=ğ‹Ñù;×}$kÉ‹~\ƒd9 ‹=Œğ‹ğBßƒÁ;Ó|â‹]ü‹ ‹~d=  Àu	ÇFdƒ   ë^=  Àu	ÇFd   ëN=‘  Àu	ÇFd„   ë>=“  Àu	ÇFd…   ë.=  Àu	ÇFd‚   ë=  Àu	ÇFd†   ë=’  ÀuÇFdŠ   ÿvdjÿÓY‰~dëƒ` QÿÓ‹EøY‰F`ƒÈÿ[_^ÉÃ‹ÿU‹ì¸csmà9EuÿuPèˆşÿÿYY]Ã3À]Ã‹ÿU‹ì‹E3É;Í ğtAƒù-rñHíƒùwjX]Ã‹Í¤ğ]ÃDÿÿÿjY;ÈÀ#ÁƒÀ]Ãè—ôÿÿ…Àu¸òÃƒÀÃè„ôÿÿ…Àu¸òÃƒÀÃ‹ÿU‹ìVèâÿÿÿ‹MQ‰è‚ÿÿÿY‹ğè¼ÿÿÿ‰0^]Ã‹ÿU‹ìQV‹uVè5f  ‰E‹FY¨‚uè—ÿÿÿÇ 	   ƒN ƒÈÿé/  ¨@tè|ÿÿÿÇ "   ëãS3Û¨t‰^¨„‡   ‹Nƒàş‰‰F‹FƒàïƒÈ‰F‰^‰]ü©  u,èd  ƒÀ ;ğtèd  ƒÀ@;ğuÿuè“c  Y…ÀuVè?c  Y÷F  W„€   ‹F‹>H‰‹N+øI;û‰N~WPÿuè3b  ƒÄ‰EüëMƒÈ ‰FƒÈÿëy‹Mƒùÿtƒùşt‹Áƒà‹ÑÁúÁà•` ë¸àòö@ tjSSQèœY  #ÂƒÄƒøÿt%‹FŠMˆë3ÿGWEPÿuèÄa  ƒÄ‰Eü9}üt	ƒN ƒÈÿë‹E%ÿ   _[^ÉÃ‹ÿU‹ì‹EV‹ñÆF …ÀucèPóÿÿ‰F‹Hl‰‹Hh‰N‹;ˆõt‹8ı…HpuèpK  ‰‹F;Àùt‹F‹8ı…HpuèìM  ‰F‹Fö@puƒHpÆFë
‹‰‹@‰F‹Æ^]Â ‹ÿU‹ìö@@tƒx tPÿuèrd  YY¹ÿÿ  f;Áuƒÿ]Ãÿ]Ã‹ÿU‹ìV‹ğëÿu‹EÿMè¹ÿÿÿƒ>ÿYtƒ} æ^]Ã‹ÿU‹ìöG@SV‹ğ‹Ùt7ƒ u1‹Eë0·ÿMP‹Çè~ÿÿÿCCƒ>ÿYuè=ıÿÿƒ8*uj?‹ÇècÿÿÿYƒ} Ğ^[]Ã‹ÿU‹ììt  ¡pğ3Å‰Eü‹ES‹]V‹uWÿu3ÿ¨ûÿÿ‰…Ğûÿÿ‰äûÿÿ‰½¸ûÿÿ‰½øûÿÿ‰½Ôûÿÿ‰½ôûÿÿ‰½Üûÿÿ‰½Äûÿÿ‰½Øûÿÿèjşÿÿ9½Ğûÿÿu3è°üÿÿWWWWÇ    WèdàÿÿƒÄ€½´ûÿÿ t
‹…°ûÿÿƒ`pıƒÈÿéÄ
  ;÷tÉ·3É‰½àûÿÿ‰½ìûÿÿ‰½¼ûÿÿ‰•èûÿÿf;×„
  j_÷ƒ½àûÿÿ ‰µÀûÿÿŒi
  BàfƒøXw·Â¾€˜Šƒàë3À¾„Á¸ŠjÁøY‰…¤ûÿÿ;Á‡õ	  ÿ$…DÂ 3Àƒôûÿÿÿ‰… ûÿÿ‰…Äûÿÿ‰…Ôûÿÿ‰…Üûÿÿ‰…øûÿÿ‰…Øûÿÿé¼	  ·Âƒè tJƒèt6ƒèt%+Çtƒè…	  ƒøûÿÿé‘	  ƒøûÿÿé…	  ƒøûÿÿéy	  øûÿÿ€   éj	  	½øûÿÿé_	  fƒú*u,ƒÃ‰äûÿÿ‹[ü‰Ôûÿÿ…Û?	  ƒøûÿÿ÷Ôûÿÿé-	  ‹…ÔûÿÿkÀ
·ÊDĞ‰…Ôûÿÿé	  ƒ¥ôûÿÿ é	  fƒú*u&ƒÃ‰äûÿÿ‹[ü‰ôûÿÿ…Ûæ  ƒôûÿÿÿéÚ  ‹…ôûÿÿkÀ
·ÊDĞ‰…ôûÿÿé¿  ·ÂƒøItWƒøhtFƒøltƒøw…¤  øûÿÿ   é•  fƒ>lu÷øûÿÿ   ‰µÀûÿÿéx  ƒøûÿÿél  ƒøûÿÿ é`  ·fƒø6ufƒ~4uƒÆøûÿÿ €  ‰µÀûÿÿé8  fƒø3ufƒ~2uƒÆ¥øûÿÿÿÿÿ‰µÀûÿÿé  fƒød„	  fƒøi„ÿ  fƒøo„õ  fƒøu„ë  fƒøx„á  fƒøX„×  ƒ¥¤ûÿÿ ‹…ĞûÿÿRµàûÿÿÇ…Øûÿÿ   èıûÿÿé®  ·Âƒød/  „À  ƒøS  t~ƒèAt+ÇtY+Çt+Ç…ï  ƒÂ Ç… ûÿÿ   ‰•èûÿÿƒøûÿÿ@ƒ½ôûÿÿ µüûÿÿ¸   ‰µğûÿÿ‰…ìûÿÿ  Ç…ôûÿÿ   éì  ÷…øûÿÿ0  …È   ƒøûÿÿ é¼   ÷…øûÿÿ0  uƒøûÿÿ ‹½ôûÿÿƒÿÿu¿ÿÿÿƒÃö…øûÿÿ ‰äûÿÿ‹[ü‰ğûÿÿ„  …Ûu¡<ı‰…ğûÿÿƒ¥ìûÿÿ ‹µğûÿÿ…ÿ   Š„À„  ¨ûÿÿ¶ÀQPè7b  YY…ÀtFFÿ…ìûÿÿ9½ìûÿÿ|Ğéë  ƒèX„÷  +Ç„”   +Á„öşÿÿ+Ç…Ê  ·ƒÃ3öFö…øûÿÿ ‰µØûÿÿ‰äûÿÿ‰…œûÿÿtBˆ…Ìûÿÿ…¨ûÿÿP‹…¨ûÿÿÆ…Íûÿÿ ÿ°¬   …ÌûÿÿP…üûÿÿPès`  ƒÄ…À}‰µÄûÿÿëf‰…üûÿÿ…üûÿÿ‰…ğûÿÿ‰µìûÿÿéF  ‹ƒÃ‰äûÿÿ…Àt:‹H…Ét3÷…øûÿÿ   ¿ ‰ğûÿÿt™+ÂÇ…Øûÿÿ   é  ƒ¥Øûÿÿ é÷  ¡<ı‰…ğûÿÿPèßİÿÿYéà  ƒøpú  „â  ƒøeŒÎ  ƒøgéıÿÿƒøitqƒønt(ƒøo…²  ö…øûÿÿ€Ç…èûÿÿ   taøûÿÿ   ëU‹3ƒÃ‰äûÿÿèm_  …À„0  ö…øûÿÿ tf‹…àûÿÿf‰ë‹…àûÿÿ‰Ç…Äûÿÿ   éÁ  ƒøûÿÿ@Ç…èûÿÿ
   ÷…øûÿÿ €  „«  ‹‹SƒÃéç  ufƒúgucÇ…ôûÿÿ   ëW9…ôûÿÿ~‰…ôûÿÿ½ôûÿÿ£   ~=‹½ôûÿÿÇ]  Wèİîÿÿ‹•èûÿÿY‰…¼ûÿÿ…Àt‰…ğûÿÿ‰½ìûÿÿ‹ğë
Ç…ôûÿÿ£   ‹ƒÃ‰…”ûÿÿ‹Cü‰…˜ûÿÿ…¨ûÿÿPÿµ ûÿÿ¾Âÿµôûÿÿ‰äûÿÿPÿµìûÿÿ…”ûÿÿVPÿ5hóè›èÿÿYÿĞ‹øûÿÿƒÄã€   t!ƒ½ôûÿÿ u…¨ûÿÿPVÿ5tóèkèÿÿYÿĞYYfƒ½èûÿÿgu…Ûu…¨ûÿÿPVÿ5póèEèÿÿYÿĞYY€>-uøûÿÿ   F‰µğûÿÿVéşÿÿÇ…ôûÿÿ   ‰¸ûÿÿë$ƒès„güÿÿ+Ç„Šşÿÿƒè…É  Ç…¸ûÿÿ'   ö…øûÿÿ€Ç…èûÿÿ   „jşÿÿj0Xf‰…Èûÿÿ‹…¸ûÿÿƒÀQf‰…Êûÿÿ‰½ÜûÿÿéEşÿÿ÷…øûÿÿ   …EşÿÿƒÃö…øûÿÿ tö…øûÿÿ@‰äûÿÿt¿Cüë·Cü™ëö…øûÿÿ@‹Cüt™ë3Ò‰äûÿÿö…øûÿÿ@t…Ò|…Às÷ØƒÒ ÷Úøûÿÿ   ÷…øûÿÿ   ‹Ú‹øu3Ûƒ½ôûÿÿ }Ç…ôûÿÿ   ëƒ¥øûÿÿ÷¸   9…ôûÿÿ~‰…ôûÿÿ‹ÇÃu!…Üûÿÿµûıÿÿ‹…ôûÿÿÿôûÿÿ…À‹ÇÃt-‹…èûÿÿ™RPSWè^  ƒÁ0ƒù9‰ûÿÿ‹ø‹Ú~¸ûÿÿˆNë½…ûıÿÿ+ÆF÷…øûÿÿ   ‰…ìûÿÿ‰µğûÿÿtY…Àt‹Î€90tNÿğûÿÿ‹ğûÿÿÆ0@ë6…Ûu¡@ı‰…ğûÿÿ‹…ğûÿÿÇ…Øûÿÿ   ë	Ofƒ8 t@@…ÿuó+…ğûÿÿÑø‰…ìûÿÿƒ½Äûÿÿ …e  ‹…øûÿÿ¨@t+©   tj-ë¨tj+ë¨tj Xf‰…ÈûÿÿÇ…Üûÿÿ   ‹Ôûÿÿ‹µìûÿÿ+Ş+Üûÿÿö…øûÿÿuÿµĞûÿÿ…àûÿÿSj è“õÿÿƒÄÿµÜûÿÿ‹½Ğûÿÿ…àûÿÿÈûÿÿèšõÿÿö…øûÿÿYtö…øûÿÿuWSj0…àûÿÿèQõÿÿƒÄƒ½Øûÿÿ uu…ö~q‹½ğûÿÿ‰µèûÿÿÿèûÿÿ…¨ûÿÿP‹…¨ûÿÿÿ°¬   …œûÿÿWPè	[  ƒÄ‰…ûÿÿ…À~)ÿµœûÿÿ‹…Ğûÿÿµàûÿÿè¼ôÿÿ½ûÿÿƒ½èûÿÿ Y¦ëƒàûÿÿÿë‹ğûÿÿV…àûÿÿèåôÿÿYƒ½àûÿÿ | ö…øûÿÿtÿµĞûÿÿ…àûÿÿSj è—ôÿÿƒÄƒ½¼ûÿÿ tÿµ¼ûÿÿè_áÿÿƒ¥¼ûÿÿ Y‹µÀûÿÿ·‰…èûÿÿf…Àt*‹¤ûÿÿ‹äûÿÿ‹Ğé–õÿÿèéñÿÿÇ    3ÀPPPPPé2õÿÿ€½´ûÿÿ t
‹…°ûÿÿƒ`pı‹…àûÿÿ‹Mü_^3Í[èÌÿÿÉÃI º í· ¸ |¸ É¸ Õ¸ ¹ ,º ‹ÿU‹ìì(  ¡pğ3Å‰EüöòVtj
è  Yè¤I  …Àtjè¦I  Yöò„Ê   ‰…àıÿÿ‰Üıÿÿ‰•Øıÿÿ‰Ôıÿÿ‰µĞıÿÿ‰½ÌıÿÿfŒ•øıÿÿfŒìıÿÿfŒÈıÿÿfŒ…ÄıÿÿfŒ¥ÀıÿÿfŒ­¼ıÿÿœ…ğıÿÿ‹uE‰…ôıÿÿÇ…0ıÿÿ  ‰µèıÿÿ‹@üjP‰…äıÿÿ…Øüÿÿj PèMŞÿÿ…ØüÿÿƒÄ‰…(ıÿÿ…0ıÿÿj Ç…Øüÿÿ  @‰µäüÿÿ‰…,ıÿÿÿ€…(ıÿÿPÿŒ€jèñìÿÿÌ‹ÿU‹ì‹M¡ò‹U#U÷Ñ#ÈÊ‰ò]Ã‹ÿU‹ìQQS‹]VW3ö3ÿ‰}ü;ıòt	G‰}üƒÿrîƒÿƒw  jè%]  Yƒø„4  jè]  Y…Àuƒ=D„  ûü   „A  h˜‰»  S¿ÈWèŞ  ƒÄ…ÀtVVVVVèdÒÿÿƒÄh  ¾áVj Æå	 ÿØ€…Àu&h€‰hû  Vèœ  ƒÄ…Àt3ÀPPPPPè ÒÿÿƒÄVèËÕÿÿ@Yƒø<v8Vè¾Õÿÿƒî;Æj¹Üh|‰+ÈQPè¦[  ƒÄ…Àt3öVVVVVèİÑÿÿƒÄë3öhx‰SWè[  ƒÄ…ÀtVVVVVè¹ÑÿÿƒÄ‹Eüÿ4ÅòSWèçZ  ƒÄ…ÀtVVVVVè”ÑÿÿƒÄh  hP‰WèZY  ƒÄë2jôÿÔ€‹Ø;Şt$ƒûÿtj EøP4ıòÿ6è	ÕÿÿYPÿ6SÿĞ€_^[ÉÃjè©[  Yƒøtjèœ[  Y…Àuƒ=Duhü   è)şÿÿhÿ   èşÿÿYYÃ‹ÿU‹ì‹E£ä]ÃjhX¨èàÿÿjè.  Yƒeü ‹u‹N…Ét/¡ìºè‰Eä…Àt9u,‹H‰JPè`İÿÿYÿvèWİÿÿYƒf ÇEüşÿÿÿè
   èüßÿÿÃ‹ĞëÅjèĞ,  YÃÌ‹T$‹L$÷Â   u<‹:u.
Àt&:au%
ätÁè:Au
Àt:auƒÁƒÂ
äuÒ‹ÿ3ÀÃÀÑàƒÀÃ÷Â   tŠƒÂ:uçƒÁ
ÀtÜ÷Â   t¤f‹ƒÂ:uÎ
ÀtÆ:auÅ
ät½ƒÁëˆÌÌÌÌÌÌÌÌU‹ìWV‹u‹M‹}‹Á‹ÑÆ;şv;ø‚¤  ù   rƒ=<  tWVƒçƒæ;ş^_u^_]é‘[  ÷Ç   uÁéƒâƒùr*ó¥ÿ$•È ‹Çº   ƒérƒàÈÿ$…Ç ÿ$È ÿ$˜Ç (Ç TÇ xÇ #ÑŠˆŠFˆGŠFÁéˆGƒÆƒÇƒùrÌó¥ÿ$•È I #ÑŠˆŠFÁéˆGƒÆƒÇƒùr¦ó¥ÿ$•È #ÑŠˆƒÆÁéƒÇƒùrˆó¥ÿ$•È I ûÇ èÇ àÇ ØÇ ĞÇ ÈÇ ÀÇ ¸Ç ‹Dä‰Dä‹Dè‰Dè‹Dì‰Dì‹Dğ‰Dğ‹Dô‰Dô‹Dø‰Dø‹Dü‰Dü    ğøÿ$•È ‹ÿÈ È (È <È ‹E^_ÉÃŠˆ‹E^_ÉÃŠˆŠFˆG‹E^_ÉÃI ŠˆŠFˆGŠFˆG‹E^_ÉÃt1ü|9ü÷Ç   u$Áéƒâƒùrıó¥üÿ$• É ‹ÿ÷Ùÿ$PÉ I ‹Çº   ƒùrƒà+Èÿ$…¤È ÿ$ É ´È ØÈ  É ŠF#ÑˆGƒîÁéƒïƒùr²ıó¥üÿ$• É I ŠF#ÑˆGŠFÁéˆGƒîƒïƒùrˆıó¥üÿ$• É ŠF#ÑˆGŠFˆGŠFÁéˆGƒîƒïƒù‚Vÿÿÿıó¥üÿ$• É I TÉ \É dÉ lÉ tÉ |É „É —É ‹D‰D‹D‰D‹D‰D‹D‰D‹D‰D‹D‰D‹D‰D    ğøÿ$• É ‹ÿ°É ¸É ÈÉ ÜÉ ‹E^_ÉÃŠFˆG‹E^_ÉÃI ŠFˆGŠFˆG‹E^_ÉÃŠFˆGŠFˆGŠFˆG‹E^_ÉÃ‹ÿU‹ì‹MS3ÛVW;Ët‹};ûwèŞéÿÿj^‰0SSSSSè“ÍÿÿƒÄ‹Æë0‹u;óuˆëÚ‹ÑŠˆBF:ÃtOuó;ûuˆè£éÿÿj"Y‰‹ñëÁ3À_^[]ÃÌÌÌU‹ìWV‹u‹M‹}‹Á‹ÑÆ;şv;ø‚¤  ù   rƒ=<  tWVƒçƒæ;ş^_u^_]éÁW  ÷Ç   uÁéƒâƒùr*ó¥ÿ$•ÔË ‹Çº   ƒérƒàÈÿ$…èÊ ÿ$äË ÿ$hË øÊ $Ë HË #ÑŠˆŠFˆGŠFÁéˆGƒÆƒÇƒùrÌó¥ÿ$•ÔË I #ÑŠˆŠFÁéˆGƒÆƒÇƒùr¦ó¥ÿ$•ÔË #ÑŠˆƒÆÁéƒÇƒùrˆó¥ÿ$•ÔË I ËË ¸Ë °Ë ¨Ë  Ë ˜Ë Ë ˆË ‹Dä‰Dä‹Dè‰Dè‹Dì‰Dì‹Dğ‰Dğ‹Dô‰Dô‹Dø‰Dø‹Dü‰Dü    ğøÿ$•ÔË ‹ÿäË ìË øË Ì ‹E^_ÉÃŠˆ‹E^_ÉÃŠˆŠFˆG‹E^_ÉÃI ŠˆŠFˆGŠFˆG‹E^_ÉÃt1ü|9ü÷Ç   u$Áéƒâƒùrıó¥üÿ$•pÍ ‹ÿ÷Ùÿ$ Í I ‹Çº   ƒùrƒà+Èÿ$…tÌ ÿ$pÍ „Ì ¨Ì ĞÌ ŠF#ÑˆGƒîÁéƒïƒùr²ıó¥üÿ$•pÍ I ŠF#ÑˆGŠFÁéˆGƒîƒïƒùrˆıó¥üÿ$•pÍ ŠF#ÑˆGŠFˆGŠFÁéˆGƒîƒïƒù‚Vÿÿÿıó¥üÿ$•pÍ I $Í ,Í 4Í <Í DÍ LÍ TÍ gÍ ‹D‰D‹D‰D‹D‰D‹D‰D‹D‰D‹D‰D‹D‰D    ğøÿ$•pÍ ‹ÿ€Í ˆÍ ˜Í ¬Í ‹E^_ÉÃŠFˆG‹E^_ÉÃI ŠFˆGŠFˆG‹E^_ÉÃŠFˆGŠFˆGŠFˆG‹E^_ÉÃƒ%`! ÃjThx¨èÏ×ÿÿ3ÿ‰}üEœPÿä€ÇEüşÿÿÿj@j ^Vè”ŞÿÿYY;Ç„  £` ‰5D ˆ   ë0Æ@ ƒÿÆ@
‰xÆ@$ Æ@%
Æ@&
‰x8Æ@4 ƒÀ@‹` Á   ;ÁrÌf9}Î„
  ‹EĞ;Ç„ÿ   ‹8X;‰Eä¾   ;ş|‹şÇEà   ë[j@j èŞÿÿYY…ÀtV‹Mà` ‰ƒD     ë*Æ@ ƒÿÆ@
ƒ` €`$€Æ@%
Æ@&
ƒ`8 Æ@4 ƒÀ@‹Ö;ÂrÒÿEà9=D |ë‹=D ƒeà …ÿ~m‹Eä‹ƒùÿtVƒùştQŠ¨tK¨uQÿà€…Àt<‹uà‹ÆÁøƒæÁæ4…` ‹Eä‹ ‰ŠˆFh   FPèÊ>  YY…À„É   ÿFÿEàCƒEä9}à|“3Û‹óÁæ5` ‹ƒøÿtƒøşt€N€ërÆF…ÛujöXë
‹ÃH÷ØÀƒÀõPÿÔ€‹øƒÿÿtC…ÿt?Wÿà€…Àt4‰>%ÿ   ƒøu€N@ë	ƒøu€Nh   FPè4>  YY…Àt7ÿFë
€N@ÇşÿÿÿCƒûŒgÿÿÿÿ5D ÿÜ€3Àë3À@Ã‹eèÇEüşÿÿÿƒÈÿèÍÕÿÿÃ‹ÿVW¾` ‹>…ÿt1‡   ëƒ t
GPÿ,€‹ƒÇ@   ;ørâÿ6èÕÒÿÿƒ& YƒÆş`!|¾_^Ãƒ=p! uè8  V‹58W3ÿ…öuƒÈÿé    <=tGVè¢ÉÿÿYtŠ„ÀuêjGWèÜÛÿÿ‹øYY‰= …ÿtË‹58SëBVèqÉÿÿ‹ØC€>=Yt1jSè®ÛÿÿYY‰…ÀtNVSPèùÿÿƒÄ…Àt3ÀPPPPPè‰ÅÿÿƒÄƒÇó€> u¹ÿ58èÒÿÿƒ%8 ƒ' Çd!   3ÀY[_^Ãÿ5 èñÑÿÿƒ%  ƒÈÿëä‹ÿU‹ìQ‹MS3ÀV‰‹ò‹UÇ   9Et	‹]ƒE‰‰Eü€>"u3À9Eü³"”ÀF‰Eüë<ÿ…ÒtŠˆB‰UŠ¶ÃPFè÷Q  Y…Àtÿƒ} t
‹MŠÿEˆF‹U‹M„Ût2ƒ}ü u©€û t€û	uŸ…ÒtÆBÿ ƒeü €> „é   Š< t<	uFëóNëã€> „Ğ   ƒ} t	‹EƒE‰ÿ3ÛC3ÉëFA€>\tù€>"u&öÁuƒ}ü tF€8"u‹ğë3À3Û9Eü”À‰EüÑé…ÉtI…ÒtÆ\Bÿ…Éuñ‰UŠ„ÀtUƒ}ü u< tK<	tG…Ût=¾ÀP…Òt#èQ  Y…ÀtŠ‹MÿEˆFÿ‹MŠÿEˆëèïP  Y…ÀtFÿÿ‹UFéVÿÿÿ…ÒtÆ B‰Uÿ‹Méÿÿÿ‹E^[…Àtƒ  ÿÉÃ‹ÿU‹ìƒìS3ÛVW9p!uè‡5  h  ¾ğVSˆôÿØ€¡x!‰5°;Ãt‰Eü8u‰uü‹UüEøPSS}ôè
şÿÿ‹EøƒÄ=ÿÿÿ?sJ‹MôƒùÿsB‹øÁç;Ár6PèßØÿÿ‹ğY;ót)‹UüEøPşWV}ôèÉıÿÿ‹EøƒÄH£”‰5˜3ÀëƒÈÿ_^[ÉÃ‹ÿU‹ì¡øƒìSV‹5ø€W3Û3ÿ;Ãu.ÿÖ‹ø;ûtÇø   ë#ÿt€ƒøxu
jX£øë¡øƒø…   ;ûuÿÖ‹ø;ûu3ÀéÊ   ‹Çf9t@@f9uù@@f9uò‹5ô€SSS+ÇSÑø@PWSS‰EôÿÖ‰Eø;Ãt/PèØÿÿY‰Eü;Ãt!SSÿuøPÿuôWSSÿÖ…ÀuÿuüèÌÎÿÿY‰]ü‹]üWÿğ€‹Ãë\ƒøt;Ãu‚ÿì€‹ğ;ó„rÿÿÿ8t
@8uû@8uö+Æ@P‰Eøè×ÿÿ‹øY;ûuVÿè€éEÿÿÿÿuøVWèÈñÿÿƒÄVÿè€‹Ç_^[ÉÃ‹ÿV¸Ø¥¾Ø¥W‹ø;Æs‹…ÀtÿĞƒÇ;şrñ_^Ã‹ÿV¸à¥¾à¥W‹ø;Æs‹…ÀtÿĞƒÇ;şrñ_^Ã‹ÿU‹ì3À9Ej ”Àh   Pÿü€£ü…Àu]Ã3À@£@ ]Ãƒ=@ uWS3Û9$ W‹=l€~3V‹5( ƒÆh €  j ÿvüÿÿ6j ÿ5üÿ×ƒÆC;$ |Ø^ÿ5( j ÿ5üÿ×_[ÿ5üÿ ƒ%ü Ã‹ÿU‹ìƒì¡pğƒeø ƒeü SW¿Næ@»»  ÿÿ;Çt…Ãt	÷Ğ£tğë`VEøPÿ‹uü3uøÿ3ğÿ|€3ğÿ3ğEğPÿ‹Eô3Eğ3ğ;÷u¾Oæ@»ë…óu‹ÆÁàğ‰5pğ÷Ö‰5tğ^_[ÉÃ‹ÿU‹ìVEP‹ñèŸ¾ÿÿÇ¼‰‹Æ^]Â Ç¼‰éT¿ÿÿ‹ÿU‹ìV‹ñÇ¼‰èA¿ÿÿöEtVè(¸ÿÿY‹Æ^]Â ‹ÿU‹ìVW‹}‹G…ÀtGP€: t?‹u‹N;ÁtƒÁQRè$ïÿÿYY…Àt3Àë$ötötò‹E‹ ¨tötä¨tötÛ3À@_^]Ã‹ÿU‹ì‹E‹ ‹ =MOCàt=csmàu+èØÑÿÿƒ     é×ÍÿÿèÇÑÿÿƒ¸    ~è¹Ñÿÿ   ÿ3À]Ãjh˜¨èEÎÿÿ‹}‹]€   ¾së‹s‰uäè‚Ñÿÿ   ÿ ƒeü ;uteƒşÿ~;w|èºÍÿÿ‹ÆÁà‹OÈ‹1‰uàÇEü   ƒy t‰sh  S‹OÿtèM  ƒeü ëÿuìè-ÿÿÿYÃ‹eèƒeü ‹}‹]‹uà‰uäë–ÇEüşÿÿÿè   ;utèNÍÿÿ‰sè×ÍÿÿÃ‹]‹uäèãĞÿÿƒ¸    ~èÕĞÿÿ   ÿÃ‹ 8csmàu8ƒxu2‹Hù “tù!“tù"“uƒx uè—Ğÿÿ3ÉA‰ˆ  ‹ÁÃ3ÀÃjhÀ¨èÍÿÿ‹M…Ét*9csmàu"‹A…Àt‹@…Àtƒeü Pÿqè–ÂÿÿÇEüşÿÿÿè.ÍÿÿÃ3À8E•ÀÃ‹eèè?ÌÿÿÌ‹ÿU‹ì‹M‹V‹uÆƒy |‹Q‹I‹42‹ÊÁ^]Ã‹ÿU‹ìƒì…ÿu
èPÌÿÿèÿËÿÿƒeø ƒ? ÆEÿ ~SSV‹E‹@‹@‹p…Û~3‹EøÁà‰Eô‹Mÿq‹P‹GEôPè_ıÿÿƒÄ…Àu
KƒÆ…ÛÜëÆEÿÿEø‹Eø;|±^[ŠEÿÉÃj¸“gè®Åÿÿè~Ïÿÿƒ¸”    tèÇËÿÿƒeü è«ËÿÿƒMüÿèiËÿÿèYÏÿÿ‹Mj j ‰ˆ”   èÁÿÿÌj,h8©èİËÿÿ‹Ù‹}‹u‰]äƒeÌ ‹Gü‰EÜÿvEÄPèÄÿÿYY‰EØèÏÿÿ‹€ˆ   ‰EÔèÏÿÿ‹€Œ   ‰EĞèóÎÿÿ‰°ˆ   èèÎÿÿ‹M‰ˆŒ   ƒeü 3À@‰E‰EüÿuÿuSÿuWèZÄÿÿƒÄ‰Eäƒeü ëo‹EìèáıÿÿÃ‹eèè¥Îÿÿƒ    ‹u‹}~€   ¾Oë‹O‹^ƒeà ‹Eà;FskÀÃ‹P;Ê~@;H;‹F‹LĞQVj Wè§üÿÿƒÄƒeä ƒeü ‹uÇEüşÿÿÿÇE    è   ‹EäèËÿÿÃÿEàë§‹}‹u‹EÜ‰GüÿuØèXÃÿÿYèÎÿÿ‹MÔ‰ˆˆ   èşÍÿÿ‹MĞ‰ˆŒ   >csmàuBƒ~u<‹F= “t=!“t="“u$ƒ}Ì uƒ}ä tÿvèÚÂÿÿY…ÀtÿuVè%ıÿÿYYÃjh`©èAÊÿÿ3Ò‰Uä‹E‹H;Ê„X  8Q„O  ‹H;Êu÷    €„<  ‹ ‹u…Àxt1‰Uü3ÛCS¨tA‹}ÿwèıG  YY…À„ò   SVèìG  YY…À„á   ‹G‰‹MƒÁQPèìüÿÿYY‰éË   ‹}‹Eÿp„tHèµG  YY…À„ª   SVè¤G  YY…À„™   ÿw‹EÿpVè5îÿÿƒÄƒ…‚   ‹…Àt|ƒÇWëœ9Wu8èhG  YY…ÀtaSVè[G  YY…ÀtTÿwƒÇW‹Eÿpè_üÿÿYYPVèäíÿÿƒÄë9è0G  YY…Àt)SVè#G  YY…ÀtÿwèG  Y…Àtöj X•À@‰Eäëè¢ÈÿÿÇEüşÿÿÿ‹Eäë3À@Ã‹eèè>Èÿÿ3ÀèÉÿÿÃjh€©èÂÈÿÿ‹E÷    €t‹]ë
‹H‹U\ƒeü ‹uVPÿu‹}WèFşÿÿƒÄHtHu4jFPÿwè¦ûÿÿYYPÿvSè¾ÿÿëFPÿwèŒûÿÿYYPÿvSè÷½ÿÿÇEüşÿÿÿèÈÿÿÃ3À@Ã‹eèè¥ÇÿÿÌ‹ÿU‹ìƒ} tÿuSVÿuèVÿÿÿƒÄƒ}  ÿuuVëÿu èµ½ÿÿÿ7ÿuÿuVè®ùÿÿ‹Gh   ÿu@ÿu‰Fÿu‹KVÿuèõûÿÿƒÄ(…ÀtVPè?½ÿÿ]Ã‹ÿU‹ìQQV‹u>  €„Ú   WèËÿÿƒ¸€    t?è Ëÿÿ¸€   ècÈÿÿ9t+>MOCàt#ÿu$ÿu ÿuÿuÿuÿuVèÙ½ÿÿƒÄ…À…‹   ‹}ƒ uèÇÿÿ‹uEøPEüPVÿu Wè!¿ÿÿ‹ø‹EüƒÄ;Eøs[S;7|G;wB‹G‹OÁàÁ‹Hô…Ét€y u*Xğö@u"ÿu$‹uÿu j ÿuÿuÿuÿuè·şÿÿ‹uƒÄÿEü‹EüƒÇ;Eør§[_^ÉÃ‹ÿU‹ìƒì,‹MS‹]‹C=€   VWÆEÿ ¾Ië‹Iƒùÿ‰Mø|;È|èUÆÿÿ‹u¿csmà9>…º  ƒ~» “…  ‹F;Ãt=!“t="“…ÿ   ƒ~ …õ   è·Éÿÿƒ¸ˆ    „µ  è¥Éÿÿ‹°ˆ   ‰uè—Éÿÿ‹€Œ   jV‰Eè7D  YY…ÀuèÒÅÿÿ9>u&ƒ~u ‹F;Ãt=!“t="“uƒ~ uè¨ÅÿÿèLÉÿÿƒ¸”    t|è>Éÿÿ‹¸”   è3Éÿÿÿu3ö‰°”   èùÿÿY„ÀuO3Û9~‹G‹Lh(óèc´ÿÿ„ÀuFƒÃ;7|ãèÅÿÿjÿuèdøÿÿYYhÄ‰MÔè7öÿÿhœ©EÔPè•ºÿÿ‹u¿csmà9>…ˆ  ƒ~…~  ‹F;Ãt=!“t="“…e  ‹}ƒ †¿   EäPEğPÿuøÿu Wèù¼ÿÿƒÄ‹ø‹Eğ;Eäƒ—   ‹Eø9   ;G|‹G‰Eô‹G‰Eè…À~l‹F‹@X‹ ‰Eì…À~#ÿv‹Pÿuô‰EàèÑõÿÿƒÄ…ÀuÿMìƒÃ9EìİÿMèƒEôƒ}è ¾ë(ÿu$‹]ôÿu ÆEÿÿuàÿuÿuÿuV‹uèKüÿÿ‹uƒÄÿEğƒÇé]ÿÿÿ‹}€} t
jVè:÷ÿÿYY€}ÿ …®   ‹%ÿÿÿ=!“‚œ   ‹…ÿ„‘   Vè‰÷ÿÿY„À…‚   è…Çÿÿè€Çÿÿè{Çÿÿ‰°ˆ   èpÇÿÿƒ}$ ‹M‰ˆŒ   Vuÿuëÿu$è¹ÿÿ‹ujÿVÿuÿuè”õÿÿƒÄÿvè¨÷ÿÿ‹]ƒ{ v&€} …)şÿÿÿu$ÿu ÿuøSÿuÿuÿuVèàûÿÿƒÄ èÇÿÿƒ¸”    tèLÃÿÿ_^[ÉÃ‹ÿU‹ìVÿu‹ñèZ³ÿÿÇ¼‰‹Æ^]Â ‹ÿU‹ìSVWèÆÆÿÿƒ¸   ‹E‹M¿csmà¾ÿÿÿ»"“u ‹;×tú&  €t‹#Ö;Ór
ö@ …“   öAft#ƒx „ƒ   ƒ} u}jÿPÿuÿuè¶ôÿÿƒÄëjƒx u‹#Öú!“rXƒx tR99u2ƒyr,9Yv'‹Q‹R…Òt¶u$Vÿu ÿuPÿuÿuÿuQÿÒƒÄ ëÿu ÿuÿu$PÿuÿuÿuQèÁûÿÿƒÄ 3À@_^[]ÃÌÌÌÌÌÌÌÌU‹ìƒìSQ‹EƒÀ‰Eü‹EUÿu‹M‹müè‘A  VWÿĞ_^‹İ]‹MU‹ëù   u¹   QèoA  ]Y[ÉÂ ‹ÿU‹ìƒìVÿuMğèÒÿÿ‹u¾Pè¶B  ƒøeëF¶Pèø=  …ÀYuñ¾Pè™B  YƒøxuFF‹Mğ‹‰¼   ‹	ŠŠ	ˆFŠˆŠÁŠF„Éuó^8Müt‹Eøƒ`pıÉÃ‹ÿU‹ìƒìVÿuMğèªÑÿÿ‹EŠ‹uğ„Ét‹–¼   ‹Š:Êt@Š„ÉuõŠ@„Ét6ë€ùet€ùEt@Š„Éuï‹ĞH€80tú‹¼   ‹	SŠ:[uHŠ
@Bˆ„Éuö€}ü ^t‹Eøƒ`pıÉÃ‹ÿU‹ìÙî‹EÜßàöÄAz3À@]Ã3À]Ã‹ÿU‹ìQQƒ} ÿuÿutEøPèÕA  ‹Mø‹E‰‹Mü‰HëEPèdB  ‹E‹M‰ƒÄÉÃ‹ÿU‹ìj ÿuÿuÿuè©ÿÿÿƒÄ]Ã‹ÿV‹ğ…ÿtVèXµÿÿ@PV÷VèmåÿÿƒÄ^Ã‹ÿU‹ìj ÿuèeşÿÿYY]Ã‹ÿU‹ìj ÿuèÅşÿÿYY]Ã‹ÿU‹ìƒìSVWÿuMğ‹ØègĞÿÿ3ö;Şu+è¯Îÿÿj_VVVVV‰8èd²ÿÿƒÄ€}ü t‹Eøƒ`pı‹Çé!  9uvĞ9u~‹Eë3ÀƒÀ	9Ew	èkÎÿÿj"ëº€} t‹U3À9uŸÀ3Éƒ:-”Á‹øË‹Áè,ÿÿÿ‹}ƒ?-‹óuÆ-sƒ} ~FŠˆ‹ğ‹Eğ‹€¼   ‹ Š ˆ3À8E”ÀEğƒ}ÿuƒËÿë+Ş]hÔ‰SVèñãÿÿƒÄ3Û…ÀtSSSSSèu°ÿÿƒÄN9]tÆE‹GF€80t.‹GHy÷ØÆ-Fƒød|
™jd_÷ÿ ‹ÂFƒø
|
™j
_÷ÿ ‹Â Föt€90ujAPQèêãÿÿƒÄ€}ü t‹Eøƒ`pı3À_^[ÉÃ‹ÿU‹ìƒì,¡pğ3Å‰Eü‹ESVW‹}j^VMäQMÔQÿpÿ0è|B  3ÛƒÄ;ûuè$ÍÿÿSSSSS‰0èÜ°ÿÿƒÄ‹Æëo‹E;Ãvá‹uƒøÿuƒÈÿë3Éƒ}Ô-”Á+Á3É;óŸÁ+ÁMÔQNQP3Àƒ}Ô-”À3É;óŸÁÇÈQè”@  ƒÄ;ÃtˆëÿuEÔSPÿu‹ÇVÿuèÓıÿÿƒÄ‹Mü_^3Í[èe§ÿÿÉÃ‹ÿU‹ìj ÿuÿuÿuÿuÿuèÿÿÿƒÄ]Ã‹ÿU‹ìƒì$VWÿuMÜÇEìÿ  3ÿÇEü0   èûÍÿÿ9}}‰}‹u;÷u+è:Ìÿÿj^WWWWW‰0èï¯ÿÿƒÄ€}è t‹Eäƒ`pı‹Æé  9}vĞ‹EƒÀÆ 9Ew	èüËÿÿj"ëÀ‹}‹‰Eô‹G‹ÈÁéºÿ  S#Ê3Û;Ê…   …Û…ˆ   ‹EƒøÿuÀëƒÀşj ÿu^PSWèÿÿÿƒÄ…Àt€}è Æ „–  ‹MäƒapıéŠ  €;-uÆ-FÆ0Fƒ} je”ÀşÈ$àxˆFVèz<  YY…À„L  ƒ} ”ÁşÉ€áà€ÁpˆÆ@ é2  %   €3ÉÈtÆ-F‹]Æ0F…Û”ÀşÈ$àxˆ‹OF÷ÛÛƒãàá  ğ3ÀƒÃ'3ÒÁu!Æ0‹O‹áÿÿ FÁu‰UìëÇEìş  ëÆ1F‹ÆF‰E9Uuˆë‹MÜ‹‰¼   ‹	Š	ˆ‹O‹áÿÿ ‰Møw;Â†µ   ‰UôÇEø   ƒ} ~M‹W#Uø‹¿Mü#Eôâÿÿ èBA  fƒÀ0·Àfƒø9vÃ‹Møƒmüˆ‹Eô¬ÈÁéFÿMfƒ}ü ‰Eô‰Mø}­fƒ}ü |Q‹W#Uø‹¿Mü#Eôâÿÿ èî@  fƒøv1FÿŠ€ùft€ùFuÆ 0Hëî;EtŠ€ù9u€Ã:ˆë	şÁˆëş@ÿƒ} ~ÿuj0Vèv·ÿÿƒÄu‹E€8 u‹ğƒ} ±4”ÀşÈ$àpˆ‹‹WFèz@  3Û%ÿ  #Ó+EìSYÑx;ÃrÆ+Fë
Æ-F÷ØÓ÷Ú;Ó‹şÆ0|$¹è  ;ÁrSQRPèU?  0ˆF‰Uğ‹Á‹Ó;÷u…Ò|ƒødrj jdRPè/?  0ˆ‰UğF‹Á‹Ó;÷u…Ò|ƒø
rj j
RPè	?  0ˆ‰UğF‹Á‰]ğ0ˆÆF €}è t‹Eäƒ`pı3À[_^ÉÃ‹ÿU‹ìƒìSVWÿu‹Ø‹s‹ùMğNèÊÿÿ…ÿu-èÙÈÿÿj^‰03ÀPPPPPèŒ¬ÿÿƒÄ€}ü t‹Eøƒ`pı‹Æé£   ƒ} vÍ€} t;uu3Àƒ;-”ÀÆÇÆ 0Æ@ ƒ;-‹÷uÆ-w‹C3ÿG…À‹ÆèXùÿÿÆ0Fëğƒ} ~D‹ÆèCùÿÿ‹Eğ‹€¼   ‹ Š ˆ‹[F…Û}&÷Û€} u9]|‰]‹}‹ÆèùÿÿWj0Vè°µÿÿƒÄ€}ü t‹Eøƒ`pı3À_^[ÉÃ‹ÿU‹ìƒì,¡pğ3Å‰Eü‹ESVW‹}j^VMäQMÔQÿpÿ0è"=  3ÛƒÄ;ûuèÊÇÿÿSSSSS‰0è‚«ÿÿƒÄ‹ÆëZ‹E;ÃváƒøÿuÀë3Éƒ}Ô-”Á+Á‹uMÔQ‹MØÎQP3Àƒ}Ô-”ÀÇPèK;  ƒÄ;ÃtˆëÿuEÔSVÿu‹Ïè`şÿÿƒÄ‹Mü_^3Í[è ¢ÿÿÉÃ‹ÿU‹ìƒì0¡pğ3Å‰Eü‹ESV‹uWj_WMäQMĞQÿpÿ0èg<  3ÛƒÄ;óuèÇÿÿSSSSS‰8èÇªÿÿƒÄ‹Çé–   ‹M;ËvŞ‹EÔH‰Eà3Àƒ}Ğ-”À<0ƒùÿuÉë+ÈEĞPÿuQWè”:  ƒÄ;ÃtˆëX‹EÔH9EàœÁƒøü|-;E}(:Ët
ŠG„Àuùˆ_şÿuEĞjÿu‹Îÿuè„ıÿÿƒÄëÿuEĞjPÿu‹Æÿuÿuè”÷ÿÿƒÄ‹Mü_^3Í[è&¡ÿÿÉÃ‹ÿU‹ì‹Eƒøet_ƒøEtZƒøfuÿu ÿuÿuÿuÿuè şÿÿƒÄ]ÃƒøatƒøAtÿu ÿuÿuÿuÿuÿuèµşÿÿë0ÿu ÿuÿuÿuÿuÿuèwùÿÿëÿu ÿuÿuÿuÿuÿuènøÿÿƒÄ]Ã‹ÿU‹ìj ÿuÿuÿuÿuÿuÿuèZÿÿÿƒÄ]Ã‹ÿVW3ÿ·Póÿ6è§·ÿÿƒÇY‰ƒÿ(rè_^Ã‹ÿVh   h   3öVè[<  ƒÄ…ÀtVVVVVèş§ÿÿƒÄ^Ã‹ÿU‹ìƒìİè‰İ]ğİà‰İ]èİEèÜuğÜMğÜmèİ]øÙèÜ]øßàöÄz3À@ÉÃ3ÀÉÃhŠÿ…Àthğ‰Pÿ¬€…Àtj ÿĞÃé™ÿÿÿÌÌSVW‹T$‹D$‹L$URPQQhŒï dÿ5    ¡pğ3Ä‰D$d‰%    ‹D$0‹X‹L$,3‹pƒşşt;‹T$4ƒúşt;òv.4v\³‹‰Hƒ{ uÌh  ‹Cèn5  ¹   ‹Cè€5  ë°d    ƒÄ_^[Ã‹L$÷A   ¸   t3‹D$‹H3ÈèŸÿÿU‹hÿpÿpÿpè>ÿÿÿƒÄ]‹D$‹T$‰¸   ÃU‹L$‹)ÿqÿqÿq(èÿÿÿƒÄ]Â UVWS‹ê3À3Û3Ò3ö3ÿÿÑ[_^]Ã‹ê‹ñ‹ÁjèË4  3À3Û3É3Ò3ÿÿæU‹ìSVWj j h3ğ Qè+w  _^[]ÃU‹l$RQÿt$è´şÿÿƒÄ]Â U‹ìƒì‰}ü‹}‹MÁéfïÀë¤$    ffGfG fG0fG@fGPfG`fGp¿€   IuĞ‹}ü‹å]ÃU‹ìƒì‰}ü‹E™‹ø3ú+úƒç3ú+ú…ÿu<‹M‹Ñƒâ‰Uô;Êt+ÊQPèsÿÿÿƒÄ‹E‹Uô…ÒtEE+Â‰Eø3À‹}ø‹Môóª‹Eë.÷ßƒÇ‰}ğ3À‹}‹Mğóª‹Eğ‹M‹UÈ+ĞRj Qè~ÿÿÿƒÄ‹E‹}ü‹å]ÃjhØ©èg´ÿÿƒeü f(ÁÇEä   ë#‹Eì‹ ‹ =  Àt
=  Àt3ÀÃ3À@Ã‹eèƒeä ÇEüşÿÿÿ‹Eäèi´ÿÿÃ‹ÿU‹ìƒì3ÀS‰Eü‰Eô‰EøSœX‹È5    PœZ+ÑtQ3À¢‰Eô‰]è‰Uì‰Mğ¸   ¢‰Uü‰Eø[÷Eü   tè\ÿÿÿ…Àt3À@ë3À[ÉÃè™ÿÿÿ£< 3ÀÃÌÌÌÌÌÌÌÌÌÌÌÌQL$+ÈÀ÷Ğ#È‹Ä% ğÿÿ;Èr
‹ÁY”‹ ‰$Ã-   … ëé‹ÿVW3ö¿ ƒ<õ„óuõ€ó‰8h   ÿ0ƒÇè·  YY…ÀtFƒş$|Ò3À@_^Ãƒ$õ€ó 3Àëñ‹ÿS‹,€V¾€óW‹>…ÿtƒ~tWÿÓWè—°ÿÿƒ& YƒÆş ô|Ü¾€ó_‹…Àt	ƒ~uPÿÓƒÆş ô|æ^[Ã‹ÿU‹ì‹Eÿ4Å€óÿ€]Ãjhø©è¸²ÿÿ3ÿG‰}ä3Û9üuèBÒÿÿjèĞÿÿhÿ   è9»ÿÿYY‹u4õ€ó9t‹Çënjè¹ÿÿY‹ø;ûuè³ÀÿÿÇ    3ÀëQj
èY   Y‰]ü9u,h   Wè®  YY…ÀuWèÅ¯ÿÿYè}ÀÿÿÇ    ‰]äë‰>ëWèª¯ÿÿYÇEüşÿÿÿè	   ‹EäèP²ÿÿÃj
è(ÿÿÿYÃ‹ÿU‹ì‹EV4Å€óƒ> uPè"ÿÿÿY…Àujè-ºÿÿYÿ6ÿ€^]Ã‹ÿU‹ì‹$ ¡( kÉÈë‹U+Pú   r	ƒÀ;Árë3À]Ã‹ÿU‹ìƒì‹M‹AV‹uW‹ş+yƒÆüÁï‹ÏiÉ  ŒD  ‰Mğ‹I‰MüöÁ…Ó  S1‹‰Uô‹Vü‰Uø‹Uô‰]öÂutÁúJƒú?vj?Z‹K;KuB»   €ƒú s‹ÊÓëL÷Ó!\¸Dş	u#‹M!ëJàÓëL÷Ó!œ¸Ä   ş	u‹M!Y‹]‹S‹[‹MüMô‰Z‹U‹Z‹R‰S‰Mü‹ÑÁúJƒú?vj?Z‹]øƒã‰]ô…   +uø‹]øÁûj?‰uK^;Şv‹ŞMø‹ÑÁúJ‰Mü;Öv‹Ö;Út^‹M‹q;qu;¾   €ƒû s‹ËÓî÷Ö!t¸DşLu!‹M!1ëKàÓî÷Ö!´¸Ä   şLu‹M!q‹M‹q‹I‰N‹M‹q‹I‰N‹uë‹]ƒ}ô u;Ú„€   ‹MğÑ‹Y‰N‰^‰q‹N‰q‹N;Nu`ŠLˆMşÁˆLƒú s%€} u‹Ê»   €Óë‹M	»   €‹ÊÓëD¸D	ë)€} uJà»   €Óë‹M	YJàº   €Óê„¸Ä   	‹Eü‰‰D0ü‹Eğÿ…ó   ¡P…À„Ø   ‹8 ‹5h @  ÁáH» €  SQÿÖ‹8 ¡Pº   €Óê	P¡P‹@‹8 ƒ¤ˆÄ    ¡P‹@şHC¡P‹H€yC u	ƒ`ş¡PƒxÿueSj ÿpÿÖ¡Pÿpj ÿ5üÿl€‹$ ¡PkÉ‹( +ÈLìQHQPèuÓÿÿ‹EƒÄÿ$ ;Pvƒm¡( £0 ‹E£P‰=8 [_^ÉÃ¡4 V‹5$ W3ÿ;ğu4ƒÀkÀPÿ5( Wÿ5üÿ ;Çu3Àëxƒ4 ‹5$ £( kö5( hÄA  jÿ5üÿ¤€‰F;ÇtÇjh    h   Wÿ‰F;ÇuÿvWÿ5üÿl€ë›ƒNÿ‰>‰~ÿ$ ‹Fƒÿ‹Æ_^Ã‹ÿU‹ìQQ‹M‹ASV‹qW3ÛëÀC…À}ù‹ÃiÀ  „0D  j?‰EøZ‰@‰@ƒÀJuôj‹ûh   Áçyh €  Wÿ…ÀuƒÈÿé   — p  ‰Uü;úwC‹Ê+ÏÁéGAƒHøÿƒˆì  ÿü  ‰üïÿÿÇ@üğ  ‰PÇ€è  ğ     IuË‹Uü‹Eøø  O‰H‰AJ‰H‰AƒdD 3ÿG‰¼Ä   ŠFCŠÈşÁ„À‹EˆNCu	xº   €‹ËÓê÷Ò!P‹Ã_^[ÉÃ‹ÿU‹ìƒì‹M‹ASV‹uW‹}‹×+QƒÆÁê‹ÊiÉ  ŒD  ‰Mô‹OüƒæğI;ñ|9ü‹‰M‰]üU  öÃ…E  Ù;ó;  ‹MüÁùI‰Møƒù?vj?Y‰Mø‹_;_uC»   €ƒù sÓë‹MøL÷Ó!\Dş	u&‹M!ëƒÁàÓë‹MøL÷Ó!œÄ   ş	u‹M!Y‹O‹_‰Y‹O‹‰y‹M+ÎMüƒ}ü ¥   ‹}ü‹MÁÿOL1üƒÿ?vj?_‹]ôû‰]‹[‰Y‹]‰Y‰K‹Y‰K‹Y;YuWŠLˆMşÁˆLƒÿ s€} u‹Ï»   €Óë‹M	DD‹Ïë €} uOà»   €Óë‹M	Y„Ä   Oàº   €Óê	‹U‹MüD2ü‰‰Lüë‹UF‰Bü‰D2øé<  3Àé8  /  ‹])uN‰Kü\3ü‹uÁşN‰]‰Küƒş?vj?^öEü…€   ‹uüÁşNƒş?vj?^‹O;OuB»   €ƒş s‹ÎÓët÷Ó!\Dşu#‹M!ëNàÓëL÷Ó!œÄ   ş	u‹M!Y‹]‹O‹w‰q‹w‹O‰q‹uuü‰uÁşNƒş?vj?^‹Môñ‹y‰K‰{‰Y‹K‰Y‹K;KuWŠLˆMşÁˆLƒş s€} u‹Î¿   €Óï‹M	9DD‹Îë €} uNà¿   €Óï‹M	y„Ä   Nàº   €Óê	‹E‰‰Dü3À@_^[ÉÃ‹ÿU‹ìƒì¡$ ‹MkÀ( ƒÁƒáğ‰MğÁùSIƒù VW}ƒÎÿÓîƒMøÿëƒÁàƒÊÿ3öÓê‰Uø‹0 ‹Ùë‹S‹;#Uø#ş×u
ƒÃ‰];Ørè;Øu‹( ë‹S‹;#Uø#ş×u
ƒÃ‰];Ùrè;Ùu[ëƒ{ u
ƒÃ‰];Ørğ;Øu1‹( ë	ƒ{ u
ƒÃ‰];Ùrğ;Ùuè úÿÿ‹Ø‰]…Ûu3Àé	  Sè:ûÿÿY‹K‰‹Cƒ8ÿtå‰0 ‹C‹‰Uüƒúÿt‹ŒÄ   ‹|D#Mø#şÏu)ƒeü ‹Ä   HD‹9#Uø#ş×uÿEü‹‘„   ƒÁëç‹Uü‹ÊiÉ  ŒD  ‰Mô‹LD3ÿ#Îu‹ŒÄ   #Møj _ëÉG…É}ù‹Mô‹Tù‹
+Mğ‹ñÁşNƒş?‰Mø~j?^;÷„  ‹J;Ju\ƒÿ »   €}&‹ÏÓë‹Mü|8÷Ó‰]ì#\ˆD‰\ˆDşu3‹Mì‹]!ë,OàÓë‹MüŒˆÄ   |8÷Ó!ş‰]ìu‹]‹Mì!Kë‹]ƒ}ø ‹J‹z‰y‹J‹z‰y„   ‹Môñ‹y‰J‰z‰Q‹J‰Q‹J;Ju^ŠLˆMşÁƒş ˆL}#€} u¿   €‹ÎÓï	;‹Î¿   €Óï‹Mü	|ˆDë)€} uNà¿   €Óï	{‹Mü¼ˆÄ   Nà¾   €Óî	7‹Mø…Ét‰
‰Lüë‹Mø‹uğÑN‰
‰L2ü‹uô‹y‰>…Éu;Pu‹Mü;8 uƒ%P ‹Mü‰B_^[ÉÃ‹ÿU‹ìSV‹u‹†¼   3ÛW;Ãto=(şth‹†°   ;Ãt^9uZ‹†¸   ;Ãt9uPèT¤ÿÿÿ¶¼   è5.  YY‹†´   ;Ãt9uPè3¤ÿÿÿ¶¼   èÏ-  YYÿ¶°   è¤ÿÿÿ¶¼   è¤ÿÿYY‹†À   ;ÃtD9u@‹†Ä   -ş   Pèï£ÿÿ‹†Ì   ¿€   +ÇPèÜ£ÿÿ‹†Ğ   +ÇPèÎ£ÿÿÿ¶À   èÃ£ÿÿƒÄ¾Ô   ‹=hıt9˜´   uPèµ+  ÿ7èœ£ÿÿYY~PÇE   ø¨ôt‹;Ãt9uPèw£ÿÿY9_üt‹G;Ãt9uPè`£ÿÿYƒÇÿMuÇVèQ£ÿÿY_^[]Ã‹ÿU‹ìSV‹5<€W‹}WÿÖ‹‡°   …ÀtPÿÖ‹‡¸   …ÀtPÿÖ‹‡´   …ÀtPÿÖ‹‡À   …ÀtPÿÖ_PÇE   {ø¨ôt	‹…ÀtPÿÖƒ{ü t
‹C…ÀtPÿÖƒÃÿMuÖ‹‡Ô   ´   PÿÖ_^[]Ã‹ÿU‹ìW‹}…ÿ„ƒ   SV‹5D€WÿÖ‹‡°   …ÀtPÿÖ‹‡¸   …ÀtPÿÖ‹‡´   …ÀtPÿÖ‹‡À   …ÀtPÿÖ_PÇE   {ø¨ôt	‹…ÀtPÿÖƒ{ü t
‹C…ÀtPÿÖƒÃÿMuÖ‹‡Ô   ´   PÿÖ^[‹Ç_]Ã…ÿt7…Àt3V‹0;÷t(W‰8èÁşÿÿY…ötVèEÿÿÿƒ> Yuş°ôtVèYıÿÿY‹Ç^Ã3ÀÃjhªèO¤ÿÿè§§ÿÿ‹ğ¡8ı…Fpt"ƒ~l tè§ÿÿ‹pl…öuj èx¬ÿÿY‹Æèb¤ÿÿÃjèòÿÿYƒeü Fl‹=ˆõèiÿÿÿ‰EäÇEüşÿÿÿè   ëÁjèñÿÿY‹uäÃ-¤  t"ƒètƒètHt3ÀÃ¸  Ã¸  Ã¸  Ã¸  Ã‹ÿVW‹ğh  3ÿFWPèwŸÿÿ3À·È‹Á‰~‰~‰~ÁáÁ~«««¹˜õƒÄF+Î¿  Šˆ@Ou÷†  ¾   Šˆ@Nu÷_^Ã‹ÿU‹ìì  ¡pğ3Å‰EüSW…èúÿÿPÿvÿ$¿   …À„û   3Àˆ„üşÿÿ@;ÇrôŠ…îúÿÿÆ…üşÿÿ „Àt.ïúÿÿ¶È¶;Èw+Á@P”üşÿÿj Rè´ÿÿƒÄCŠC„ÀuØj ÿv…üúÿÿÿvPW…üşÿÿPjj è¹,  3ÛSÿv…üıÿÿWPW…üşÿÿPWÿvSèÎ0  ƒÄDSÿv…üüÿÿWPW…üşÿÿPh   ÿvSè©0  ƒÄ$3À·ŒEüúÿÿöÁt€LŠŒüıÿÿëöÁt€L ŠŒüüÿÿˆŒ  ëÆ„   @;Çr¾ëV†  Ç…äúÿÿŸÿÿÿ3É)…äúÿÿ‹•äúÿÿ„  ĞZ ƒûw€LŠÑ€Â ëƒúw€L ŠÑ€ê ˆëÆ  A;ÏrÂ‹Mü_3Í[èÙŠÿÿÉÃjh8ªè³¡ÿÿè¥ÿÿ‹ø¡8ı…Gptƒl t‹wh…öuj èá©ÿÿY‹ÆèË¡ÿÿÃjè}ïÿÿYƒeü ‹wh‰uä;5Àùt6…ötVÿD€…Àuş˜õtVèØÿÿY¡Àù‰Gh‹5Àù‰uäVÿ<€ÇEüşÿÿÿè   ë‹uäjèBîÿÿYÃ‹ÿU‹ìƒìS3ÛSMğèü°ÿÿ‰|ƒşşuÇ|   ÿ,8]ütE‹Møƒapıë<ƒşıuÇ|   ÿ(ëÛƒşüu‹Eğ‹@Ç|   ëÄ8]üt‹Eøƒ`pı‹Æ[ÉÃ‹ÿU‹ìƒì ¡pğ3Å‰EüS‹]V‹uWèdÿÿÿ‹ø3ö‰};şu‹Ãè·üÿÿ3Àé  ‰uä3À9¸Èù„‘   ÿEäƒÀ0=ğ   rçÿèı  „p  ÿéı  „d  ·ÇPÿ0…À„R  EèPWÿ$…À„3  h  CVPèÔ›ÿÿ3ÒBƒÄ‰{‰s9Uè†ø   €}î „Ï   uïŠ„É„Â   ¶Fÿ¶Éé¦   h  CVPè›ÿÿ‹MäƒÄkÉ0‰uà±Øù‰uäë*ŠF„Àt(¶>¶Àë‹EàŠ€ÄùD;¶FG;øvê‹}FF€> uÑ‹uäÿEàƒÆƒ}à‰uäré‹Ç‰{ÇC   ègûÿÿj‰CC‰ÌùZf‹1Af‰0A@@Juó‹óè×ûÿÿé·şÿÿ€L@;ÁvöFF€~ÿ …4ÿÿÿC¹ş   €@Iuù‹Cèûÿÿ‰C‰Së‰s3À·È‹ÁÁáÁ{«««ë¨95|…XşÿÿƒÈÿ‹Mü_^3Í[èÔ‡ÿÿÉÃjhXªè®ÿÿƒMàÿè¢ÿÿ‹ø‰}ÜèÜüÿÿ‹_h‹uèuıÿÿ‰E;C„W  h   è¥ÿÿY‹Ø…Û„F  ¹ˆ   ‹wh‹ûó¥ƒ# Sÿuè¸ıÿÿYY‰Eà…À…ü   ‹uÜÿvhÿD€…Àu‹Fh=˜õtPè´›ÿÿY‰^hS‹=<€ÿ×öFp…ê   ö8ı…İ   jèşëÿÿYƒeü ‹C£Œ‹C£‹C£”3À‰Eäƒø}f‹LCf‰E€@ëè3À‰Eä=  }ŠLˆˆ¸÷@ëé3À‰Eä=   }ŠŒ  ˆˆÀø@ëæÿ5ÀùÿD€…Àu¡Àù=˜õtPèûšÿÿY‰ÀùSÿ×ÇEüşÿÿÿè   ë0jèwêÿÿYÃë%ƒøÿu û˜õtSèÅšÿÿYè}«ÿÿÇ    ëƒeà ‹EàèfÿÿÃƒ=p! ujıèVşÿÿYÇp!   3ÀÃjhxªèöœÿÿ‹M3ÿ;Ïv.jàX3Ò÷ñ;EÀ@uè!«ÿÿÇ    WWWWWèÕÿÿƒÄ3ÀéÕ   ¯M‹ñ‰u;÷u3öF3Û‰]äƒşàwiƒ=@ uKƒÆƒæğ‰u‹E;, w7jè€êÿÿY‰}üÿuè†òÿÿY‰EäÇEüşÿÿÿè_   ‹]ä;ßtÿuWSè,˜ÿÿƒÄ;ßuaVjÿ5üÿ¤€‹Ø;ßuL9=Tt3Vèj›ÿÿY…À…rÿÿÿ‹E;Ç„PÿÿÿÇ    éEÿÿÿ3ÿ‹ujè$éÿÿYÃ;ßu‹E;ÇtÇ    ‹Ãè*œÿÿÃjh˜ªèØ›ÿÿ‹]…Ûuÿuè0šÿÿYéÌ  ‹u…öuSè@™ÿÿYé·  ƒ=@ …“  3ÿ‰}äƒşà‡Š  jèéÿÿY‰}üSè¶éÿÿY‰Eà;Ç„   ;5, wIVSPè˜îÿÿƒÄ…Àt‰]äë5VègñÿÿY‰Eä;Çt'‹CüH;Ær‹ÆPSÿuäè"¼ÿÿSèféÿÿ‰EàSPèŒéÿÿƒÄ9}äuH;÷u3öF‰uƒÆƒæğ‰uVWÿ5üÿ¤€‰Eä;Çt ‹CüH;Ær‹ÆPSÿuäèÎ»ÿÿSÿuàè?éÿÿƒÄÇEüşÿÿÿè.   ƒ}à u1…öuFƒÆƒæğ‰uVSj ÿ5üÿ ‹øë‹u‹]jè¾çÿÿYÃ‹}ä…ÿ…¿   9=Tt,Vè¾™ÿÿY…À…Òşÿÿè¸¨ÿÿ9}àul‹ğÿt€Pèc¨ÿÿY‰ë_…ÿ…ƒ   è“¨ÿÿ9}àthÇ    ëq…öuFVSj ÿ5üÿ ‹ø…ÿuV9Tt4VèU™ÿÿY…ÀtƒşàvÍVèE™ÿÿYèG¨ÿÿÇ    3Àè7šÿÿÃè4¨ÿÿé|ÿÿÿ…ÿuè&¨ÿÿ‹ğÿt€PèÖ§ÿÿ‰Y‹ÇëÒ‹ÿU‹ì‹E£˜£œ£ £¤]Ã‹ÿU‹ì‹E‹˜ğV9Pt‹ñköuƒÀ;ÆrìkÉM^;Ás9Pt3À]Ãÿ5 è=šÿÿYÃj h¸ªè[™ÿÿ3ÿ‰}ä‰}Ø‹]ƒûLt‹ÃjY+Át"+Át+Átd+ÁuDèœÿÿ‹ø‰}Ø…ÿuƒÈÿéa  ¾˜¡˜ë`ÿw\‹Óè]ÿÿÿ‹ğƒÆ‹ëZ‹Ãƒèt<ƒèt+Htè3§ÿÿÇ    3ÀPPPPPèåŠÿÿƒÄë®¾ ¡ ë¾œ¡œë
¾¤¡¤ÇEä   Pèy™ÿÿ‰EàY3Àƒ}à„Ø   9EàujèL£ÿÿ9EätPè}æÿÿY3À‰Eüƒût
ƒûtƒûu‹O`‰MÔ‰G`ƒûu@‹Od‰MĞÇGdŒ   ƒûu.‹Œğ‰MÜ‹ğ‹ŒğÊ9MÜ}‹MÜkÉ‹W\‰DÿEÜëÛèá˜ÿÿ‰ÇEüşÿÿÿè   ƒûuÿwdSÿUàYë‹]‹}Øƒ}ä tj èåÿÿYÃSÿUàYƒût
ƒûtƒûu‹EÔ‰G`ƒûu‹EĞ‰Gd3Àèı—ÿÿÃ‹ÿU‹ì‹E£¬]Ã‹ÿU‹ì‹E£°]ÃjhØªè—ÿÿƒeü ÿuÿuÿ8‰Eäë/‹Eì‹ ‹ ‰Eà3É=  À”Á‹ÁÃ‹eè}à  ÀujÿÀ€ƒeä ÇEüşÿÿÿ‹Eäè—ÿÿÃ‹ÿU‹ìQQ‹EV‹u‰Eø‹EWV‰Eüè#&  ƒÏÿY;ÇuèV¥ÿÿÇ 	   ‹Ç‹×ëJÿuMüQÿuøPÿ<‰Eø;Çuÿt€…Àt	PèH¥ÿÿYëÏ‹ÆÁø‹…` ƒæÁæD0€ ı‹Eø‹Uü_^ÉÃjhøªè¨–ÿÿƒÎÿ‰uÜ‰uà‹Eƒøşuèí¤ÿÿƒ  èÒ¤ÿÿÇ 	   ‹Æ‹ÖéĞ   3ÿ;Ç|;D r!èÃ¤ÿÿ‰8è©¤ÿÿÇ 	   WWWWWè]ˆÿÿƒÄëÈ‹ÈÁù` ‹ğƒæÁæ‹¾L1ƒáu&è‚¤ÿÿ‰8èh¤ÿÿÇ 	   WWWWWèˆÿÿƒÄƒÊÿ‹Âë[Pè%  Y‰}ü‹öD0tÿuÿuÿuÿuè©şÿÿƒÄ‰EÜ‰Uàëè¤ÿÿÇ 	   è"¤ÿÿ‰8ƒMÜÿƒMàÿÇEüşÿÿÿè   ‹EÜ‹Uàèë•ÿÿÃÿuè¼%  YÃ‹ÿU‹ì¸ä  èäáÿÿ¡pğ3Å‰Eü‹EV3ö‰…4åÿÿ‰µ8åÿÿ‰µ0åÿÿ9uu3Àéé  ;Æu'è°£ÿÿ‰0è–£ÿÿVVVVVÇ    èJ‡ÿÿƒÄƒÈÿé¾  SW‹}‹ÇÁø4…` ‹ƒçÁçÇŠX$ÛĞû‰µ(åÿÿˆ'åÿÿ€ût€ûu0‹M÷ÑöÁu&èG£ÿÿ3ö‰0è+£ÿÿVVVVVÇ    èß†ÿÿƒÄéC  ö@ tjj j ÿuè~ıÿÿƒÄÿuèi  Y…À„  ‹öD€„  èî—ÿÿ‹@l3É9H…åÿÿ”ÁP‹ÿ4‰ åÿÿÿD…À„`  3É9 åÿÿt„Û„P  ÿ@‹4åÿÿ‰…åÿÿ3À‰…<åÿÿ9E†B  ‰…DåÿÿŠ…'åÿÿ„À…g  Š‹µ(åÿÿ3À€ù
”À‰… åÿÿ‹Çƒx8 tŠP4ˆUôˆMõƒ`8 jEôPëK¾ÁPèí  Y…Àt:‹4åÿÿ+ËM3À@;È†¥  j…@åÿÿSPèq  ƒÄƒøÿ„±  Cÿ…DåÿÿëjS…@åÿÿPèM  ƒÄƒøÿ„  3ÀPPjMôQj@åÿÿQPÿµåÿÿCÿ…Dåÿÿÿô€‹ğ…ö„\  j …<åÿÿPVEôP‹…(åÿÿ‹ ÿ4ÿĞ€…À„)  ‹…Dåÿÿ‹0åÿÿÁ9µ<åÿÿ‰…8åÿÿŒ  ƒ½ åÿÿ „Í   j …<åÿÿPjEôP‹…(åÿÿ‹ ÆEôÿ4ÿĞ€…À„Ğ  ƒ½<åÿÿŒÏ  ÿ…0åÿÿÿ…8åÿÿéƒ   <t<u!·33Éfƒş
”ÁCCƒ…Dåÿÿ‰µ@åÿÿ‰ åÿÿ<t<uRÿµ@åÿÿèÀ"  Yf;…@åÿÿ…h  ƒ…8åÿÿƒ½ åÿÿ t)jXP‰…@åÿÿè“"  Yf;…@åÿÿ…;  ÿ…8åÿÿÿ…0åÿÿ‹E9…Dåÿÿ‚ùıÿÿé'  ‹Šÿ…8åÿÿˆT4‹‰D8é  3É‹Çö@€„¿  ‹…4åÿÿ‰@åÿÿ„Û…Ê   ‰…<åÿÿ9M†   ë‹µ(åÿÿ‹<åÿÿƒ¥Dåÿÿ +4åÿÿ…Håÿÿ;Ms9‹•<åÿÿÿ…<åÿÿŠA€ú
uÿ…0åÿÿÆ @ÿ…Dåÿÿˆ@ÿ…Dåÿÿ½Dåÿÿÿ  rÂ‹Ø…Håÿÿ+Øj …,åÿÿPS…HåÿÿP‹ÿ4ÿĞ€…À„B  ‹…,åÿÿ…8åÿÿ;ÃŒ:  ‹…<åÿÿ+…4åÿÿ;E‚Lÿÿÿé   ‰…Dåÿÿ€û…Ñ   9M†M  ë‹µ(åÿÿ‹Dåÿÿƒ¥<åÿÿ +4åÿÿ…Håÿÿ;MsF‹•Dåÿÿƒ…Dåÿÿ·AAfƒú
uƒ…0åÿÿj[f‰@@ƒ…<åÿÿƒ…<åÿÿf‰@@½<åÿÿş  rµ‹Ø…Håÿÿ+Øj …,åÿÿPS…HåÿÿP‹ÿ4ÿĞ€…À„b  ‹…,åÿÿ…8åÿÿ;ÃŒZ  ‹…Dåÿÿ+…4åÿÿ;E‚?ÿÿÿé@  9M†|  ‹Dåÿÿƒ¥<åÿÿ +4åÿÿj…Hùÿÿ^;Ms<‹•Dåÿÿ·µDåÿÿÎfƒú
uj[f‰Æµ<åÿÿµ<åÿÿf‰Æ½<åÿÿ¨  r¿3öVVhU  ğëÿÿQHùÿÿ+Á™+ÂÑøP‹ÁPVhéı  ÿô€‹Ø;Ş„—   j …,åÿÿP‹Ã+ÆP„5ğëÿÿP‹…(åÿÿ‹ ÿ4ÿĞ€…Àtµ,åÿÿ;ŞËëÿt€‰…@åÿÿ;Ş\‹…Dåÿÿ+…4åÿÿ‰…8åÿÿ;E‚
ÿÿÿë?j ,åÿÿQÿuÿµ4åÿÿÿ0ÿĞ€…Àt‹…,åÿÿƒ¥@åÿÿ ‰…8åÿÿëÿt€‰…@åÿÿƒ½8åÿÿ ulƒ½@åÿÿ t-j^9µ@åÿÿuèÿÿÇ 	   è&ÿÿ‰0ë?ÿµ@åÿÿè*ÿÿYë1‹µ(åÿÿ‹öD@t‹…4åÿÿ€8u3Àë$èŞœÿÿÇ    èæœÿÿƒ  ƒÈÿë‹…8åÿÿ+…0åÿÿ_[‹Mü3Í^è‚wÿÿÉÃjh«è\ÿÿ‹Eƒøşuèªœÿÿƒ  èœÿÿÇ 	   ƒÈÿé   3ÿ;Ç|;D r!èœÿÿ‰8ègœÿÿÇ 	   WWWWWè€ÿÿƒÄëÉ‹ÈÁù` ‹ğƒæÁæ‹¾L1ƒát¿Pèc  Y‰}ü‹öD0tÿuÿuÿuè.øÿÿƒÄ‰EäëèœÿÿÇ 	   èœÿÿ‰8ƒMäÿÇEüşÿÿÿè	   ‹EäèÜÿÿÃÿuè­  YÃ‹ÿU‹ìÿ´h   è”ÿÿY‹M‰A…ÀtƒIÇA   ëƒIA‰AÇA   ‹Aƒa ‰]Ã‹ÿU‹ì‹Eƒøşuèy›ÿÿÇ 	   3À]ÃV3ö;Æ|;D rè[›ÿÿVVVVVÇ 	   èÿÿƒÄ3Àë‹ÈƒàÁù‹` Áà¾Dƒà@^]Ã¸¸úÃ¡  Vj^…Àu¸   ë;Æ}‹Æ£  jPè˜“ÿÿYY£…ÀujV‰5  è“ÿÿYY£…ÀujX^Ã3Ò¹¸úë¡‰ƒÁ ƒÂù8ı|êjş^3Ò¹ÈúW‹ÂÁø‹…` ‹úƒçÁç‹ƒøÿt;Æt…Àu‰1ƒÁ Bù(û|Î_3À^ÃèW  €=¸ tè   ÿ5è”‰ÿÿYÃ‹ÿU‹ìV‹u¸¸ú;ğr"şıw‹Î+ÈÁùƒÁQèİÙÿÿN €  Yë
ƒÆ Vÿ€^]Ã‹ÿU‹ì‹Eƒø}ƒÀPè°Ùÿÿ‹EH €  Y]Ã‹EƒÀ Pÿ€]Ã‹ÿU‹ì‹E¹¸ú;Ár=ıw`ÿÿÿ+ÁÁøƒÀPèØÿÿY]ÃƒÀ Pÿ€]Ã‹ÿU‹ì‹Mƒù‹E}`ÿÿÿƒÁQè^ØÿÿY]ÃƒÀ Pÿ€]Ã‹ÿU‹ì‹EV3ö;Æuè^™ÿÿVVVVVÇ    è}ÿÿƒÄƒÈÿë‹@^]Ã‹ÿU‹ìƒì¡pğ3Å‰EüSV‹uöF@W…6  Vè¦ÿÿÿY»àòƒøÿt.Vè•ÿÿÿYƒøşt"Vè‰ÿÿÿÁøV<…` èyÿÿÿƒàYÁàYë‹ÃŠ@$$<„è   VèXÿÿÿYƒøÿt.VèLÿÿÿYƒøşt"Vè@ÿÿÿÁøV<…` è0ÿÿÿƒàYÁàYë‹ÃŠ@$$<„Ÿ   VèÿÿÿYƒøÿt.VèÿÿÿYƒøşt"Vè÷şÿÿÁøV<…` èçşÿÿƒàYÁàYë‹Ãö@€t]ÿuEôjPEğPè   ƒÄ…Àt¸ÿÿ  ë]3ÿ9}ğ~0ÿNx‹ŠL=ôˆ‹¶A‰ë¾D=ôVPèD˜ÿÿYYƒøÿtÈG;}ğ|Ğf‹Eë ƒFşx‹‹Ef‰ƒë·EVPè¿  YY‹Mü_^3Í[è‹rÿÿÉÃ¡pğƒÈ3É9¸”Á‹ÁÃ‹ÿU‹ìƒìSV‹u3Û;ót9]t8u‹E;Ãt3Éf‰3À^[ÉÃÿuMğè™ÿÿ‹Eğ9Xu‹E;Ãtf¶f‰8]üt‹Eøƒ`pı3À@ëÊEğP¶PèÄ   YY…Àt}‹Eğ‹ˆ¬   ƒù~%9M| 3Ò9]•ÂRÿuQVj	ÿpÿH…À‹Eğu‹M;ˆ¬   r 8^t‹€¬   8]ü„eÿÿÿ‹MøƒapıéYÿÿÿèÍ–ÿÿÇ *   8]üt‹Eøƒ`pıƒÈÿé:ÿÿÿ3À9]•ÀPÿu‹EğjVj	ÿpÿH…À…:ÿÿÿëº‹ÿU‹ìj ÿuÿuÿuèÔşÿÿƒÄ]Ã‹ÿU‹ìƒìÿuMğè˜ÿÿ¶E‹Mğ‹‰È   ·A% €  €}ü t‹MøƒapıÉÃ‹ÿU‹ìj ÿuè¹ÿÿÿYY]ÃÌÌÌÌÌÌÌV‹D$Àu(‹L$‹D$3Ò÷ñ‹Ø‹D$÷ñ‹ğ‹Ã÷d$‹È‹Æ÷d$ÑëG‹È‹\$‹T$‹D$ÑéÑÛÑêÑØÉuô÷ó‹ğ÷d$‹È‹D$÷æÑr;T$wr;D$v	N+D$T$3Û+D$T$÷Ú÷ØƒÚ ‹Ê‹Ó‹Ù‹È‹Æ^Â ‹ÿU‹ìƒìSVWèş‡ÿÿƒeü ƒ=¼ ‹Ø…   hx‹ÿ4‹ø…ÿ„*  ‹5¬€hl‹WÿÖ…À„  PèH‡ÿÿÇ$\‹W£¼ÿÖPè3‡ÿÿÇ$H‹W£ÀÿÖPè‡ÿÿÇ$,‹W£ÄÿÖPè	‡ÿÿY£Ì…Àth‹WÿÖPèñ†ÿÿY£È¡È;ÃtO9ÌtGPèO‡ÿÿÿ5Ì‹ğèB‡ÿÿYY‹ø…öt,…ÿt(ÿÖ…ÀtMøQjMìQjPÿ×…ÀtöEôu	M    ë9¡À;Ãt0Pèÿ†ÿÿY…Àt%ÿĞ‰Eü…Àt¡Ä;ÃtPèâ†ÿÿY…ÀtÿuüÿĞ‰Eüÿ5¼èÊ†ÿÿY…ÀtÿuÿuÿuÿuüÿĞë3À_^[ÉÃ‹ÿU‹ì‹ES3ÛVW;Ãt‹};ûwè”ÿÿj^‰0SSSSSèºwÿÿƒÄ‹Æë<‹u;óuˆëÚ‹Ğ8tBOuø;ûtîŠˆ
BF:ËtOuó;ûuˆè¾“ÿÿj"Y‰‹ñëµ3À_^[]Ã‹ÿU‹ìSV‹u3ÛW9]u;óu9]u3À_^[]Ã;ót‹};ûwè|“ÿÿj^‰0SSSSSè1wÿÿƒÄ‹ÆëÕ9]uˆëÊ‹U;ÓuˆëÑƒ}ÿ‹ÆuŠ
ˆ@B:ËtOuóëŠ
ˆ@B:ËtOtÿMuî9]uˆ;ûu‹ƒ}ÿu‹EjPˆ\ÿXéxÿÿÿˆè“ÿÿj"Y‰‹ñë‚‹ÿU‹ì‹MV3ö;Î|ƒù~ƒùu¡@ë(¡@‰@ëèÇ’ÿÿVVVVVÇ    è{vÿÿƒÄƒÈÿ^]Ã‹ÿU‹ìƒìÿuMğèH”ÿÿ‹Eğƒ¸¬   ~EğPjÿuès  ƒÄë‹€È   ‹M·Hƒà€}ü t‹MøƒapıÉÃ‹ÿU‹ìƒ=X u‹E‹xõ·Aƒà]Ãj ÿuè…ÿÿÿYY]Ã‹ÿU‹ì‹E…Àtƒè8İİ  uPèTÿÿY]ÃU‹ìƒì‰}ü‰uø‹u‹}‹MÁéë›    fofoNfoV fo^0ffOfW f_0fof@fonPfov`fo~pfg@foPfw`fp¶€   ¿€   Iu£‹uø‹}ü‹å]ÃU‹ìƒì‰}ô‰uø‰]ü‹]‹Ã™‹È‹E3Ê+Êƒá3Ê+Ê™‹ø3ú+úƒç3ú+ú‹Ñ×uJ‹u‹Îƒá‰Mè;ñt+ñVSPè'ÿÿÿƒÄ‹E‹Mè…Étw‹]‹UÓ+Ñ‰UìØ+Ù‰]ğ‹uì‹}ğ‹Mèó¤‹EëS;Ïu5÷ÙƒÁ‰Mä‹u‹}‹Mäó¤‹MMä‹UUä‹E+EäPRQèLÿÿÿƒÄ‹Eë‹u‹}‹M‹ÑÁéó¥‹Êƒáó¤‹E‹]ü‹uø‹}ô‹å]Ã‹ÿU‹ìƒìÿuMğè?’ÿÿ¶E‹MôŠU„Tuƒ} t‹Mğ‹‰È   ·A#Eë3À…Àt3À@€}ü t‹MøƒapıÉÃ‹ÿU‹ìjj ÿuj èšÿÿÿƒÄ]Ã‹ÿU‹ì3À@ƒ} u3À]ÃU‹ìSVWUj j hà#ÿuè~C  ]_^[‹å]Ã‹L$÷A   ¸   t2‹D$‹Hü3Èè¸jÿÿU‹h‹P(R‹P$Rè   ƒÄ]‹D$‹T$‰¸   ÃSVW‹D$UPjşhè#dÿ5    ¡pğ3ÄPD$d£    ‹D$(‹X‹pƒşÿt:ƒ|$,ÿt;t$,v-4v‹³‰L$‰Hƒ|³ uh  ‹D³èI   ‹D³è_   ë·‹L$d‰    ƒÄ_^[Ã3Àd‹    yè#u‹Q‹R9Qu¸   ÃSQ»PıëSQ»Pı‹L$‰K‰C‰kUQPXY]Y[Â ÿĞÃÌU‹ìW‹}3ÀƒÉÿò®ƒÁ÷ÙƒïŠEıò®ƒÇ8t3Àë‹Çü_ÉÃ‹ÿU‹ìƒìSVÿuMèè[ÿÿ‹]¾   ;ŞsT‹Mèƒ¹¬   ~EèPjSè|  ‹MèƒÄë‹È   ·Xƒà…Àt‹Ì   ¶é£   €}ô t‹Eğƒ`pı‹Ãéœ   ‹Eèƒ¸¬   ~1‰]Á}EèP‹E%ÿ   Pè·÷ÿÿYY…ÀtŠEjˆEüˆ]ıÆEş YëèÿÿÇ *   3Éˆ]üÆEı A‹EèjÿpUøjRQMüQVÿpEèPèÑ  ƒÄ$…À„oÿÿÿƒø¶Eøt	¶MùÁàÁ€}ô t‹Mğƒapı^[ÉÃ‹ÿU‹ìƒ=X u‹EH¿ƒùwƒÀ ]Ãj ÿuèÃşÿÿYY]Ã‹ÿU‹ìƒì(¡pğ3Å‰EüSV‹uWÿu‹}MÜè	ÿÿEÜP3ÛSSSSWEØPEğPèÆ   ‰EìEğVPè1  ƒÄ(öEìu+ƒøu8]èt‹Eäƒ`pıjXë/ƒøu8]èt‹Eäƒ`pıjëèöEìuêöEìuÎ8]èt‹Eäƒ`pı3À‹Mü_^3Í[è¬gÿÿÉÃ‹ÿU‹ìƒì(¡pğ3Å‰EüSV‹uWÿu‹}MÜèaÿÿEÜP3ÛSSSSWEØPEğPè   ‰EìEğVPèÍ  ƒÄ(öEìu+ƒøu8]èt‹Eäƒ`pıjXë/ƒøu8]èt‹Eäƒ`pıjëèöEìuêöEìuÎ8]èt‹Eäƒ`pı3À‹Mü_^3Í[ègÿÿÉÃ‹ÿU‹ì‹MSV‹u3ÛW‹y;óuèŒÿÿj^‰0SSSSSèËoÿÿƒÄ‹Æé…   9]vİ‹U;Óˆ~‹Âë3À@9EwèŞ‹ÿÿj"Y‰‹ñëÄ;ÓÆ0F~Š:Ët¾ÉGëj0Yˆ@J;Óé‹M;Óˆ|€?5|ëÆ 0H€89t÷ş €>1uÿAë~WèÖqÿÿ@PWVèí¡ÿÿƒÄ3À_^[]Ã‹ÿU‹ìQ‹U·BS‹ÈVWÁé% €  ¿ÿ  #Ï‰E‹B‹·Ù¾   €%ÿÿ ‰uü…Ût;ßtÁ <  ë(¿ÿ  ë$3Û;Ãu;Óu‹Ef‹M‰X‰ëLÁ<  ‰]ü·ù‹ÊÁéÁàÈMü‹EÁâ‰H‰…Îu‹‹P‹ÙÒÁëÓÉÇÿÿ  ‰P‰…Ötá‹MÏ_^f‰H[ÉÃ‹ÿU‹ìƒì0¡pğ3Å‰Eü‹ES‹]V‰EĞWEPEğPèÿÿÿYYEÔPj jƒìuğ‹ü¥¥f¥èê$  ‹uĞ‰C¾EÖ‰¿EÔ‰CEØPÿuVèU ÿÿƒÄ$…Àt3ÀPPPPPèÙlÿÿƒÄ‹Mü_‰s^‹Ã3Í[èødÿÿÉÃÌÌÌÌÌÌWVU3ÿ3í‹D$À}GE‹T$÷Ø÷ÚƒØ ‰D$‰T$‹D$À}G‹T$÷Ø÷ÚƒØ ‰D$‰T$Àu(‹L$‹D$3Ò÷ñ‹Ø‹D$÷ñ‹ğ‹Ã÷d$‹È‹Æ÷d$ÑëG‹Ø‹L$‹T$‹D$ÑëÑÙÑêÑØÛuô÷ñ‹ğ÷d$‹È‹D$÷æÑr;T$wr;D$v	N+D$T$3Û+D$T$My÷Ú÷ØƒÚ ‹Ê‹Ó‹Ù‹È‹ÆOu÷Ú÷ØƒÚ ]^_Â Ì€ù@s€ù s­ĞÓêÃ‹Â3Ò€áÓèÃ3À3ÒÃjè%ƒÿÿYÃ‹ÿU‹ì‹E‹M%ÿÿ÷ÿ#ÈV÷Áàüğüt1W‹}3ö;ştVVè¸-  YY‰èãˆÿÿj_VVVVV‰8è˜lÿÿƒÄ‹Ç_ë‹uPÿu…öt	èˆ-  ‰ëè-  YY3À^]Ã‹ÿU‹ìV‹u…ö„  ÿvèÕwÿÿÿvèÍwÿÿÿvèÅwÿÿÿvè½wÿÿÿvèµwÿÿÿvè­wÿÿÿ6è¦wÿÿÿv èwÿÿÿv$è–wÿÿÿv(èwÿÿÿv,è†wÿÿÿv0è~wÿÿÿv4èvwÿÿÿvènwÿÿÿv8èfwÿÿÿv<è^wÿÿƒÄ@ÿv@èSwÿÿÿvDèKwÿÿÿvHèCwÿÿÿvLè;wÿÿÿvPè3wÿÿÿvTè+wÿÿÿvXè#wÿÿÿv\èwÿÿÿv`èwÿÿÿvdèwÿÿÿvhèwÿÿÿvlèûvÿÿÿvpèóvÿÿÿvtèëvÿÿÿvxèãvÿÿÿv|èÛvÿÿƒÄ@ÿ¶€   èÍvÿÿÿ¶„   èÂvÿÿÿ¶ˆ   è·vÿÿÿ¶Œ   è¬vÿÿÿ¶   è¡vÿÿÿ¶”   è–vÿÿÿ¶˜   è‹vÿÿÿ¶œ   è€vÿÿÿ¶    èuvÿÿÿ¶¤   èjvÿÿÿ¶¨   è_vÿÿƒÄ,^]Ã‹ÿU‹ìV‹u…öt5‹;(ştPè<vÿÿY‹F;,ştPè*vÿÿY‹v;50ştVèvÿÿY^]Ã‹ÿU‹ìV‹u…öt~‹F;4ştPèöuÿÿY‹F;8ştPèäuÿÿY‹F;<ştPèÒuÿÿY‹F;@ştPèÀuÿÿY‹F;DştPè®uÿÿY‹F ;HştPèœuÿÿY‹v$;5LştVèŠuÿÿY^]ÃÌÌÌÌU‹ìV3ÀPPPPPPPP‹UI Š
Àt	ƒÂ«$ëñ‹uƒÉÿI ƒÁŠ
Àt	ƒÆ£$sî‹ÁƒÄ ^ÉÃ‹ÿU‹ìQQ¡pğ3Å‰Eü¡SV3ÛW‹ù;Ãu:EøP3öFVhÔ›Vÿh€…Àt‰5ë4ÿt€ƒøxu
jX£ë¡ƒø„Ï   ;Ã„Ç   ƒø…è   ‰]ø9]u‹‹@‰E‹5H3À9] SSÿu•ÀÿuÅ   PÿuÿÖ‹ø;û„«   ~<ÿğÿÿw4D?=   wè>sÿÿ‹Ä;ÃtÇ ÌÌ  ëPè9uÿÿY;Ãt	Ç İİ  ƒÀ‹Ø…Ûti?Pj SèŠrÿÿƒÄWSÿuÿujÿuÿÖ…ÀtÿuPSÿuÿh€‰EøSèòÿÿ‹EøYëu3ö9]u‹‹@‰E9]u‹‹@‰Eÿuè~,  Yƒøÿu3ÀëG;EtSSMQÿuPÿuè¦,  ‹ğƒÄ;ótÜ‰uÿuÿuÿuÿuÿuÿP‹ø;ótVè—sÿÿY‹Çeì_^[‹Mü3Íè_ÿÿÉÃ‹ÿU‹ìƒìÿuMğèÚ…ÿÿÿu$Mğÿu ÿuÿuÿuÿuÿuèşÿÿƒÄ€}ü t‹MøƒapıÉÃÌÌÌÌÌÌÌÌÌÌÌÌÌÌU‹ìV3ÀPPPPPPPP‹UI Š
Àt	ƒÂ«$ëñ‹u‹ÿŠ
ÀtƒÆ£$sñFÿƒÄ ^ÉÃ‹ÿU‹ìƒì¡pğ3Å‰EüSV3ÛW‹ñ9u8SS3ÿGWhÔ›h   Sÿ`€…Àt‰=ëÿt€ƒøxu
Ç   9]~"‹M‹EI8t@;ËuöƒÉÿ‹E+ÁH;E}@‰E¡ƒø„¬  ;Ã„¤  ƒø…Ì  ‰]ø9] u‹‹@‰E ‹5H3À9]$SSÿu•ÀÿuÅ   Pÿu ÿÖ‹ø;û„  ~Cjà3ÒX÷÷ƒør7D?=   wèÆpÿÿ‹Ä;ÃtÇ ÌÌ  ëPèÁrÿÿY;Ãt	Ç İİ  ƒÀ‰Eôë‰]ô9]ô„>  Wÿuôÿuÿujÿu ÿÖ…À„ã   ‹5`€SSWÿuôÿuÿuÿÖ‹È‰Mø;Ë„Â   ÷E   t)9]„°   ;M§   ÿuÿuWÿuôÿuÿuÿÖé   ;Ë~Ejà3ÒX÷ñƒør9D	=   wèpÿÿ‹ô;ótjÇÌÌ  ƒÆëPèÿqÿÿY;Ãt	Ç İİ  ƒÀ‹ğë3ö;ótAÿuøVWÿuôÿuÿuÿ`€…Àt"SS9]uSSëÿuÿuÿuøVSÿu ÿô€‰EøVèYïÿÿYÿuôèPïÿÿ‹EøYéY  ‰]ô‰]ğ9]u‹‹@‰E9] u‹‹@‰E ÿuè))  Y‰Eìƒøÿu3Àé!  ;E „Û   SSMQÿuPÿu èG)  ƒÄ‰Eô;ÃtÔ‹5d€SSÿuPÿuÿuÿÖ‰Eø;Ãu3öé·   ~=ƒøàw8ƒÀ=   wèñnÿÿ‹ü;ûtİÇÌÌ  ƒÇëPèépÿÿY;Ãt	Ç İİ  ƒÀ‹øë3ÿ;ût´ÿuøSWè8nÿÿƒÄÿuøWÿuÿuôÿuÿuÿÖ‰Eø;Ãu3öë%ÿuEøÿuPWÿu ÿuìè–(  ‹ğ‰uğƒÄ÷Şö#uøWè.îÿÿYëÿuÿuÿuÿuÿuÿuÿd€‹ğ9]ôt	ÿuôèuoÿÿY‹Eğ;Ãt9EtPèboÿÿY‹Æeà_^[‹Mü3ÍèİZÿÿÉÃ‹ÿU‹ìƒìÿuMğè¥ÿÿÿu(Mğÿu$ÿu ÿuÿuÿuÿuÿuè(üÿÿƒÄ €}ü t‹MøƒapıÉÃ‹ÿU‹ì‹MS3Û;ËVW|[;D sS‹ÁÁø‹ñ<…` ‹ƒæÁæÆö@t5ƒ8ÿt0ƒ=Du+ËtItIuSjôëSjõëSjöÿ\€‹ƒÿ3ÀëèUÿÿÇ 	   è]ÿÿ‰ƒÈÿ_^[]Ã‹ÿU‹ì‹EƒøşuèAÿÿƒ  è&ÿÿÇ 	   ƒÈÿ]ÃV3ö;Æ|";D s‹ÈƒàÁù‹` ÁàÁö@u$è ÿÿ‰0èæ~ÿÿVVVVVÇ 	   èšbÿÿƒÄƒÈÿë‹ ^]Ãjh8«èupÿÿ‹}‹ÇÁø‹÷ƒæÁæ4…` ÇEä   3Û9^u6j
èH¾ÿÿY‰]ü9^uh   FPè™ØÿÿYY…Àu‰]äÿFÇEüşÿÿÿè0   9]ät‹ÇÁøƒçÁç‹…` D8Pÿ€‹Eäè5pÿÿÃ3Û‹}j
è½ÿÿYÃ‹ÿU‹ì‹E‹ÈƒàÁù‹` ÁàDPÿ€]Ã‹ÿU‹ìƒì¡pğ3Å‰EüV3ö95pştOƒ=dÿşuè¯'  ¡dÿƒøÿu¸ÿÿ  ëpVMğQjMQPÿP€…Àugƒ=pşuÚÿt€ƒøxuÏ‰5pşVVjEôPjEPVÿT€Pÿô€‹dÿƒùÿt¢VUğRPEôPQÿX€…Àtf‹E‹Mü3Í^èXÿÿÉÃÇpş   ëãjhX«èénÿÿ3Û‰]äjèÜ¼ÿÿY‰]üj_‰}à;=  }W‹÷Áæ¡Æ9tD‹ ö@ƒtPè'  YƒøÿtÿEäƒÿ|(¡‹ƒÀ Pÿ,€¡ÿ4è
lÿÿY¡‰GëÇEüşÿÿÿè	   ‹Eäè¥nÿÿÃjè}»ÿÿYÃ‹ÿU‹ìSV‹u‹F‹È€á3Û€ùu@©  t9‹FW‹>+ø…ÿ~,WPVèøâÿÿYPè³ßÿÿƒÄ;Çu‹F„Àyƒàı‰FëƒN ƒËÿ_‹Fƒf ‰^‹Ã[]Ã‹ÿU‹ìV‹u…öu	Vè5   Yë/Vè|ÿÿÿY…ÀtƒÈÿë÷F @  tVèâÿÿPè'  Y÷ØYÀë3À^]Ãjhx«èšmÿÿ3ÿ‰}ä‰}ÜjèŠ»ÿÿY‰}ü3ö‰uà;5  ƒ   ¡°98t^‹ ö@ƒtVPVè”áÿÿYY3ÒB‰Uü¡‹°‹HöÁƒt/9UuPèJÿÿÿYƒøÿtÿEäë9}uöÁtPè/ÿÿÿYƒøÿu	EÜ‰}üè   Fë„3ÿ‹uà¡ÿ4°VèáÿÿYYÃÇEüşÿÿÿè   ƒ}‹Eät‹EÜèmÿÿÃjèó¹ÿÿYÃjèÿÿÿYÃ‹ÿU‹ìQV‹uVè‰áÿÿ‰E‹FY¨‚uèëzÿÿÇ 	   ƒN ¸ÿÿ  é=  ¨@tèÎzÿÿÇ "   ëá¨tƒf ¨„   ‹Nƒàş‰‰F‹Fƒf ƒeü Sjƒàï[Ã‰F©  u,èaßÿÿƒÀ ;ğtèUßÿÿƒÀ@;ğuÿuèâŞÿÿY…ÀuVèŞÿÿY÷F  W„ƒ   ‹F‹>H‰‹N+ø+Ë‰N…ÿ~WPÿuèİÿÿƒÄ‰EüëNƒÈ ‰Fé=ÿÿÿ‹Mƒùÿtƒùşt‹Áƒà‹ÑÁúÁà•` ë¸àòö@ tSj j QèéÔÿÿ#ÂƒÄƒøÿt-‹F‹]f‰ëjEüPÿu‹û‹]f‰]üè	İÿÿƒÄ‰Eü9}ütƒN ¸ÿÿ  ë‹Ã%ÿÿ  _[^ÉÃ‹ÿU‹ìƒìSV‹u3ÛW‹};óu;ûv‹E;Ãt‰3Àéƒ   ‹E;ÃtƒÿÿÿÿÿvèUyÿÿj^SSSSS‰0è
]ÿÿƒÄ‹ÆëVÿuMğèázÿÿ‹Eğ9X…œ   f‹E¹ÿ   f;Áv6;ót;ûvWSVèšfÿÿƒÄèyÿÿÇ *   è÷xÿÿ‹ 8]üt‹Møƒapı_^[ÉÃ;ót2;ûw,è×xÿÿj"^SSSSS‰0èŒ\ÿÿƒÄ8]ü„yÿÿÿ‹Eøƒ`pıémÿÿÿˆ‹E;ÃtÇ    8]ü„%ÿÿÿ‹Eøƒ`pıéÿÿÿMQSWVjMQS‰]ÿpÿô€;Ãt9]…^ÿÿÿ‹M;Ët½‰ë¹ÿt€ƒøz…Dÿÿÿ;ó„gÿÿÿ;û†_ÿÿÿWSVèÃeÿÿƒÄéOÿÿÿ‹ÿU‹ìj ÿuÿuÿuÿuè|şÿÿƒÄ]Ã‹ÿU‹ìƒìSÿuMèè§yÿÿ‹]C=   w‹Eè‹€È   ·Xëu‰]Á}EèP‹E%ÿ   PèSáÿÿYY…ÀtŠEjˆEøˆ]ùÆEú Yë
3Éˆ]øÆEù A‹EèjÿpÿpEüPQEøPEèjPèDóÿÿƒÄ …Àu8Eôt‹Eğƒ`pı3Àë·Eü#E€}ô t‹Mğƒapı[ÉÃÌÌÌÌÌÌ‹D$‹L$È‹L$u	‹D$÷áÂ S÷á‹Ø‹D$÷d$Ø‹D$÷áÓ[Â ‹ÿU‹ìj
j ÿuè2%  ƒÄ]Ã‹ÿU‹ìƒì,‹E·H
S‹Ùá €  ‰Mì‹H‰Mà‹H· ãÿ  ëÿ?  ÁàW‰Mä‰EèûÀÿÿu'3Û3À9\…àu@ƒø|ô3Àé¥  3À}à««j«Xé•  ƒe Vuà}Ô¥¥¥‹5ˆşNN‹Á™ƒâÂÁø‹Ñâ  €‰]ğ‰EôyJƒÊàB|…àj3ÀY+Ê@Óà‰Mø…„   ‹EôƒÊÿÓâ÷Ò…T…àëƒ|…à u@ƒø|óën‹Æ™jY#ÑÂÁøæ  €yNƒÎàFƒeü +Î3ÒBÓâL…à‹1ò‰u‹19ur"9Uë…Ét+ƒeü L…à‹r‰u;òrƒşsÇEü   H‹U‰‹MüyÑ‰M‹MøƒÈÿÓà!‹Eô@ƒø}jY|…à+È3Àó«ƒ} tC¡„ş‹È+ˆş;Ù}3À}à«««é  ;Ø  +EğuÔ‹È}à¥™ƒâÂ¥‹ÑÁøâ  €¥yJƒÊàBƒeô ƒe ƒÏÿ‹ÊÓçÇEü    )Uü÷×‹]\à‹3‹Î#Ï‰Mğ‹ÊÓî‹Müuô‰3‹uğÓæÿEƒ}‰uô|Ó‹ğjÁæMèZ+Î;Ğ|‹1‰t•àëƒd•à Jƒé…Ò}ç‹5ˆşNN‹Á™ƒâÂÁø‹Ñâ  €‰EôyJƒÊàBjY+Ê3ÒBÓâ\…à‰Mğ…„‚   ƒÊÿÓâ÷Ò…T…àëƒ|…à u@ƒø|óëf‹Æ™jY#ÑÂÁøæ  €yNƒÎàFƒe 3Ò+ÎBÓâL…à‹1<;şr;úsÇE   ‰9‹Më…ÉtL…à‹r3ÿ;òrƒşs3ÿG‰1‹ÏHyŞ‹MğƒÈÿÓà!‹Eô@ƒø}jY|…à+È3Àó«‹ŒşA‹Á™ƒâÂ‹ÑÁøâ  €yJƒÊàBƒeô ƒe ƒÏÿ‹ÊÓçÇEü    )Uü÷×‹]\à‹3‹Î#Ï‰Mğ‹ÊÓî‹Müuô‰3‹uğÓæÿEƒ}‰uô|Ó‹ğjÁæMèZ+Î;Ğ|‹1‰t•àëƒd•à Jƒé…Ò}çj3ÛXéZ  ;€ş‹ŒşŒ­   3À}à«««Mà   €‹Á™ƒâÂ‹ÑÁøâ  €yJƒÊàBƒeô ƒe ƒÏÿ‹ÊÓçÇEü    )Uü÷×‹]\à‹3‹Î#Ï‰Mğ‹ÊÓî‹Müuô‰3‹uğÓæÿEƒ}‰uô|Ó‹ğjÁæMèZ+Î;Ğ|‹1‰t•àëƒd•à Jƒé…Ò}ç¡€ş‹”ş3À@é›   ¡”şeàÿÿÿØ‹Á™ƒâÂ‹ÑÁøâ  €yJƒÊàBƒeô ƒe ƒÎÿ‹ÊÓæÇEü    )Uü÷Ö‹M‹|à‹Ï#Î‰Mğ‹ÊÓï‹M}ô‰|à‹}ğ‹MüÓçÿEƒ}‰}ô|Ğ‹ğjÁæMèZ+Î;Ğ|‹1‰t•àëƒd•à Jƒé…Ò}ç3À^jY+ŒşÓã‹Mì÷ÙÉá   €Ù‹ş]àƒù@u‹M‹Uä‰Y‰ë
ƒù u‹M‰_[ÉÃ‹ÿU‹ìƒì,‹E·H
S‹Ùá €  ‰Mì‹H‰Mà‹H· ãÿ  ëÿ?  ÁàW‰Mä‰EèûÀÿÿu'3Û3À9\…àu@ƒø|ô3Àé¥  3À}à««j«Xé•  ƒe Vuà}Ô¥¥¥‹5 şNN‹Á™ƒâÂÁø‹Ñâ  €‰]ğ‰EôyJƒÊàB|…àj3ÀY+Ê@Óà‰Mø…„   ‹EôƒÊÿÓâ÷Ò…T…àëƒ|…à u@ƒø|óën‹Æ™jY#ÑÂÁøæ  €yNƒÎàFƒeü +Î3ÒBÓâL…à‹1ò‰u‹19ur"9Uë…Ét+ƒeü L…à‹r‰u;òrƒşsÇEü   H‹U‰‹MüyÑ‰M‹MøƒÈÿÓà!‹Eô@ƒø}jY|…à+È3Àó«ƒ} tC¡œş‹È+ ş;Ù}3À}à«««é  ;Ø  +EğuÔ‹È}à¥™ƒâÂ¥‹ÑÁøâ  €¥yJƒÊàBƒeô ƒe ƒÏÿ‹ÊÓçÇEü    )Uü÷×‹]\à‹3‹Î#Ï‰Mğ‹ÊÓî‹Müuô‰3‹uğÓæÿEƒ}‰uô|Ó‹ğjÁæMèZ+Î;Ğ|‹1‰t•àëƒd•à Jƒé…Ò}ç‹5 şNN‹Á™ƒâÂÁø‹Ñâ  €‰EôyJƒÊàBjY+Ê3ÒBÓâ\…à‰Mğ…„‚   ƒÊÿÓâ÷Ò…T…àëƒ|…à u@ƒø|óëf‹Æ™jY#ÑÂÁøæ  €yNƒÎàFƒe 3Ò+ÎBÓâL…à‹1<;şr;úsÇE   ‰9‹Më…ÉtL…à‹r3ÿ;òrƒşs3ÿG‰1‹ÏHyŞ‹MğƒÈÿÓà!‹Eô@ƒø}jY|…à+È3Àó«‹¤şA‹Á™ƒâÂ‹ÑÁøâ  €yJƒÊàBƒeô ƒe ƒÏÿ‹ÊÓçÇEü    )Uü÷×‹]\à‹3‹Î#Ï‰Mğ‹ÊÓî‹Müuô‰3‹uğÓæÿEƒ}‰uô|Ó‹ğjÁæMèZ+Î;Ğ|‹1‰t•àëƒd•à Jƒé…Ò}çj3ÛXéZ  ;˜ş‹¤şŒ­   3À}à«««Mà   €‹Á™ƒâÂ‹ÑÁøâ  €yJƒÊàBƒeô ƒe ƒÏÿ‹ÊÓçÇEü    )Uü÷×‹]\à‹3‹Î#Ï‰Mğ‹ÊÓî‹Müuô‰3‹uğÓæÿEƒ}‰uô|Ó‹ğjÁæMèZ+Î;Ğ|‹1‰t•àëƒd•à Jƒé…Ò}ç¡˜ş‹¬ş3À@é›   ¡¬şeàÿÿÿØ‹Á™ƒâÂ‹ÑÁøâ  €yJƒÊàBƒeô ƒe ƒÎÿ‹ÊÓæÇEü    )Uü÷Ö‹M‹|à‹Ï#Î‰Mğ‹ÊÓï‹M}ô‰|à‹}ğ‹MüÓçÿEƒ}‰}ô|Ğ‹ğjÁæMèZ+Î;Ğ|‹1‰t•àëƒd•à Jƒé…Ò}ç3À^jY+¤şÓã‹Mì÷ÙÉá   €Ù‹¨ş]àƒù@u‹M‹Uä‰Y‰ë
ƒù u‹M‰_[ÉÃ‹ÿU‹ìƒì|¡pğ3Å‰Eü‹ES3ÛV3ö‰Eˆ‹EF3ÉW‰E}à‰]Œ‰u˜‰]´‰]¨‰]¤‰] ‰]œ‰]°‰]”9]$uè.lÿÿSSSSSÇ    èâOÿÿƒÄ3ÀéN  ‹U‰U¬Š< t<	t<
t<uBëë³0ŠBƒù‡/  ÿ$:NŠÈ€é1€ùwjYJëİ‹M$‹	‹‰¼   ‹	:ujYëÇ¾Àƒè+tHHtƒè…‹  ‹Îë®jYÇEŒ €  ë¢ƒeŒ jYë™ŠÈ€é1‰u¨€ùv©‹M$‹	‹‰¼   ‹	:ujë­<+t(<-t$:Ãt¹<C<  <E~<c0  <e(  jëJjéyÿÿÿŠÈ€é1€ù†Rÿÿÿ‹M$‹	‹‰¼   ‹	:„Tÿÿÿ:Ã„fÿÿÿ‹U¬é  ‰u¨ë<9ƒ}´s
ÿE´*ÃˆGëÿE°ŠB:Ã}â‹M$‹	‹‰¼   ‹	:„]ÿÿÿ<+t‰<-t…é`ÿÿÿƒ}´ ‰u¨‰u¤u&ëÿM°ŠB:Ãtöë<9Õƒ}´sÿE´*ÃˆGÿM°ŠB:Ã}äë»*Ã‰u¤<	‡nÿÿÿjéşÿÿJş‰M¬ŠÈ€é1€ùwj	é‡şÿÿ¾Àƒè+t HHtƒè…;ÿÿÿjé‚şÿÿƒM˜ÿjYé@şÿÿjéoşÿÿ‰u ëŠB:Ãtù,1<v¸Jë(ŠÈ€é1€ùv«:Ãë½ƒ}  tG¾Àƒè+Jÿ‰M¬tÂHHt²‹Ñƒ}¨ ‹E‰„Ù  jX9E´v€}÷|şE÷OÿE°‰E´ƒ}´ †Ş  ëYj
YJƒù
…¼ıÿÿë¾‰u 3Éë<9 kÉ
¾ğL1ĞùP  	ŠB:Ã}ãë¹Q  ‰Mœë<9[ÿÿÿŠB:Ã}ñéOÿÿÿÿM´ÿE°O€? tôEÄPÿu´EàPè£  ‹Eœ3ÒƒÄ9U˜}÷ØE°9U uE9U¤u+E=P  "  =°ëÿÿŒ.  ¹hÿƒé`‰E¬;Â„é  }÷Ø¹È ‰E¬ƒé`9Uu3Àf‰EÄ9U¬„Æ  ë‹M„3Ò‹E¬Á}¬ƒÁTƒà‰M„;Â„  kÀÁ‹Ø¸ €  f9r‹ó}¸¥¥¥ÿMº]¸·K
3À‰E°‰EÔ‰EØ‰EÜ‹EÎ‹ñºÿ  3ğ#Â#Êæ €  ¿ÿ  ‰u·Òf;Çƒ!  f;Ïƒ  ¿ı¿  f;×‡
  ¾¿?  f;Öw3À‰EÈ‰EÄé  3öf;ÆuB÷EÌÿÿÿu9uÈu9uÄu3Àf‰EÎéë  f;Îu!B÷Cÿÿÿu9su93u‰uÌ‰uÈ‰uÄéÅ  ‰u˜}ØÇE¨   ‹E˜‹M¨À‰Mœ…É~RDÄ‰E¤C‰E ‹E ‹M¤·	· ƒe´ ¯Á‹Oü4;ñr;ğsÇE´   ƒ}´ ‰wütfÿƒE¤ƒm ÿMœƒ}œ »GGÿE˜ÿM¨ƒ}¨ ‘ÂÀ  f…Ò~7‹}Ü…ÿx+‹uØ‹EÔÑeÔÁè‹ÎöğÁé?ÁÂÿÿ  ‰uØ‰EÜf…ÒÎf…ÒMÂÿÿ  f…Ò}B‹Â÷Ø·ğÖöEÔtÿE°‹EÜ‹}Ø‹MØÑmÜÁàÑïø‹EÔÁáÑèÁN‰}Ø‰EÔuÑ9u°tfƒMÔ¸ €  ‹Èf9MÔw‹MÔáÿÿ ù € u4ƒ}Öÿu+ƒeÖ ƒ}ÚÿuƒeÚ ¹ÿÿ  f9MŞuf‰EŞBëfÿEŞëÿEÚëÿEÖ¸ÿ  f;Ğr#3À3Éf9E‰EÈ”Á‰EÄIá   €Á €ÿ‰MÌë;f‹EÖUf‰EÄ‹EØ‰EÆ‹EÜ‰EÊf‰UÎë3Àf…ö”ÀƒeÈ H%   € €ÿƒeÄ ‰EÌƒ}¬ …<ıÿÿ‹EÌ·MÄ‹uÆ‹UÊÁèë/ÇE”   ë3ö¸ÿ  º   €3ÉÇE”   ëÇE”   3É3À3Ò3ö‹}ˆEŒf‰f‰G
‹E”‰w‰W‹Mü_^3Í[è‰@ÿÿÉÃH`H¶HéH.IfIzIÕIÀI?J4JãI‹ÿU‹ìƒìt¡pğ3Å‰EüS‹]VWu}ğ¥¥f¥‹Uø‹Ê¸ €  #Èâÿ  ‰] ÆEĞÌÆEÑÌÆEÒÌÆEÓÌÆEÔÌÆEÕÌÆEÖÌÆE×ÌÆEØÌÆEÙÌÆEÚûÆEÛ?ÇEŒ   ‰Mf…ÉtÆC-ëÆC ‹uô‹}ğf…Òu/…öu+…ÿu'3Òf;È•ÀşÈ$ f‰ˆCÆCÆC0ˆS3À@é  ¸ÿ  f;Ğ…Ÿ   3À@f‰¸   €;ğu…ÿt÷Æ   @uhğ›ëQf…Étş   Àu…ÿu;hè›ë;ğu0…ÿu,hà›CjPèqzÿÿƒÄ3ö…ÀtVVVVVèõFÿÿƒÄÆCë*hØ›CjPèEzÿÿƒÄ3ö…ÀtVVVVVèÉFÿÿƒÄÆC3Àéq  ·Ê‹ÙiÉM  Áë‹ÆÁèCkÀM„í¼ìÁø·À3É¿Øf‰Mà¹hÿ÷Ûƒé`‰E´f‰Uê‰uæ‰}â‰Mœ…Û„œ  }¸È ÷Ûƒè`‰Eœ…Û„…  ƒEœT‹ËƒáÁû…É„g  kÉMœ‹Á‰M¼¹ €  f9r‹ğ}Ä¥¥EÄ¥ÿMÆ‰E¼·P
3É‰M¬‰Mğ‰Mô‰Mø‹Mê‹ò3ñæ €  ‰u¸¾ÿ  #Î#Ö4
·ş¾ÿ  f;Îƒ¬  f;Öƒ£  ¾ı¿  f;ş‡•  ¾¿?  f;şw3ö‰uè‰uä‰uàéÓ  3öf;ÎuG÷Eèÿÿÿu9uäu9uàu3Àf‰Eêé­  f;ÖuG÷@ÿÿÿu	9pu90t´!u¨uôÇEÀ   ‹M¨‹UÀÉ‰U°…Ò~ULàƒÀ‰M”‰E˜‹E”·‹E˜· ‹Vü¯Èƒe¤ 
;Âr;ÁsÇE¤   ƒ}¤ ‰FütfÿƒE”ƒm˜ÿM°ƒ}° »‹E¼FFÿE¨ÿMÀƒ}À ÇÀ  f…ÿ~;÷Eø   €u-‹Eô‹MğÑeğ‹ĞÀÁéÁ‰Eô‹EøÁêÀÂÇÿÿ  ‰Eøf…ÿÊf…ÿMÇÿÿ  f…ÿ}B‹Ç÷Ø·ÀøöEğtÿE¬‹Mø‹uô‹UôÑmøÁáÑîñ‹MğÁâÑéÊH‰uô‰MğuÑ9E¬tfƒMğ¸ €  ‹Èf9Mğw‹Mğáÿÿ ù € u4ƒ}òÿu+ƒeò ƒ}öÿuƒeö ¹ÿÿ  f9Múuf‰EúGëfÿEúëÿEöëÿEò¸ÿ  f;ø‚«   3À3Éf9E¸‰Eä”Á‰EàIá   €Á €ÿ‰Mè3ö;Ş…{ıÿÿ‹MèÁéºÿ?  ¸ÿ  f;Ê‚£  ÿE´3Ò‰U°‰Uğ‰Uô‰Uø‹UÚ·É‹Ú3Ù#È#Ğã €  ‹ø4
‰]¤·öf;ÏƒL  f;ĞƒC  ¸ı¿  f;ğ‡5  ¸¿?  f;ğwK3À‰Eä‰Eàé9  f‹Eò}¸f‰Eà‹Eô‰Eâ‹Eø‰Eæf‰}êéVÿÿÿ3À3öf9u¸”ÀH%   € €ÿ‰Eèé\ıÿÿ3Àf;ÈuF÷Eèÿÿÿu9Eäu9Eàu	f‰EêéÚ  f;ĞuF÷EØÿÿÿu9EÔu	9EĞ„vÿÿÿ‰E¨}ôÇEÀ   ‹E¨‹MÀÀ‰M¬…É~JMØ‰M¸Dà‹M¸··	ƒe¼ ¯Ê‹Wü
;Úr;ÙsÇE¼   ƒ}¼ ‰_ütfÿƒm¸@@ÿM¬ƒ}¬ ÀGGÿE¨ÿMÀƒ}À ™ÆÀ  f…ö~7‹}ø…ÿx+‹Eô‹MğÑeğ‹ĞÀÁéÁ‰EôÁê?ÂÆÿÿ  ‰Eøf…öÎf…öMÆÿÿ  f…ö}B‹Æ÷Ø·ÀğöEğtÿE°‹Mø‹}ô‹UôÑmøÁáÑïù‹MğÁâÑéÊH‰}ô‰MğuÑ9E°tfƒMğ¸ €  ‹Èf9Mğw‹Mğáÿÿ ù € u4ƒ}òÿu+ƒeò ƒ}öÿuƒeö ¹ÿÿ  f9Múuf‰EúFëfÿEúëÿEöëÿEò¸ÿ  f;ğr#3À3Éf9E¤‰Eä”Á‰EàIá   €Á €ÿ‰Mèë;f‹Eòu¤f‰Eà‹Eô‰Eâ‹Eø‰Eæf‰uêë3Àf…Û”Àƒeä H%   € €ÿƒeà ‰EèöE‹U ‹E´‹}f‰t2˜ø…ÿ+3Àf‰¸ €  f9EÆB•ÀşÈ$ ˆBÆB0ÆB é^ùÿÿƒÿ~j_‹uèÁîîş?  3Àf‰EêÇE¼   ‹Eà‹]ä‹MäÑeàÁèÛØ‹EèÁéÀÁÿM¼‰]ä‰EèuØ…ö}2÷Şæÿ   ~(‹Eè‹]ä‹MäÑmèÁàÑëØ‹EàÁáÑèÁN‰]ä‰Eà…öØGZ‰]À‰E´…Àµ   ‹Uà‹Eäuà}Ä¥¥¥Ñeà‹}àÑeàÁê Ê‹Uè‹ğÁîÒÖ‹Á4	Áè‹UÄÁïÈ‹Eà÷<;ør;úsF3Ò;Ærƒøs3ÒB‹ğ…ÒtA‹EÈ0‰U¼;Ör;ĞsAMÌÁêÉÊ4?‰uà‹u¼‰MèÁéö€Á0‹ÇÁèğˆCÿM´ƒ}´ ‰uäÆEë KÿÿÿKŠK<5}‹MÀëD€;9u	Æ0K;]Àsò‹E ;]ÀsCfÿ ş*Ø€ë¾ËˆXÆD ‹EŒ‹Mü_^3Í[èq7ÿÿÉÃ€;0uK;Ùsö‹E ;ÙsÍ3Òf‰º €  f9UÆ@•ÂşÊ€â€Â ˆPÆ0Æ@ é÷ÿÿ3ÀöÃt@öÃtƒÈöÃtƒÈöÃtƒÈöÃtƒÈ ÷Ã   tƒÈ‹Ëº   #ÊV¾   t#ù   t;Ît;Êu   ë   ë   ‹Ëá   tù   uÆëÂ^÷Ã   t   Ã3ÀöÂt¸€   SVW»   öÂtÃöÂt   öÂt   öÂt   ¿   ÷Â   tÇ‹Ê¾   #Ît;Ït;Ët;Îu `  ë @  ë    ¹   _#Ñ^[ú   tú   t
;Ñu €  ÃƒÈ@Ã@€  Ã‹ÿU‹ìƒìSVW›Ù}ø‹]ø3ÒöÃtjZöÃtƒÊöÃtƒÊöÃtƒÊöÃ tƒÊöÃtÊ   ·Ë‹Á¾   #Æ¿   t$=   t=   t;Æu×ëÊ   ëÊ   #Ïtù   uÊ   ëÊ   ÷Ã   tÊ   ‹}‹M‹Ç÷Ğ#Â#ÏÁ‰E;Â„®   ‹Øè
şÿÿ·À‰EüÙmü›Ù}ü‹]ü3ÒöÃtjZöÃtƒÊöÃtƒÊöÃtƒÊöÃ tƒÊöÃtÊ   ·Ë‹Á#Æt(=   t=   t;ÆuÊ   ëÊ   ëÊ   á   tù   uÊ   ëÊ   ÷Ã   tÊ   ‰U‹Â3ö95< „  ç‰}ì®]ğ‹Eğ„Àyj^©   tƒÎ©   tƒÎ©   tƒÎ©   tƒÎ©   tÎ   ‹È» `  #Ët*ù    tù @  t;ËuÎ   ëÎ   ëÎ   ¿@€  #Çƒè@t-À  tƒè@uÎ   ëÎ   ëÎ   ‹Eì‹Ğ#E÷Ò#ÖĞ;Öu‹Æé°   èıÿÿP‰Eôè	  Y®]ô‹Mô3Ò„ÉyjZ÷Á   tƒÊ÷Á   tƒÊ÷Á   tƒÊ÷Á   tƒÊ¾   …ÎtÊ   ‹Á#Ãt$=    t= @  t;ÃuÊ   ë
Ê   ëÖ#Ïƒé@téÀ  tƒé@uÊ   ëÊ   ëÊ   ‹Â‹È3ME÷Á t   €_^[ÉÃ‹ÿU‹ìƒì¡pğ3Å‰EüjEôPh  ÿuÆEú ÿL…ÀuƒÈÿë
EôPèÍàÿÿY‹Mü3Íè®2ÿÿÉÃ‹ÿU‹ìƒì4¡pğ3Å‰Eü‹E‹M‰EØ‹ES‰EĞ‹ V‰EÜ‹EW3ÿ‰MÌ‰}à‰}Ô;E„_  ‹5$MèQPÿÖ‹H…Àt^ƒ}èuXEèPÿuÿÖ…ÀtKƒ}èuE‹uÜÇEÔ   ƒşÿuÿuØè¥=ÿÿ‹ğYF;÷~[şğÿÿwSD6=   w/èEEÿÿ‹Ä;Çt8Ç ÌÌ  ë-WWÿuÜÿuØjÿuÿÓ‹ğ;÷uÃ3ÀéÑ   Pè$GÿÿY;Çt	Ç İİ  ƒÀ‰Eäë‰}ä9}ätØ6PWÿuäèmDÿÿƒÄVÿuäÿuÜÿuØjÿuÿÓ…Àt‹]Ì;ßtWWÿuSVÿuäWÿuÿô€…Àt`‰]àë[‹ô€9}ÔuWWWWVÿuäWÿuÿÓ‹ğ;÷t<VjèOÿÿYY‰Eà;Çt+WWVPVÿuäWÿuÿÓ;Çuÿuàè™EÿÿY‰}àëƒ}Üÿt‹MĞ‰ÿuäèÄÿÿY‹EàeÀ_^[‹Mü3Íèú0ÿÿÉÃ3ÀPPjPjh   @h8œÿL€£dÿÃ¡dÿV‹50€ƒøÿtƒøştPÿÖ¡`ÿƒøÿtƒøştPÿÖ^Ã‹ÿU‹ìSV‹uW3ÿƒËÿ;÷uèÃUÿÿWWWWWÇ    èw9ÿÿƒÄÃëBöFƒt7VèÙÿÿV‹Øè  Vè ¼ÿÿPè)  ƒÄ…À}ƒËÿë‹F;Çt
PèµDÿÿY‰~‰~‹Ã_^[]Ãjh «èGÿÿƒMäÿ3À‹u3ÿ;÷•À;Çuè@UÿÿÇ    WWWWWèô8ÿÿƒÄƒÈÿëöF@t‰~‹EäèGÿÿÃVèÀºÿÿY‰}üVè*ÿÿÿY‰EäÇEüşÿÿÿè   ëÕ‹uVè»ÿÿYÃjhÀ«è•Fÿÿ‹EƒøşuèĞTÿÿÇ 	   ƒÈÿéª   3Û;Ã|;D rè¯TÿÿÇ 	   SSSSSèc8ÿÿƒÄëĞ‹ÈÁù<` ‹ğƒæÁæ‹¾LƒátÆPè«ÕÿÿY‰]ü‹öDt1ÿuèÕÿÿYPÿH€…Àuÿt€‰Eäë‰]ä9]ätèNTÿÿ‹Mä‰è1TÿÿÇ 	   ƒMäÿÇEüşÿÿÿè	   ‹EäèFÿÿÃÿuèáÕÿÿYÃ‹ÿU‹ìƒìVWÿuMìè Uÿÿ‹E‹u3ÿ;Çt‰0;÷u,èÜSÿÿWWWWWÇ    è7ÿÿƒÄ€}ø t‹Eôƒ`pı3ÀéØ  9}tƒ}|Éƒ}$Ã‹MìSŠ‰}ü~ƒ¹¬   ~EìP¶ÃjPèrÛÿÿ‹MìƒÄë‹‘È   ¶Ã·Bƒà…ÀtŠGëÇ€û-uƒMë€û+uŠG‹E…ÀŒK  ƒø„B  ƒø$9  …Àu*€û0t	ÇE
   ë4Š<xt<Xt	ÇE   ë!ÇE   ë
ƒøu€û0uŠ<xt<XuGŠG‹±È   ¸ÿÿÿÿ3Ò÷u¶Ë·NöÁt¾Ëƒé0ë÷Á  t1ŠË€éa€ù¾Ëwƒé ƒÁÉ;MsƒM9Eür'u;Êv!ƒMƒ} u#‹EO¨u ƒ} t‹}ƒeü ë[‹]ü¯]Ù‰]üŠGë‹¾ÿÿÿ¨u¨u=ƒàt	}ü   €w	…Àu+9uüv&è;RÿÿöEÇ "   tƒMüÿëöEj X•ÀÆ‰Eü‹E…Àt‰8öEt÷]ü€}ø t‹Eôƒ`pı‹Eüë‹E…Àt‰0€}ø t‹Eôƒ`pı3À[_^ÉÃ‹ÿU‹ì3ÀPÿuÿuÿu9XuhõëPè«ıÿÿƒÄ]Ã‹ÿU‹ìƒì¡pğ3Å‰Eü‹ESV3öWÇEèN@  ‰0‰p‰p9u†F  ‹‹X‹ğ}ğ¥¥¥‹ÊÁé<Ñ‹H‹óÁîÉÎ‰}ì‹÷ƒeì ‹ÚÁëÉÁïË‹]ğöÒ×<‰0‰P‰H;şr;ûsÇEì   3Û‰89]ìtr;òrƒşs3ÛC‰p…ÛtA‰H‹H‹Uô3ö;Ùr;Ús3öF‰X…ötÿ@‹MøHƒeì ?‹×Áê<ú‹P‹óÁî‹UŞ‰‰x‰X¾4‰Uğ;ñr;òsÇEì   ƒ}ì ‰0tO3Ò;Ïrƒùs3ÒB‰H…ÒtC‰XÿMÿEƒ} ‡äşÿÿ3öë&‹H‹ÑÁê‰P‹‹úÁáÁïÏÁâEèğÿ  ‰H‰9ptÕ» €  …Xu0‹0‹xEèÿÿ  ‹ÎöÁé‰04?ñ‹H‹×ÁêÉÊ‰p‰H…ËtĞf‹Mèf‰H
‹Mü_^3Í[è²*ÿÿÉÃjhà«èŒAÿÿ3À9< tVöE@tH9<t@‰Eü®Uë.‹Eì‹ ‹ =  Àt
=  Àt3ÀÃ3À@Ã‹eèƒ%< ƒe¿®UÇEüşÿÿÿëƒe¿®UèlAÿÿÃÌÌÌÌÌÌÌÌÌÌÌÌÌÌU‹ìWVS‹MÉtM‹u‹}·A³Z¶ I Š&
äŠt'
Àt#ƒÆƒÇ:çr:ãwæ:Çr:ÃwÆ:àuƒéuÑ3É:àt	¹ÿÿÿÿr÷Ù‹Á[^_ÉÃ‹ÿU‹ìV‹uWVè¯ÏÿÿYƒøÿtP¡` ƒşu	ö€„   uƒşuö@Dtjè„Ïÿÿj‹øè{ÏÿÿYY;ÇtVèoÏÿÿYPÿ0€…Àu
ÿt€‹øë3ÿVèËÎÿÿ‹ÆÁø‹…` ƒæÁæYÆD0 …ÿtWè•NÿÿYƒÈÿë3À_^]Ãjh ¬è@ÿÿ‹Eƒøşuè]Nÿÿƒ  èBNÿÿÇ 	   ƒÈÿé   3ÿ;Ç|;D r!è4Nÿÿ‰8èNÿÿÇ 	   WWWWWèÎ1ÿÿƒÄëÉ‹ÈÁù` ‹ğƒæÁæ‹¾L1ƒát¿PèÏÿÿY‰}ü‹öD0tÿuèËşÿÿY‰Eäëè¿MÿÿÇ 	   ƒMäÿÇEüşÿÿÿè	   ‹Eäè?ÿÿÃÿuèoÏÿÿYÃ‹ÿU‹ìV‹u‹F¨ƒt¨tÿvè¼<ÿÿf÷ûÿÿ3ÀY‰‰F‰F^]ÃÌÌÌÌÌBÿ[Ã¤$    d$ 3ÀŠD$S‹ØÁà‹T$÷Â   tŠ
ƒÂ:ËtÏ„ÉtQ÷Â   uëØW‹ÃÁãVØ‹
¿ÿşş~‹Á‹÷3Ëğùƒñÿƒğÿ3Ï3ÆƒÂá u% tÓ% uæ   €uÄ^_[3ÀÃ‹Bü:Ãt6„Àtï:ãt'„ätçÁè:Ãt„ÀtÜ:ãt„ätÔë–^_Bÿ[ÃBş^_[ÃBı^_[ÃBü^_[Ãÿ% €ÌÌÌÌÌÌÌÌÌÌÌÌMØéHÿÿ‹T$B‹J¬3Èè7'ÿÿ¸ğ¥é4ÿÿ‹T$B‹Jì3Èè'ÿÿ¸©éö3ÿÿÌÌ‹EğPè'ÿÿYÃ‹T$Bü‹Jø3Èèô&ÿÿ¸Ğ¬éÎ3ÿÿÌÌÌÌÌÌÌÌÌÌ‹EPèæ&ÿÿYÃ‹T$Bø‹Jô3ÈèÄ&ÿÿ¸ü¬é3ÿÿÌÌÌÌÌÌÌÌÌÌ‹T$B‹Jä3ÈèŸ&ÿÿ¸T­éy3ÿÿÌÌÌÌÌ‹T$B‹Jì3Èè&ÿÿ¸¬­éY3ÿÿÌÌÌÌÌ‹T$B‹JÔ3Èè_&ÿÿ¸8®é93ÿÿÌÌÌÌÌ‹}ğƒÇdé…ÿÿ‹}ğƒÇhézÿÿ‹T$Bì‹Jè3Èè)&ÿÿ¸l®é3ÿÿÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌ}éHÿÿ‹T$Bô‹Jğ3Èè÷%ÿÿ¸˜®éÑ2ÿÿÌÌÌÌÌÌÌÌÌÌÌÌÌ}éÿÿ}éÿÿ}éÿÿ}é ÿÿ‹T$Bì‹Jè3Èè¯%ÿÿ¸Ü®é‰2ÿÿÌÌÌÌÌ}éØÿÿ}éĞÿÿ}éÈÿÿ‹T$Bğ‹Jì3Èèw%ÿÿ¸¯éQ2ÿÿÌÌÌÌÌÌÌÌÌÌÌÌÌ}é˜ÿÿ}éÿÿ}éˆÿÿ‹T$Bô‹Jğ3Èè7%ÿÿ¸T¯é2ÿÿÌÌÌÌÌÌÌÌÌÌÌÌÌ}éXÿÿ}éPÿÿ‹T$Bğ‹Jì3Èèÿ$ÿÿ¸ˆ¯éÙ1ÿÿÌÌÌÌÌ}é(ÿÿ}é ÿÿ‹T$Bğ‹Jì3ÈèÏ$ÿÿ¸¼¯é©1ÿÿÌÌÌÌÌ}éøÿÿ‹T$Bø‹Jô3Èè§$ÿÿ¸è¯é1ÿÿÌÌÌÌÌÌÌÌÌÌÌÌÌ}éÈÿÿ‹T$Bø‹Jô3Èèw$ÿÿ¸°éQ1ÿÿÌÌÌÌÌÌÌÌÌÌÌÌÌ}é˜ÿÿ}éÿÿ}éˆÿÿ}é€ÿÿ}éxÿÿ}épÿÿ‹T$Bä‹Jà3Èè$ÿÿ¸h°éù0ÿÿÌÌÌÌÌ}éHÿÿ}é@ÿÿ}é8ÿÿ}é0ÿÿ‹T$Bì‹Jè3Èèß#ÿÿ¸¬°é¹0ÿÿÌÌÌÌÌ‹Mğéä*ÿÿ‹T$Bô‹Jğ3Èè·#ÿÿ¸Ø°é‘0ÿÿÌÌÌÌÌÌÌÌÌÌÌÌÌ‹T$B‹Jè3Èè#ÿÿ¸0±éi0ÿÿÌÌÌÌÌ‹T$B‹JÜ3Èèo#ÿÿ¸ˆ±éI0ÿÿÌÌÌÌÌ‹}Ôé˜ÿÿ‹}Ğéÿÿ‹}Ìéˆÿÿ‹}Èé€ÿÿ‹}Ìéxÿÿ‹}Ğépÿÿ‹}Èéhÿÿ‹}Ìé`ÿÿ‹}ĞéXÿÿ‹}ÈéPÿÿ‹}ÌéHÿÿ‹}Ğé@ÿÿ‹}Èé8ÿÿ‹}Ìé0ÿÿ‹}Ğé(ÿÿ‹}Èé ÿÿ‹}Ìéÿÿ‹}Ğéÿÿ‹T$B‹JÄ3Èè¿"ÿÿ¸¨²é™/ÿÿÌÌÌÌÌ‹T$B‹Jì3ÈèŸ"ÿÿ¸4³éy/ÿÿÌÌÌÌÌ‹Mğé¤)ÿÿ‹T$Bø‹Jô3Èèw"ÿÿ¸`³éQ/ÿÿÌÌÌÌÌÌÌÌÌÌÌÌÌ‹T$B‹Jè3ÈèO"ÿÿ¸¸³é)/ÿÿÌÌÌÌÌM¬é8ÿÿ‹T$B´‹J°3Èè'"ÿÿ¸ä³é/ÿÿÌÌÌÌÌÌÌÌÌÌÌÌÌ‹}$éHÿÿ‹} é@ÿÿ‹}é8ÿÿ‹}é0ÿÿ‹}é(ÿÿ‹T$B‹Jè3Èè×!ÿÿ¸d´é±.ÿÿÌÌÌÌÌÌÌÌÌÌÌÌÌ‹T$B‹Jè3Èè¯!ÿÿ¸¼´é‰.ÿÿÌÌÌÌÌ‹T$B‹Jì3Èè!ÿÿ¸µéi.ÿÿÌÌÌÌÌ‹T$B‹Jè3Èèo!ÿÿ¸lµéI.ÿÿÌÌÌÌÌ‹T$B‹Jè3ÈèO!ÿÿ¸Äµé).ÿÿÌÌÌÌÌ‹}èéxÿÿ‹}épÿÿ‹T$B‹Jä3Èè!ÿÿ¸,¶éù-ÿÿÌÌÌÌÌ}èéHÿÿ}ìé@ÿÿ}é8ÿÿ} é0ÿÿ‹T$B‹JÄ3Èèß ÿÿ¸¤¶é¹-ÿÿÌÌÌÌÌ}äéÿÿ}èé ÿÿ}ìéøÿÿ}éğÿÿ‹T$B‹JÄ3ÈèŸ ÿÿ¸·éy-ÿÿÌÌÌÌÌ‹T$B‹Jì3Èè ÿÿ¸t·éY-ÿÿÌÌÌÌÌ‹T$B‹Jì3Èè_ ÿÿ¸Ì·é9-ÿÿÌÌÌÌÌ‹T$B‹Jä3Èè? ÿÿ¸$¸é-ÿÿÌÌÌÌÌ‹}èéhÿÿ‹T$B‹Jä3Èè ÿÿ¸„¸éñ,ÿÿÌÌÌÌÌÌÌÌÌÌÌÌÌ‹T$B‹Jä3Èèïÿÿ¸Ü¸éÉ,ÿÿÌÌÌÌÌ‹}èéÿÿ‹}éÿÿ‹T$B‹Jä3Èè¿ÿÿ¸D¹é™,ÿÿÌÌÌÌÌ‹T$B‹Jè3ÈèŸÿÿ¸œ¹éy,ÿÿÌÌÌÌÌ‹}èéÈ ÿÿ‹}éÀ ÿÿ‹T$B‹Jä3Èèoÿÿ¸ºéI,ÿÿÌÌÌÌÌ‹T$B‹Jì3ÈèOÿÿ¸\ºé),ÿÿÌÌÌÌÌ‹T$B‹Jì3Èè/ÿÿ¸´ºé	,ÿÿÌÌÌÌÌ‹T$B‹Jè3Èèÿÿ¸»éé+ÿÿÌÌÌÌÌ‹T$B‹Jè3Èèïÿÿ¸d»éÉ+ÿÿÌÌÌÌÌ‹T$B‹Jì3ÈèÏÿÿ¸¼»é©+ÿÿÌÌÌÌÌ‹T$B‹Jä3Èè¯ÿÿ¸¼é‰+ÿÿÌÌÌÌÌ‹}éØÿşÿ‹T$B‹Jè3Èè‡ÿÿ¸t¼éa+ÿÿÌÌÌÌÌÌÌÌÌÌÌÌÌ‹}èé¨ÿşÿ‹T$B‹Jä3ÈèWÿÿ¸Ô¼é1+ÿÿÌÌÌÌÌÌÌÌÌÌÌÌÌ‹T$B‹Jè3Èè/ÿÿ¸,½é	+ÿÿÌÌÌÌÌ‹T$B‹Jä3Èèÿÿ¸„½éé*ÿÿÌÌÌÌÌ‹T$B‹Jä3Èèïÿÿ¸Ü½éÉ*ÿÿÌÌÌÌÌ‹T$B‹Jä3ÈèÏÿÿ¸4¾é©*ÿÿÌÌÌÌÌ‹T$B‹Jä3Èè¯ÿÿ¸Œ¾é‰*ÿÿÌÌÌÌÌ‹T$B‹Jä3Èèÿÿ¸ä¾éi*ÿÿÌÌÌÌÌ‹T$B‹Jè3Èèoÿÿ¸<¿éI*ÿÿÌÌÌÌÌ‹T$B‹Jä3ÈèOÿÿ¸”¿é)*ÿÿÌÌÌÌÌ‹T$B‹Jä3Èè/ÿÿ¸ì¿é	*ÿÿÌÌÌÌÌ‹T$B‹Jä3Èèÿÿ¸DÀéé)ÿÿÌÌÌÌÌjè.ÿÿ3ÉƒÄ;ÁtÇ ˜ë3Àh¸£˜‰¨‰¬‰°‰´ÿ8€hrèAÿÿYÃÌÌVh¸Ç”¨ÿ,€¾˜èÿÿ¡˜Pè”ÿÿƒÄ^ÃÇ  ‚¹ éˆ#ÿÿ                                                                                                                                                                                                                                                                                                                                                                                                                                            †Ã xÃ fÃ VÃ ”Ã     ÊÂ âÂ úÂ ¾Â Ã 0Ã °Â  Â „Â lÂ Ã TÂ ¸È ªÈ šÈ „È tÈ dÈ TÈ DÈ 2È $Ä 0Ä BÄ RÄ `Ä vÄ †Ä šÄ ®Ä ÊÄ èÄ üÄ Å  Å ,Å 8Å LÅ ^Å lÅ xÅ †Å Å  Å ¨Å ´Å ÂÅ ÎÅ ŞÅ ôÅ Æ Æ &Æ @Æ XÆ rÆ ˆÆ ¢Æ °Æ ¾Æ ÌÆ æÆ öÆ Ç &Ç :Ç JÇ XÇ dÇ nÇ zÇ ŒÇ œÇ ÄÇ ÖÇ æÇ øÇ È  È     ¢  €  €  €  €È  €    ÆÃ ØÃ şÃ ìÃ ¶Ã         Àq        à çñ ˆÏ        ç]€                            ø)ÓX       €   @Ÿ @‡ #      À      F        À      F      À      F£Pƒ ò• ¸¢0‡ €‡ h¢0‡ €‡ ÀŸ\Œ €‡ string too long invalid string position `=ßTe ++Ñp  @” X ÿ• ò• Unknown exception       csmà               “        ÆŸ -² -² P¨EncodePointer   K E R N E L 3 2 . D L L     DecodePointer   FlsFree FlsSetValue FlsGetValue FlsAlloc    CorExitProcess  m s c o r e e . d l l     À         À       –  À         À         À         À         À       ‘  À       ’  À       “  À       runtime error   
  TLOSS error
   SING error
    DOMAIN error
      R6034
An application has made an attempt to load the C runtime library incorrectly.
Please contact the application's support team for more information.
      R6033
- Attempt to use MSIL code from this assembly during native code initialization
This indicates a bug in your application. It is most likely the result of calling an MSIL-compiled (/clr) function from a native constructor or from DllMain.
  R6032
- not enough space for locale information
      R6031
- Attempt to initialize the CRT more than once.
This indicates a bug in your application.
  R6030
- CRT not initialized
  R6028
- unable to initialize heap
    R6027
- not enough space for lowio initialization
    R6026
- not enough space for stdio initialization
    R6025
- pure virtual function call
   R6024
- not enough space for _onexit/atexit table
    R6019
- unable to open console device
    R6018
- unexpected heap error
    R6017
- unexpected multithread lock error
    R6016
- not enough space for thread data
 
This application has requested the Runtime to terminate it in an unusual way.
Please contact the application's support team for more information.
   R6009
- not enough space for environment
 R6008
- not enough space for arguments
   R6002
- floating point support not loaded
    Microsoft Visual C++ Runtime Library    

  ... <program name unknown>  Runtime Error!

Program:    }Ø l ˆÖ ò• bad exception   e+000          À~PA   €ÿÿGAIsProcessorFeaturePresent   KERNEL32    	
 !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~ =   ( n u l l )     (null)             EEE50 P    ( 8PX 700WP        `h````  xpxxxx          GetProcessWindowStation GetUserObjectInformationA   GetLastActivePopup  GetActiveWindow MessageBoxA USER32.DLL   Complete Object Locator'    Class Hierarchy Descriptor'     Base Class Array'   Base Class Descriptor at (  Type Descriptor'   `local static thread guard' `managed vector copy constructor iterator'  `vector vbase copy constructor iterator'    `vector copy constructor iterator'  `dynamic atexit destructor for '    `dynamic initializer for '  `eh vector vbase copy constructor iterator' `eh vector copy constructor iterator'   `managed vector destructor iterator'    `managed vector constructor iterator'   `placement delete[] closure'    `placement delete closure'  `omni callsig'   delete[]    new[]  `local vftable constructor closure' `local vftable' `RTTI   `EH `udt returning' `copy constructor closure'  `eh vector vbase constructor iterator'  `eh vector destructor iterator' `eh vector constructor iterator'    `virtual displacement map'  `vector vbase constructor iterator' `vector destructor iterator'    `vector constructor iterator'   `scalar deleting destructor'    `default constructor closure'   `vector deleting destructor'    `vbase destructor'  `string'    `local static guard'    `typeof'    `vcall' `vbtable'   `vftable'   ^=  |=  &=  <<= >>= %=  /=  -=  +=  *=  ||  &&  |   ^   ~   ()  ,   >=  >   <=  <   %   /   ->* &   +   -   --  ++  *   ->  operator    []  !=  ==  !   <<  >>   delete  new    __unaligned __restrict  __ptr64 __clrcall   __fastcall  __thiscall  __stdcall   __pascal    __cdecl __based(        ‘‘üğäØÌÄ¸¬šŠğ‹Ô‹À‹ ‹„‹¤œ˜Š˜”Œˆ„xtplhd`\XTPLHD@<840,($  üğäÜĞ¸¬˜xX8øÔ¸”tL0 àØÌ¼ €X0ÜŒÀŒœŒxŒLŒ ŒŒšŠ                                                                                                                                                                                                                                                                                  ( ( ( ( (                                     H                „ „ „ „ „ „ „ „ „ „                                        ‚ ‚ ‚ ‚ ‚ ‚                                                                                                                                                                                                                                                                                                               h ( ( ( (                                     H                „ „ „ „ „ „ „ „ „ „              ‚‚‚‚‚‚                                                                      H                                      €‚ƒ„…†‡ˆ‰Š‹Œ‘’“”•–—˜™š›œŸ ¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏĞÑÒÓÔÕÖ×ØÙÚÛÜİŞßàáâãäåæçèéêëìíîïğñòóôõö÷øùúûüışÿ 	
 !"#$%&'()*+,-./0123456789:;<=>?@abcdefghijklmnopqrstuvwxyz[\]^_`abcdefghijklmnopqrstuvwxyz{|}~€‚ƒ„…†‡ˆ‰Š‹Œ‘’“”•–—˜™š›œŸ ¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏĞÑÒÓÔÕÖ×ØÙÚÛÜİŞßàáâãäåæçèéêëìíîïğñòóôõö÷øùúûüışÿ€‚ƒ„…†‡ˆ‰Š‹Œ‘’“”•–—˜™š›œŸ ¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏĞÑÒÓÔÕÖ×ØÙÚÛÜİŞßàáâãäåæçèéêëìíîïğñòóôõö÷øùúûüışÿ 	
 !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`ABCDEFGHIJKLMNOPQRSTUVWXYZ{|}~€‚ƒ„…†‡ˆ‰Š‹Œ‘’“”•–—˜™š›œŸ ¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏĞÑÒÓÔÕÖ×ØÙÚÛÜİŞßàáâãäåæçèéêëìíîïğñòóôõö÷øùúûüışÿHH:mm:ss    dddd, MMMM dd, yyyy MM/dd/yy    PM  AM  December    November    October September   August  July    June    April   March   February    January Dec Nov Oct Sep Aug Jul Jun May Apr Mar Feb Jan Saturday    Friday  Thursday    Wednesday   Tuesday Monday  Sunday  Sat Fri Thu Wed Tue Mon Sun     1#QNAN  1#INF   1#IND   1#SNAN  SunMonTueWedThuFriSat   JanFebMarAprMayJunJulAugSepOctNovDec    CONOUT$ €€†€€  †€†‚€EEE………  00€P€ˆ  ('8PW€  700PPˆ    (€ˆ€€   `h`hhhxppwpp       O p e n H e l p e r         S o f t w a r e \ W o n d e r s h a r e \ W o n d e r s h a r e   H e l p e r   C o m p a c t \     E l e v a t i o n : A d m i n i s t r a t o r ! n e w : % s     Ø¡ğ3 ¡`4 ” H¡ 5 ” ” ” ”  ¡ 5 ” ” ¸ P6 ” F      À      FKº°6µ iC»ÊŸªÜ¬0CˆFºÉJ¾Ü:.•^¸Úp¤é(æG²çĞÀÏê‰<ÛU¹7èA‡Ì|W/StÉåwwšIŠ|Lwr“ÜÁ¬p+¢'CšTuK“ VÓˆ©Qº­H¥dbÍ_õGàç«ğã2.G’L+–Ü#Ò	6MŠŸNˆKCŠıŞË†âPe·‹ŒM´2Fh¥NŞ£héå]•áM«‰²mö£1i`\Ø(ÖvB“Ãš”å3‹C6™n¼şD¼…ÓI\M–     ¢P| deque<T> too long   „£p| bad allocation  Ì£€ˆ àˆ ğˆ ‰  ‰ 0‰ @‰ P‰ À‡ úÊÅöoN›óE"¯Ô¾    H                                                           pğĞ¤A   RSDS¹ó¿1	~UDµZWÌÜôi   e:\svn_code\CommonUI\CBS_Client\Trunk\Src\Interface\C++\Release\WSCBSProductClient\CBSProductClient.pdb             ğÔŸ           äŸôŸè¢4£    ğ       ÿÿÿÿ    @   ÔŸ            Lğ$            4 <     Lğ        ÿÿÿÿ    @   $             P£            (ó€             œ 4£    (ó       ÿÿÿÿ    @   €             °Ì            Ü ä     °        ÿÿÿÿ    @   Ì             à¡           $¡,¡    à        ÿÿÿÿ    @   ¡            \¡           l¡t¡            ÿÿÿÿ    @   \¡            4¤¡           ´¡¼¡    4        ÿÿÿÿ    @   ¤¡            dì¡           ü¡¢    d        ÿÿÿÿ    @   ì¡            Ğ4¢           D¢L¢    Ğ        ÿÿÿÿ    @   4¢            T|¢           Œ¢œ¢è¢4£    T       ÿÿÿÿ    @   |¢            4Ì¢           Ü¢è¢4£    4       ÿÿÿÿ    @   Ì¢            t£           (£h£4£            ÿÿÿÿ    @   P£           `£4£    t       ÿÿÿÿ    @   £            ô˜£           ¨£°£    ô        ÿÿÿÿ    @   ˜£            à£           ğ£¤¬¤@¤x¤           ÿÿÿÿ    @   à£           0¤¬¤@¤x¤    Ğ       ÿÿÿÿ    @   \¤           l¤@¤x¤    ¸        ÿÿÿÿ    @   ”¤           ¤¤x¤    è       ÿÿÿÿ    @    ¤        Ú›  äœ  ğŸ  Œï  è# xg “g »g ëg h 0h Ph †h ¸h  i 8i xi °i ài j 8j j Ğj øj  k @k ğk l 8l `l ˆl Øl  m  m @m `m m Ğm n 0n Pn pn ˜n Àn ğn o @o `o €o  o Ào ào  p (p Xp €p  p Àp àp  q  q @q `q €q  q                     ÿÿÿÿpg"“   è¥                           QŒ     $¦   4¦T¬¬    ğ    ÿÿÿÿ    (   óŒ     °     `¦   h¦    (ğ    ÿÿÿÿ       0     şÿÿÿ    Ìÿÿÿ    şÿÿÿˆ ±     şÿÿÿ    Ôÿÿÿ    şÿÿÿ         şÿÿÿ    Ôÿÿÿ    şÿÿÿ    G‘     şÿÿÿ    Ôÿÿÿ    şÿÿÿÂ‘ Ö‘     şÿÿÿ    Ôÿÿÿ    şÿÿÿò™ š     şÿÿÿ    Ôÿÿÿ    şÿÿÿ    ˆ£     şÿÿÿ    Ôÿÿÿ    şÿÿÿ    ¤     şÿÿÿ    Øÿÿÿ    şÿÿÿ0¥ 4¥     şÿÿÿ    Øÿÿÿ    şÿÿÿ€¥ „¥     şÿÿÿ    Ôÿÿÿ    şÿÿÿ    t¨ şÿÿÿ    ƒ¨ şÿÿÿ    Øÿÿÿ    şÿÿÿ    6ª şÿÿÿ    Bª şÿÿÿ    Ğÿÿÿ    şÿÿÿ    º­     şÿÿÿ    Èÿÿÿ    şÿÿÿ    S°     şÿÿÿ    Øÿÿÿ    şÿÿÿû± ²     şÿÿÿ    Ôÿÿÿ    şÿÿÿ    öÅ     şÿÿÿ    Œÿÿÿ    şÿÿÿ
Ğ Ğ     şÿÿÿ    Ğÿÿÿ    şÿÿÿ    Ø     Ù× ã× şÿÿÿ    Øÿÿÿ    şÿÿÿÀØ ÉØ @           §Ù ÿÿÿÿ    ÿÿÿÿ                  Ü¨"“   ì¨   ü¨                   şÿÿÿ    ´ÿÿÿ    şÿÿÿ    ßÚ     OÚ XÚ şÿÿÿ    Ôÿÿÿ    şÿÿÿÆÜ ÊÜ     şÿÿÿ    Øÿÿÿ    şÿÿÿ_İ cİ     }Ö     ¬©   ¸©¬    (ó    ÿÿÿÿ       â     şÿÿÿ    Ôÿÿÿ    şÿÿÿRñ nñ     şÿÿÿ    Ôÿÿÿ    şÿÿÿ    ó     şÿÿÿ    Ôÿÿÿ    şÿÿÿ    ·    şÿÿÿ    Ôÿÿÿ    şÿÿÿ        şÿÿÿ    Ìÿÿÿ    şÿÿÿ    O    şÿÿÿ    Ôÿÿÿ    şÿÿÿ    	    şÿÿÿ    Ğÿÿÿ    şÿÿÿ        şÿÿÿ    Àÿÿÿ    şÿÿÿ    ¯    şÿÿÿ    Ğÿÿÿ    şÿÿÿ0G    şÿÿÿ    Ìÿÿÿ    şÿÿÿ        şÿÿÿ    Ğÿÿÿ    şÿÿÿ        şÿÿÿ    Ôÿÿÿ    şÿÿÿ    ¹5    şÿÿÿ    Ğÿÿÿ    şÿÿÿ    I7    şÿÿÿ    Ìÿÿÿ    şÿÿÿ    Ó8        Ÿ8şÿÿÿ    Ôÿÿÿ    şÿÿÿ    ü^    şÿÿÿ    Ğÿÿÿ    şÿÿÿ    Ş_    şÿÿÿ    Øÿÿÿ    şÿÿÿ=dYd    şÿÿÿ    Ğÿÿÿ    şÿÿÿ    Pf        ÿÿÿÿ       •     T    ÿÿÿÿ    (   ğ€     4    ÿÿÿÿ    (       8¬T¬¬    ğ†     p¬    t    ÿÿÿÿ       €ƒ    ¬¬    @ƒ     ¬¬ÿÿÿÿ°g"“   È¬                       ÿÿÿÿàg"“   ô¬                       ÿÿÿÿ    ÿÿÿÿ    @           ’;               0­"“    ­   @­               ÿÿÿÿ    ÿÿÿÿ    @           sH               ˆ­"“   x­   ˜­               ÿÿÿÿ    ÿÿÿÿ                  @           >… @           ¯„             ğ­               ®"“   Ğ­   ®               ÿÿÿÿph    {h"“   \®                       ÿÿÿÿ°h"“   ®                       ÿÿÿÿàh    èh   ğh   øh"“   ¼®                       ÿÿÿÿ i    (i   0i"“    ¯                       ÿÿÿÿ`i    hi   pi"“   <¯                       ÿÿÿÿ i    ¨i"“   x¯                       ÿÿÿÿĞi    Øi"“   ¬¯                       ÿÿÿÿ j"“   à¯                       ÿÿÿÿ0j"“   °                       ÿÿÿÿ`j    hj   pj   xj   €j   ˆj"“   8°                       ÿÿÿÿ°j    ¸j   Àj   Èj"“   Œ°                       ÿÿÿÿğj"“   Ğ°                       ÿÿÿÿ    ÿÿÿÿ    @           VQ               ±"“   ü°   ±               ÿÿÿÿ    ÿÿÿÿ    @           F               d±"“   T±   t±                   ÿÿÿÿ               `k   hk   pk   xk   €k   ˆk   k   ˜k	    k   ¨k   °k   ¸k   Àk   Èk   Ğk   Øk   àk   èk        ÿÿÿÿ    @           ‡B @           B             `²             p²"“   °±   €²               ÿÿÿÿ                    ÿÿÿÿ    @           Ä: @           Ê:             ì²             ü²"“   Ì²   ³               ÿÿÿÿ0l"“   X³                       ÿÿÿÿ    ÿÿÿÿ    @           c<               ”³"“   „³   ¤³               ÿÿÿÿ€l"“   Ü³                       ÿÿÿÿ        °l   ¸l   Àl   Èl   Ğlÿÿÿÿ    @           Lm              @´"“   ´   P´               ÿÿÿÿ    ÿÿÿÿ    @           =l               ˜´"“   ˆ´   ¨´               ÿÿÿÿ    ÿÿÿÿ    @           £k               ğ´"“   à´    µ               ÿÿÿÿ    ÿÿÿÿ    @           ıj               Hµ"“   8µ   Xµ               ÿÿÿÿ    ÿÿÿÿ    @           ]j                µ"“   µ   °µ               ÿÿÿÿ        €m   ˆmÿÿÿÿ    @           »i              ¶"“   èµ   ¶               ÿÿÿÿ        °m   ¸m   Àm   Èmÿÿÿÿ    @           ıh              €¶"“   P¶   ¶               ÿÿÿÿ        ğm   øm    n   nÿÿÿÿ    @           =e              ø¶"“   È¶   ·               ÿÿÿÿ    ÿÿÿÿ    @           ƒa               P·"“   @·   `·               ÿÿÿÿ    ÿÿÿÿ    @           ô`               ¨·"“   ˜·   ¸·               ÿÿÿÿ    ÿÿÿÿ    @           R`                ¸"“   ğ·   ¸               ÿÿÿÿ        nÿÿÿÿ    @           Á[              `¸"“   H¸   p¸               ÿÿÿÿ    ÿÿÿÿ    @           äZ               ¸¸"“   ¨¸   È¸               ÿÿÿÿ        àn   ènÿÿÿÿ    @           $Z               ¹"“    ¹   0¹               ÿÿÿÿ    ÿÿÿÿ    @           :Y               x¹"“   h¹   ˆ¹               ÿÿÿÿ        0o   8oÿÿÿÿ    @           ¤W              à¹"“   À¹   ğ¹               ÿÿÿÿ    ÿÿÿÿ    @           ÙV               8º"“   (º   Hº               ÿÿÿÿ    ÿÿÿÿ    @           WV               º"“   €º    º               ÿÿÿÿ    ÿÿÿÿ    @           ™U               èº"“   Øº   øº               ÿÿÿÿ    ÿÿÿÿ    @           ÙT               @»"“   0»   P»               ÿÿÿÿ    ÿÿÿÿ    @           4T               ˜»"“   ˆ»   ¨»               ÿÿÿÿ    ÿÿÿÿ    @           ’S               ğ»"“   à»    ¼               ÿÿÿÿ         pÿÿÿÿ    @           ¸P              P¼"“   8¼   `¼               ÿÿÿÿ        Ppÿÿÿÿ    @           ÔO              °¼"“   ˜¼   À¼               ÿÿÿÿ    ÿÿÿÿ    @           ‚M               ½"“   ø¼   ½               ÿÿÿÿ    ÿÿÿÿ    @           »L               `½"“   P½   p½               ÿÿÿÿ    ÿÿÿÿ    @           ûK               ¸½"“   ¨½   È½               ÿÿÿÿ    ÿÿÿÿ    @           :K               ¾"“    ¾    ¾               ÿÿÿÿ    ÿÿÿÿ    @           |J               h¾"“   X¾   x¾               ÿÿÿÿ    ÿÿÿÿ    @           ¼I               À¾"“   °¾   Ğ¾               ÿÿÿÿ    ÿÿÿÿ    @           I               ¿"“   ¿   (¿               ÿÿÿÿ    ÿÿÿÿ    @           >               p¿"“   `¿   €¿               ÿÿÿÿ    ÿÿÿÿ    @           7=               È¿"“   ¸¿   Ø¿               ÿÿÿÿ    ÿÿÿÿ    @           O                À"“   À   0À               äÀ         HÃ € ÌÀ         ¨Ã  € <Â         Ä p $Â         Ä X                     †Ã xÃ fÃ VÃ ”Ã     ÊÂ âÂ úÂ ¾Â Ã 0Ã °Â  Â „Â lÂ Ã TÂ ¸È ªÈ šÈ „È tÈ dÈ TÈ DÈ 2È $Ä 0Ä BÄ RÄ `Ä vÄ †Ä šÄ ®Ä ÊÄ èÄ üÄ Å  Å ,Å 8Å LÅ ^Å lÅ xÅ †Å Å  Å ¨Å ´Å ÂÅ ÎÅ ŞÅ ôÅ Æ Æ &Æ @Æ XÆ rÆ ˆÆ ¢Æ °Æ ¾Æ ÌÆ æÆ öÆ Ç &Ç :Ç JÇ XÇ dÇ nÇ zÇ ŒÇ œÇ ÄÇ ÖÇ æÇ øÇ È  È     ¢  €  €  €  €È  €    ÆÃ ØÃ şÃ ìÃ ¶Ã     ëInterlockedDecrement  ïInterlockedIncrement  âInitializeCriticalSection … CreateEventW  R CloseHandle YSetEvent  î EnterCriticalSection  9LeaveCriticalSection  ùWaitForSingleObject ResetEvent  ÁTerminateThread Ñ DeleteCriticalSection KERNEL32.dll  <RegCreateKeyW ~RegSetValueExW  0RegCloseKey dRegOpenKeyW nRegQueryValueExW  ADVAPI32.dll  > CoInitialize  l CoUninitialize   CoCreateInstance  yStringFromGUID2 5 CoGetObject ole32.dll OLEAUT32.dll  ÏHeapFree  JGetProcessHeap  GetLastError  ExitThread  ÅGetCurrentThreadId  µ CreateThread  ÀTerminateProcess  ÀGetCurrentProcess ÓUnhandledExceptionFilter  ¥SetUnhandledExceptionFilter  IsDebuggerPresent †GetCommandLineA ±RaiseException  RtlUnwind ËHeapAlloc GetModuleHandleW  EGetProcAddress  ÇTlsGetValue ÅTlsAlloc  ÈTlsSetValue ÆTlsFree sSetLastError  ²Sleep ÔHeapSize  ExitProcess %WriteFile dGetStdHandle  GetModuleFileNameA  oSetHandleCount  óGetFileType bGetStartupInfoA `FreeEnvironmentStringsA ØGetEnvironmentStrings aFreeEnvironmentStringsW WideCharToMultiByte ÚGetEnvironmentStringsW  ÍHeapCreate  ÎHeapDestroy ìVirtualFree §QueryPerformanceCounter “GetTickCount  ÁGetCurrentProcessId yGetSystemTimeAsFileTime GetModuleHandleA  éVirtualAlloc  ÒHeapReAlloc rGetCPInfo hGetACP  7GetOEMCP  
IsValidCodePage <LoadLibraryA  ãInitializeCriticalSectionAndSpinCount fSetFilePointer  šGetConsoleCP  ¬GetConsoleMode  gMultiByteToWideChar GetLocaleInfoA  fGetStringTypeA  iGetStringTypeW  +LCMapStringA  -LCMapStringW  ‡SetStdHandle  WriteConsoleA °GetConsoleOutputCP  $WriteConsoleW ˆ CreateFileA WFlushFileBuffers          ÷)ÓX    8Ï            øÈ xË øÍ  q  ĞC  Ğp  0q  @q  Pq  `q  pq  €q   r  @r  Àr   s  @s  €s  Às   t  €s  @t  @y  €y  Ày   q  €t  Àt  q   u  @u  €u  Àu   v  @v  €v  Àv  €r   z  @z  €z  Àz   {  @{   w  @w  Àw   y  €w   x  @x  €x  Àx  à6   2  ğ[  P4   ]  06  €\  ğ4  ]  5  €7  @\  ğ]  Ğ\  `]  3  @6  @6  @6  @6  ` h œ t Œ ğQ  °^  `N   X  `=  àL  `l  H  ğ:  À;  PZ   L  à8  M  i  pQ  0^  àV  @C  pR  0_  àB  ğ>  Ğ>  0>  P>  °>  >  p>  P:  ĞC  <  ÀG   G  ğR  °_  `G  a  Pe  0G  ÀU  @T  ĞF  `V  Àk  ài  G  àI  ğC   C  @?   O  X  `K   J  àP   P  p:  p?  à[  ĞW   a  °S  p`   8  Ğ8   k  q  °8  ?  À8  €j   I   D  ğG  pC   U  `Y  [  ”  ü    à MÏ jÏ ŒÏ ¶Ï åÏ Ğ >Ğ cĞ Ğ ´Ğ àĞ ıĞ 'Ñ QÑ vÑ Ñ ÃÑ öÑ )Ò WÒ ‡Ò ¢Ò ÊÒ òÒ Ó :Ó yÓ ºÓ âÓ Ô ÒØ Ù FÙ kÙ Ù ŞÙ Ú :Ú [Ú ©Ú ÚÚ Û KÛ Û ¶Û îÛ (Ü ^Ü ªÜ öÜ İ Dİ ”İ Âİ óİ Ş CŞ |Ş ÇŞ ß 8ß aß ¦ß ßß à ^à •à Åà á ?á ká šá İá ıá #â Jâ râ  â ïâ !ã Kã uã °ã Ùã ä Cä pä ä Ïä ùä Uå ±å çå 4æ †æ °æ ç 4ç Tç uç •ç Íç úç %è Wè è Âè éè é 9é @Ô bÔ †Ô Ô ªÔ ¼Ô ×Ô ôÔ Õ ,Õ DÕ UÕ mÕ ‡Õ ™Õ ±Õ ÎÕ İÕ ïÕ Ö "Ö 4Ö GÖ `Ö sÖ Ö —Ö ªÖ ¾Ö ÖÖ êÖ × .× J× n× × «× Ğ× ğ× Ø Ø 'Ø 3Ø BØ YØ nØ †Ø —Ø ¬Ø ½Ø 2 3 4 5 6 7 8 9 : ; < = > ? @ A B C D E F G H I J K L M N O P Q R S T U V W X Y Z [ \ ] ^ _ ` a b c d e f g h i j k l m n o p q r s t u v w x y z { | } ~  €  ‚ ƒ „ … † ‡ ˆ ‰ Š ‹ Œ     ‘ ’ “ ” • – — ˜ ™ š › œ   Ÿ  $ , " +  #  %  & ) * !  - 1 .                       	 
    (  ' 0 /   CBSProductClient.dll ??0CCBSProductClient@@IAE@XZ ??0CCBSProductClient@@QAE@ABV0@@Z ??0ICBSHelperControlEventReceiver@@IAE@XZ ??0ICBSHelperControlEventReceiver@@QAE@ABV0@@Z ??0ICBSInstallUpdateEventReceiver@@IAE@XZ ??0ICBSInstallUpdateEventReceiver@@QAE@ABV0@@Z ??0ICBSRegisterEventReceiver@@IAE@XZ ??0ICBSRegisterEventReceiver@@QAE@ABV0@@Z ??0ICBSUploadFileEventReceiver@@IAE@XZ ??0ICBSUploadFileEventReceiver@@QAE@ABV0@@Z ??1CCBSProductClient@@MAE@XZ ??1ICBSHelperControlEventReceiver@@MAE@XZ ??1ICBSInstallUpdateEventReceiver@@MAE@XZ ??1ICBSRegisterEventReceiver@@MAE@XZ ??1ICBSUploadFileEventReceiver@@MAE@XZ ??4CCBSProductClient@@QAEAAV0@ABV0@@Z ??4ICBSHelperControlEventReceiver@@QAEAAV0@ABV0@@Z ??4ICBSInstallUpdateEventReceiver@@QAEAAV0@ABV0@@Z ??4ICBSRegisterEventReceiver@@QAEAAV0@ABV0@@Z ??4ICBSUploadFileEventReceiver@@QAEAAV0@ABV0@@Z ??_7CCBSProductClient@@6B@ ??_7ICBSHelperControlEventReceiver@@6B@ ??_7ICBSInstallUpdateEventReceiver@@6B@ ??_7ICBSRegisterEventReceiver@@6B@ ??_7ICBSUploadFileEventReceiver@@6B@ ?AutoCreatedIncreaseDataCollect@CCBSProductClient@@QAEXPB_W0@Z ?AutoCreatedIncreaseDataCollectEx@CCBSProductClient@@QAEXPB_W0@Z ?AutoRegister@CCBSProductClient@@QAEHXZ ?AutoRunHelper@CCBSProductClient@@QAEHXZ ?AutoUpdateRegister@CCBSProductClient@@IAEPA_WPB_W@Z CBSAutoCreatedIncreaseDataCollect CBSAutoCreatedIncreaseDataCollectEx CBSCaptureExceptionData CBSChangPID CBSCollectExpData CBSCommIncreaseDataCollect CBSCommIncreaseDataCollectEx CBSCustomStringDataCollect CBSCustomStringDataCollectEx CBSGetEnableDataCollect CBSGetEnableTips CBSGetNewInstallPackage CBSGetNewInstallPackageEx CBSGetProductSuit CBSGetProductSuitEnable CBSGetResourceFileUploadSize CBSGetSumCount CBSGetUsableCount CBSHPAntiEmailBreaker CBSHPAntiEmailRecordStopTime CBSHPAutoRegister CBSHPAutoRunHelper CBSHPCheckJoinImproveExp CBSHPCheckRegister CBSHPContactCustomService CBSHPInit CBSHPLocalRegister CBSHPOnlineRegister CBSHPOnlineRegisterAsyn CBSHPProductUpgrade CBSHPSetAntiEmailBreakerFinishCallBack CBSHPSetAutoRegisterCallBack CBSHPSetCBSHPServerCallBack CBSHPSetCheckRegisterFinishCallBack CBSHPSetHelperWillExitCallBack CBSHPSetInstallUpdateCallBack CBSHPSetOnlineRegisterFinishCallBack CBSHPSetUploadLogFinishCallBack CBSHPSetUploadLogProgressCallBack CBSHPStart CBSHPStop CBSHPUnInit CBSHPUploadLog CBSHPUploadUserExpData CBSSetDataCollectPID CBSSetEnableDataCollect CBSSetEnableTips CBSSetPreUsedRecords CBSSetUsedRecord CBSUploadCollectData ?CallAutoRegisterCallBack@CCBSProductClient@@IAEHPB_W0@Z ?CaptureExceptionData@CCBSProductClient@@QAEHHPB_W00000H@Z ?ChangPID@CCBSProductClient@@QAEXH@Z ?CheckAlive@CCBSProductClient@@IAEHPBUIUnknown@@@Z ?CheckAliveRestartServer@CCBSProductClient@@IAEHPBUIUnknown@@@Z ?CheckJoinImproveExp@CCBSProductClient@@QAEHXZ ?CheckRegister@CCBSProductClient@@QAEHPB_W@Z ?Clean@CCBSProductClient@@IAEXXZ ?CoCreateInstanceAsAdmin@CCBSProductClient@@IAEJPAUHWND__@@ABU_GUID@@1PAPAX@Z ?CollectExpData@CCBSProductClient@@QAEHHPB_W00@Z ?CommIncreaseDataCollect@CCBSProductClient@@QAEXPB_W@Z ?CommIncreaseDataCollectEx@CCBSProductClient@@QAEXPB_W0@Z ?ContactCustomService@CCBSProductClient@@QAEHPB_W00@Z ?CreateSendQueueDataThread@CCBSProductClient@@AAEXXZ ?CustomStringDataCollect@CCBSProductClient@@QAEXPB_W0@Z ?CustomStringDataCollectEx@CCBSProductClient@@QAEXPB_W0@Z ?DataCollectThreadRoutine@CCBSProductClient@@CGIPAX@Z ?DoAntiEmailBreakerFinish@CCBSProductClient@@AAEXW4emRegCheckResult@@PA_W@Z ?DoCheckRegisterFinish@CCBSProductClient@@AAEXHW4emOnlineRegisterStatus@@@Z ?DoExist@CCBSProductClient@@AAEXXZ ?DoInstallUpdate@CCBSProductClient@@AAEHXZ ?DoOnlineRegisterFinish@CCBSProductClient@@AAEXPA_WW4emOnlineRegisterStatus@@@Z ?DoUploadLogFinish@CCBSProductClient@@AAEXH@Z ?DoUploadLogProgress@CCBSProductClient@@AAEHHH@Z ?FireSendEvent@CCBSProductClient@@AAEXXZ ?FreeInstance@CCBSProductClient@@SGXXZ ?GetAutoUpdateRegisterEmail@CCBSProductClient@@IAEPA_WXZ ?GetCustomerServiceInterface@CCBSProductClient@@AAEPAUICustomerService@@XZ ?GetDataGatherInterface@CCBSProductClient@@AAEPAUIDataGather@@XZ ?GetEnableDataCollect@CCBSProductClient@@QAEHXZ ?GetEnableTips@CCBSProductClient@@QAEHXZ ?GetExceptionLogInterface@CCBSProductClient@@AAEPAUIExceptionLog@@XZ ?GetNewInstallPackage@CCBSProductClient@@QAEHHPA_W0000@Z ?GetNewInstallPackageEx@CCBSProductClient@@QAEHHPA_W0000PAJ@Z ?GetPayPerViewInterface@CCBSProductClient@@AAEPAUIPayPerView@@XZ ?GetProductSuit@CCBSProductClient@@QAEXPAJ0PAPA_W001@Z ?GetProductSuitEnable@CCBSProductClient@@QAEHXZ ?GetRegisterInterface@CCBSProductClient@@AAEPAUIRegister@@XZ ?GetResourceFileUploadSize@CCBSProductClient@@QAEXHPB_WPAJ@Z ?GetSumCount@CCBSProductClient@@QAEJHPB_W@Z ?GetUsableCount@CCBSProductClient@@QAEJHPB_W@Z ?GetUserExpDataInterface@CCBSProductClient@@AAEPAUIUserExpData@@XZ ?Hide@CCBSProductClient@@QAEHXZ ?Init@CCBSProductClient@@QAEXHPB_W0@Z ?Instance@CCBSProductClient@@SGPAV1@XZ ?IsThreadIdle@CCBSProductClient@@CG_NXZ ?LocalRegister@CCBSProductClient@@QAEHPB_W0@Z ?OnlineRegister@CCBSProductClient@@QAE?AW4emOnlineRegisterStatus@@PB_WPAPA_W@Z ?OnlineRegisterAsyn@CCBSProductClient@@QAEHPB_W@Z ?ProductUpgrade@CCBSProductClient@@QAEHXZ ?RecordStopTime@CCBSProductClient@@QAEHXZ ?RegCheck@CCBSProductClient@@QAEHPB_W0W4emRegCheckType@@@Z ?RestartServer@CCBSProductClient@@IAEHXZ ?SendAllQueueData@CCBSProductClient@@CG_NXZ ?SetAutoRegisterCallBack@CCBSProductClient@@QAEXP6GHPB_W0@Z@Z ?SetAutoRunHelper@CCBSProductClient@@IAEXH@Z ?SetDataCollectPID@CCBSProductClient@@QAEXH@Z ?SetEnableDataCollect@CCBSProductClient@@QAEXH@Z ?SetEnableTips@CCBSProductClient@@QAEXH@Z ?SetHelperControlEventReceiver@CCBSProductClient@@AAEXPAVICBSHelperControlEventReceiver@@@Z ?SetInstallUpdateEventReceiver@CCBSProductClient@@AAEXPAVICBSInstallUpdateEventReceiver@@@Z ?SetPreUsedRecords@CCBSProductClient@@QAEJHPB_WHPAJ@Z ?SetRegCheckCallBack@CCBSProductClient@@QAEXP6GXW4emRegCheckResult@@PA_W@Z@Z ?SetRegisterEventReceiver@CCBSProductClient@@AAEXPAVICBSRegisterEventReceiver@@@Z ?SetThreadIdle@CCBSProductClient@@CGX_N@Z ?SetUploadFileEventReceiver@CCBSProductClient@@AAEXPAVICBSUploadFileEventReceiver@@@Z ?SetUsedRecord@CCBSProductClient@@QAEJHPB_W@Z ?Show@CCBSProductClient@@QAEHXZ ?Start@CCBSProductClient@@QAEHXZ ?Stop@CCBSProductClient@@QAEHXZ ?TerminateSendQueueDataThread@CCBSProductClient@@AAEXXZ ?UploadCollectData@CCBSProductClient@@QAEHXZ ?UploadLog@CCBSProductClient@@QAEHPB_W00@Z ?UploadUserExpData@CCBSProductClient@@QAEHPB_W0@Z ?m_DataCollectInfoQueue@CCBSProductClient@@0VCDataCollectInfoQueue@@A ?m_idlEvent@CCBSProductClient@@0PAXA ?m_instance@CCBSProductClient@@0PAV1@A ?m_sendThreadIdle@CCBSProductClient@@0_NA ?m_sentEvent@CCBSProductClient@@0PAXA ?m_threadIdlelock@CCBSProductClient@@0U_RTL_CRITICAL_SECTION@@A                                                                                                                                        ¬Œ‚    .?AVout_of_range@std@@  ğ Œ‚    .?AV_com_error@@    ¬¬Œ‚    .?AVtype_info@@ ¬        Næ@»±¿Du˜  s˜  ÿÿÿÿÿÿÿÿk°       x   
                                        	               	      
                                                !      5      A      C      P      R      S      W      Y      l      m       p      r   	         €   
      
   ‚   	   ƒ      „      ‘   )         ¡      ¤      §      ·      Î      ×                            ‰   ôˆ	   Èˆ
   0ˆ   ˆ   Ô‡   °‡   „‡   L‡   $‡   ì†   ´†   Œ†   l†   †    Ğ…!   Ø„"   8„x   $„y   „z   „ü    „ÿ   ğƒ¬            ÿÿÿÿ€
                                                             ¬Œ‚    .?AVbad_exception@std@@         Ï*Ï*Ï*Ï*Ï*Ï*Ï*Ï*Ï*Ï*                                                                                                                                                                                                                                                                                          ¤•    C                                                                                              ¨ô            ¨ô            ¨ô            ¨ô            ¨ô                              (ş         “(˜¨™hı°ô   °ô˜õ                                                                                                                                                                                                                                                                                                                                    abcdefghijklmnopqrstuvwxyz      ABCDEFGHIJKLMNOPQRSTUVWXYZ                                                                                                                                                                                                                                                                                                                                                                                                                                                       abcdefghijklmnopqrstuvwxyz      ABCDEFGHIJKLMNOPQRSTUVWXYZ                                                                                                                                     ˜õ¤  `‚y‚!       ¦ß      ¡¥      Ÿàü    @~€ü    ¨  Á£Ú£                        ş      @ş      µ  Á£Ú£                        ş      Aş      ¶  Ï¢ä¢ å¢è¢[                 ş      @~¡ş    Q  QÚ^Ú  _ÚjÚ2                 ÓØŞàù  1~ş                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       şÿÿÿ¬ŠœŠ             “             “¢•Ğ›Ì›È›Ä›À›¼›¸›°›¨› ›”›ˆ›€›t›p›l›h›d›`›\›X›T›P›L›H›D›<›0›(› ›`››››üšôšèšÜšØšÔšÈš´š¨š	         hı.   $ş(ş   .                                üÿÿ5      @   ÿ  €   ÿÿÿ             €p     ğñÿÿ    PST                                                             PDT                                                             Àş ÿÿÿÿÿ        ÿÿÿÿ        şÿÿÿşÿÿÿ          @         È@         ú@        @œ@        PÃ@        $ô@       €–˜@        ¼¾@     ¿É4@   ¡íÌÎÂÓN@ ğµp+¨­Åi@Ğ]ı%åOëƒ@q–×•C)¯@ù¿ Dí‚¹@¿<Õ¦ÏÿIxÂÓ@oÆàŒé€ÉGº“¨A¼…kU'9÷pà|B¼İŞùûë~ªQC¡ævãÌò)/„&D(ªø®ãÅÄúDë§Ôó÷ëáJz•ÏEeÌÇ‘¦® ã£Feu†uvÉHMXBä§“9;5¸²íSM§å]=Å];‹’Zÿ]¦ğ¡ ÀT¥Œ7aÑı‹Z‹Ø%]‰ùÛgª•øó'¿¢È]İ€nLÉ›— ŠR`Ä%u    ÍÌÍÌÌÌÌÌÌÌû?q=
×£p=
×£ø?Zd;ßO—nƒõ?ÃÓ,eâX·Ññ?Ğ#„GG¬Å§î?@¦¶il¯½7†ë?3=¼BzåÕ”¿Öç?ÂııÎa„wÌ«ä?/L[áMÄ¾”•æÉ?’ÄS;uDÍ¾š¯?Şgº”9E­±Ï”?$#Æâ¼º;1a‹z?aUYÁ~±S|»_?×î/¾’…ûD?$?¥é9¥'ê¨*?}¬¡ä¼d|FĞİU>c{Ì#Twƒÿ‘=‘ú:zc%C1À¬<!‰Ñ8‚G—¸ ı×;ÜˆX±èã†¦;Æ„EB¶™u7Û.:3qÒ#Û2îIZ9¦‡¾ÀWÚ¥‚¦¢µ2âh²§RŸDY·,%Iä-64OS®Îk%Y¤ÀŞÂ}ûèÆçˆZW‘<¿Pƒ"NKebıƒ¯”}ä-ŞŸÎÒÈİ¦Ø
       €D        € 0     ÿÿÿÿ   ;   Z   x   —   µ   Ô   ó     0  N  m  ÿÿÿÿ   :   Y   w   –   ´   Ó   ò     /  M  l          Œ‚    .?AVICBSInstallUpdateEventReceiver@@    Œ‚    .?AVICBSUploadFileEventReceiver@@   Œ‚    .?AVICBSRegisterEventReceiver@@ Œ‚    .?AVICBSHelperControlEventReceiver@@    Œ‚    .?AVCCBSProductClient@@ ¬¬¸œœœ¨                                                        Œ‚    .?AVCDataCollectInfoItem@@  Œ‚    .?AVCDataCollectInfoQueue@@ Œ‚    .?AVexception@std@@ Œ‚    .?AVlogic_error@std@@   Œ‚    .?AVlength_error@std@@  Œ‚    .?AVbad_alloc@std@@ Œ‚    .?AVCServerNotifyEventHandler@@ Œ‚    .?AUIUnknown@@  Œ‚    .?AUIDispatch@@ Œ‚    .?AUIEventSink@@                                                                                                                                                                                                                                                                                    €   8  €                 P  €                 h  €                €                 	      0 ä  ä      „4 Z  ä      ä4   V S _ V E R S I O N _ I N F O     ½ïş                                    B   S t r i n g F i l e I n f o      0 8 0 4 0 4 b 0   0   C o m m e n t s   A u t h o r :   X Z H   ˜ <  C o m p a n y N a m e     C o p y r i g h t   ( c )   2 0 1 3   W o n d e r s h a r e   S o f t w a r e   A l l   R i g h t s   R e s e r v e d   J   F i l e D e s c r i p t i o n     C B S P r o d u c t C l i e n t     6   F i l e V e r s i o n     2 ,   2 ,   5 ,   8     B   I n t e r n a l N a m e   C B S P r o d u c t C l i e n t     œ <  L e g a l C o p y r i g h t   C o p y r i g h t   ( c )   2 0 1 3   W o n d e r s h a r e   S o f t w a r e   A l l   R i g h t s   R e s e r v e d   R   O r i g i n a l F i l e n a m e   C B S P r o d u c t C l i e n t . d l l     J   P r o d u c t N a m e     D y n a m i c   L i n k   L i b r a r y     :   P r o d u c t V e r s i o n   2 ,   2 ,   5 ,   8     D    V a r F i l e I n f o     $    T r a n s l a t i o n     °<assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0">
  <trustInfo xmlns="urn:schemas-microsoft-com:asm.v3">
    <security>
      <requestedPrivileges>
        <requestedExecutionLevel level="asInvoker" uiAccess="false"></requestedExecutionLevel>
      </requestedPrivileges>
    </security>
  </trustInfo>
</assembly>PAPADDINGXXPADDINGPADDINGXXPADDING       00Œ0¢0¨0Ã1Ò1292N2“2¤232383S4c4°4Á4Ç4c5s5Ú5ğ5ö5Ó6æ6“7©7¯7C9Q99©9¾9::[:x::Ã:Ò:;8;M;ƒ;’;å;<<S<b<«<È<İ<=!=`=y==Ó=á=>4>I>ƒ>‘>Ë>ä>ù>3?A?€?™?®?ó?    ¬   0@0Y0n0³0Ã0 161W1›1Ó1ã1C2b2h233n333â3&4c4r4Å4è4ı435C55¡5§5C6S6 6±6·6S7b7Ã7Ô7ó778{8³8Á8û89)9c9s9Ú9ğ9ö9Ó:ä:a;w;};“<¡<à<ù<=S=b=«=É=Ş=#>1>‰>¢>·>ó>?K?i?~?Ã?Ò?   0  Ì   090N0“0¡0à0ù01S1b1«1É1Ş1&2š24T4r4š4Ÿ4Á4ô45:5?5a5”5²5Ú5ß5646b6Š66±6è6õ6ÿ6>7I7V7l7s7ƒ7”7­7º7À7É7Ù7ñ7÷7 88]8Q:\:v:†:Å:Ë:ö:;E;s;š;Æ;Ø;F<o<–<¨< =8=f=x=á=>?? ?(?.?B?H?N?S?Y?v?ˆ?±?·?½?Ã?Ì?Ú?ú? @  è   00œ0Ã0ò0W1…1Ø1*2“2¢2¼2À2Ä2È2Ì2Ğ2â2ë2ñ2÷233 3L33‰3¡3¿3Ç3Ò3ä3&484T4{4¬4¸4Â4Ê4Ğ45*5<5N5`5r5„5º5Ã5É5ë5ÿ56-6D6^6Ã6ï67O77¯7ß7ö78!8*898C8K8Q8t8–8¨8ì89&9899½9æ9ø9P:}:¦:¸:;;;f;x;à;ü;&<8< <¼<æ<ø<ƒ=—=Î=Ø=:>f>x>?&?8?¶?Õ?   P    00š0¹0æ0ø0,1W1…1‹1©1¼1Æ1Ì1Ñ1à122B2L2R2W2c2…2‹2Â2Ì2Ò2×2ã2ö23h3“3¶3Æ3454F4X4³4Ú455s5š5Æ5Ö516X6f6v6Ú6æ6ø6‰7¥7Ö7á7ü788*8:8e8l88–8¨89;9f9x9	:%:V:h:Á:å:;(;¦;Â;õ;ú;<&<B<G<e<t<…<Š<¨<¶<Ò<×<õ<===8=F=b=g=…=”=¥=ª=È=Ö=ò=÷=>$>E>K>‚>Œ>’>—>£>Å>Ë>????#?E?K?‚?Œ?’?—?£?¶?È? `     (0S0v0†0Î0õ011]1„1–1¨12’2Å23¨3È34I44Ñ4ó4>5V5h5ç5Z6Š6A7h7ˆ7Å7	8M8‘8³8ş89(9¼9æ9ø9^:†:˜:ş:&;6;¤;Æ;Ø;><f<x<M=Ó=á=>1>‚>Ó>á>#??–?È?Ş? p  ,  0"0S0`0Ñ0ó01¡1Ã122-2A2_2m22Ÿ2­2Á2ß2í233-3A3_3m33Ÿ3­3Á3ß3í344-4A4_4m44Ÿ4­4Á4ß4í455-5A5_5m55Ÿ5­5Á5ß5í566-6A6_6m66Ÿ6­6Á6ß6í677-7A7_7m77Ÿ7­7Á7ß7í788-8A8_8m88Ÿ8­8Á8ß8í899-9A9_9m99Ÿ9­9Á9ß9í9::-:A:_:m::Ÿ:­:Á:ß:í:;;-;A;_;m;‹;Z<z<€<µ<»<Á<Ì<ß<ö< ===='=0=9=?=‰?˜?¬?å?ò? €  ¤   ?0L0ÿ01"1P1B3U33ß3ì344›4¦4Ê4S6a6ˆ6õ657Ÿ7Ê7ñ782898H8O8b8u8‡8™8©8È9í9:´;¸;¼;À;Ä;È;Ì;F<S<f<†<<­<¾<È<å<==K=‚=›=º=Ò=ã=ÿ=
>=>}>•>¦>Â>à>í>?#?+?8?L?h?Æ?     ¬   10<0¶0Ï0ø0ı01k1s1ƒ1œ1¤1222C2K2[2Ü2è2ò2454
55n55â5ú5†6˜6j7t77œ7£7»7"8'818e8}8…8‹8Ñ8×8ò8"9>9V9©9Ö9Ü:;g; <8<=<¦>Æ>?H?g?l?r?v?|?€?†?Š??”?™?Ÿ?£?©?­?³?·?½?Á?Ú?    œ  0Ü0ä0ü01k1 182>2D2J2P2V2]2d2k2r2y2€2‡22—2Ÿ2«2´2¹2¿2É2Ò2İ2é2î2ş23	33%3,353G3–3œ3­3Ã3Õ3%4+4K4‚4“4â4ï45_5j5•5 5©5Æ5	666&6;6B6V6]6„6Š6•6¡6¶6½6Ñ6Ø6ğ67777"7.7=7C7X7i7u7ƒ7‰7•7›7¨7²7¹7Ñ7à7ç7ô78,8R8’8˜8Â8È8ä8ü8"9œ9¿9É9:	:U:e:k:w:}::“:¨:¶:Á:È:ã:è:ğ:ö:ı:;
;;;;$;,;5;A;F;K;Q;U;[;`;f;k;z;;›; ;«;°;»;À;Í;Û;á;î;<<0<c<l<x<¯<¸<Ä<ı<==+=c=¦=¬=Ù=â=>*>0>9>@>b>Á>É>Ü>ç>ì>ü>???!?7?B?\?h?p?€?•?Õ?â?   °  T   000!0?0Ë0Ø0x1}11­1Á1Ç1I2Â2È2á2ç2»3×3ú34=5D5Ç5Ï5ä5ï5Ø6¿7Î7é7;Q<Ø=>.>   À  0  0D2H2L2P2T2X2\2`2p2{22b3o3„3–3³3ê34414:4A4J4Š44·4Ü455,5>5b5‰5’5²5·5º6ï67777 7$7M7s7‘7˜7œ7 7¤7¨7¬7°7´7ş78888v88œ8£8¨8¬8°8Ñ8û8-94989<9@9D9H9L9P9š9 9¤9¨9¬9Š:¿:Ø:ß:ç:ì:ğ:ô:;C;a;h;l;p;t;x;|;€;„;Î;Ô;Ø;Ü;à;F<Q<l<s<x<|<€<¡<Ë<ı<======= =j=p=t=x=|=Ç=Ğ=ä=>>=>”>œ>Ü>æ>?'?h?˜?ª?ü?   Ğ  ”   0&0D0f0q0€0¸0Â011'181C1ö23333 3Œ3’3¨3³3Ê3Ö3ã3ê3!4p4ƒ4µ4Î4İ4â455<5A5O5W5c5j5s5†55œ5¥5­5·5½5Ã5Ò5õ56666*6N6V6r66’6Z7€8y9Â9^;İ<õ? à  ,   0)0'2ù5^6–6ğ;«<O>>¦>Ò>Ø>á>è>??   ğ  ˜   )081í12292C2m2{22¤2«2Ä2Ø2Ş2ç2ú23³3Ó3á3æ3)676=6W6\6k6t66Œ66±6¼6Â6È6Í6Ö6ó6ù67	777!7(7<7C7I7W7^7c7l7y77™7ª7°7Á7&8Â;Î;<'<a<¦<y>„>Œ>¶>{?¥?ğ?   Ğ   <0‹0Ó091P1a11%2b2y2ì3ı374D4N4\4e4o4£4®4¸4Ñ4Û4î45I5~5‘566f6Ò6ñ6f7r7…7—7²7º7Â7Ù7ò7888&8+8:8a8Š8›8©899`9f9r9Ç9ú92::£:ô:ú:;A;u;{;‡;Î;è;í;ò;÷;<6<D<‹<<Õ<Ú<á<æ<í<ò<a=j=p=ú=	>>'>W>³>À>Ù>÷>5?d?    ˜   0‚061V1F2o2È2V465ÿ506F6‡6¦6C7w7¦7#8Š8·8Ê8Ğ8ê8ù899"9)989D9Q9u9‡9•9ª9´9Ú9::%:I:x:¹:Ú:ü:E;;8<C<è<V={>‰>>Ÿ>¤>¼>Â>Ñ>×>æ>ì>ú>???!?/?o?Œ?©?     P   111š1¦1Ô394E4½4×4à4I6w67C9ê<ü<=0=B=T=f=x=Š=œ=ş=> >'>1>9>F>M>}>?‹? 0 €   I0[0h0t0~0†0‘0Á0ñ0ˆ182[2Ù2ª3=4M4h4ˆ4Ş4ï4*5F5¡5¬5Ú5è5÷566686B6K6V6k6r6x66©6¶6×6ã6
777*78(838V8¥8ï9ö9z;˜;f=\>d>?ù? @ X   ’0˜0:1@1P1ğ12ª2 3¨3[4=5Ö5Ü5~6„6”647K7{78Ø:ï::>>>B>F>J>N>R>V>Z>^>b>f>s>N?f?u?¡? P 4   0%0/:Ô;ñ;<V<c<B=Q=×=İ=â=è=ï=>>
?6?^?•?Ÿ? ` „   *212K24 4.4^45E5O5g55Ä5ó5`7Š7¥7Í7ı7"8B8b8˜8Ê89J9Š9Â9ò9:J:¢:â:
;2;R;<"<J<r<š<ê<=2=R=r=¢=â=">B>b>‚>ª>Ò>?"?R?r?’?²?Ò?ò? p H   0:0j0’0²0Ò0ò0121R1r1’1²1Ò1Û1à1æ1ì1ò1ø1ş12222"2'212B2F2K2   € L   Œ1˜1œ1 1¤1°1´12 2$2(2,2024282<2@2D2H2„2ˆ2Œ22”2˜2Ô2Ø2Ü2à2ä2´9¸9¼9À9     1$1(1,1014181<1@1D1H1L1P1T1X1\1`1d1h1l1p1t1x1|1€1„1ˆ1Œ11”1˜1œ1 1¤1¨1¬1°1´1¸1¼1À1Ä1È1Ì1Ğ1Ô1Ø1Ü1à1ä1è1ì1ğ1ô1ø1ü1 22222222 2$2(2,2024282<2@2D2H2L2P2T2X2\2`2d2h2l2p2t2x2|2€2„2ˆ2Œ22”2˜2œ2\=`=d=h=l=p=t=x=|=€=„=ˆ=Œ==”=˜=œ= =ˆ>Œ>¤>¨>¼>À>Ä>È>Ì>Ğ>Ô>Ø>Ü>à>4?8?Ì?Ğ?à?ä?è?ì?ô?        00 00040<0T0d0h0x0|0Œ00”0œ0´0Ä0È0Ø0Ü0ä0ü011 1$1,1D1T1X1h1l1t1Œ1œ1 1°1´1¼1Ô1ä1è1ø1ü122,202@2D2L2d2t2x2ˆ2Œ22”2œ2´2Ä2È2Ø2Ü2à2è2 333$3(3,343L3\3`3h3€33”3¤3¨3°3È3Ø3Ü3ì3ğ3ô3ø3ü344,4044484@4X4h4l4p4x44 4¤4¬4Ä4ì5ø56 6(6,60686L6T6\6d6l6€6œ6 6À6à6ü6 77 7@7`7|7€7œ7 7À7Ì7è7ô7808L8P8p8Œ88°8¸8¼8Ô8Ø8è899 9P9X9\9t9x9”9˜9 9¨9°9´9¼9Ğ9ì9ğ9:0:P:p::°:Ğ:ì:ğ:;0;P;p;;œ;¸;Ø;ô;ø;< <4<<<P<X<l<t<x<|<„<Œ<”<¨<°<´<¼<Ä<Ì<Ø<ø<=<=P=\=d=”=¨=´=¼=ü=> >4>@>H>`>h>t>”> >À>È>Ğ>Ø>ä>??? ?@?H?P?\?|?„??°?¸?Ä?ä?ğ? ° ¸  00<0D0L0T0\0d0p00˜0 0¨0´0Ô0à01,181@1p1„11˜1Ä1Ì1Ô1Ü1ä1ì1ô1ü12222$2,242<2D2L2l2|22¤2°2¸2ø23303<3D3\3h3 3´3À3È3à3ì344$4,444L4`4l4t4¤4¸4Ä4Ì4ü455$5T5h5t5|5¬5À5Ì5Ô5ô5ü56(646<6\6d6l6t6Œ6 6¬6´6Ô6Ü6ä6ì677$7,7\7p7|7„7´7È7Ô7Ü78 8,848T8l8€8Œ8”8Ä8Ø8ä8ì899,9@9L9T9„9˜9¤9¬9Ì9Ô9ì9 :::D:X:d:l:œ:°:¼:Ä:ô:;;;L;`;l;t;¤;¸;Ä;Ì;ü;<<$<D<\<p<|<„<¤<¼<Ğ<Ü<ä<=(=4=<=l=€=Œ=”=Ä=Ø=ä=ì=>0><>D>t>ˆ>”>œ>Ì>à>ì>ô>$?8?D?L?|??œ?¤?Ô?è?ô?ü? À    ,0@0L0T0 ğ     00$0(0D0H0L0d0ˆ02$2,242<2D2L2T2\2d2l2t2|2„2Œ2”2œ2¤2¬2´2¼2Ä2Ì2Ğ2$3(3P3T3X3\3`3d3h3l3p3t3 455(585H5l5x5|5€5„5ˆ55”5À9¸:À:<=@=`=d=h=l=p=t=x=|=€=„=ˆ=Œ==”=˜=œ= =¤=¨=¬=°=´=¸=¼=À=Ä=È=Ì=Ğ=Ô=Ø=Ü=à=ä=è=ì=ğ=ô=ø=ü= >>>>> >(>,>0>4>8><>@>D>H>L>X>@?D?     0   °2à2343d3„3ˆ3Œ33”3Ğ3ô3444T4t44¸4Ğ4è4                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        // continue retrying.
                                warn(error_1);
                            }
                            closeFn();
                        }
                        return [3 /*break*/, 4];
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    PersistentConnection.prototype.interrupt = function (reason) {
        log('Interrupting connection for reason: ' + reason);
        this.interruptReasons_[reason] = true;
        if (this.realtime_) {
            this.realtime_.close();
        }
        else {
            if (this.establishConnectionTimer_) {
                clearTimeout(this.establishConnectionTimer_);
                this.establishConnectionTimer_ = null;
            }
            if (this.connected_) {
                this.onRealtimeDisconnect_();
            }
        }
    };
    PersistentConnection.prototype.resume = function (reason) {
        log('Resuming connection for reason: ' + reason);
        delete this.interruptReasons_[reason];
        if (isEmpty(this.interruptReasons_)) {
            this.reconnectDelay_ = RECONNECT_MIN_DELAY;
            if (!this.realtime_) {
                this.scheduleConnect_(0);
            }
        }
    };
    PersistentConnection.prototype.handleTimestamp_ = function (timestamp) {
        var delta = timestamp - new Date().getTime();
        this.onServerInfoUpdate_({ serverTimeOffset: delta });
    };
    PersistentConnection.prototype.cancelSentTransactions_ = function () {
        for (var i = 0; i < this.outstandingPuts_.length; i++) {
            var put = this.outstandingPuts_[i];
            if (put && /*hash*/ 'h' in put.request && put.queued) {
                if (put.onComplete) {
                    put.onComplete('disconnect');
                }
                delete this.outstandingPuts_[i];
                this.outstandingPutCount_--;
            }
        }
        // Clean up array occasionally.
        if (this.outstandingPutCount_ === 0) {
            this.outstandingPuts_ = [];
        }
    };
    PersistentConnection.prototype.onListenRevoked_ = function (pathString, query) {
        // Remove the listen and manufacture a "permission_denied" error for the failed listen.
        var queryId;
        if (!query) {
            queryId = 'default';
        }
        else {
            queryId = query.map(function (q) { return ObjectToUniqueKey(q); }).join('$');
        }
        var listen = this.removeListen_(pathString, queryId);
        if (listen && listen.onComplete) {
            listen.onComplete('permission_denied');
        }
    };
    PersistentConnection.prototype.removeListen_ = function (pathString, queryId) {
        var normalizedPathString = new Path(pathString).toString(); // normalize path.
        var listen;
        if (this.listens.has(normalizedPathString)) {
            var map = this.listens.get(normalizedPathString);
            listen = map.get(queryId);
            map.delete(queryId);
            if (map.size === 0) {
                this.listens.delete(normalizedPathString);
            }
        }
        else {
            // all listens for this path has already been removed
            listen = undefined;
        }
        return listen;
    };
    PersistentConnection.prototype.onAuthRevoked_ = function (statusCode, explanation) {
        log('Auth token revoked: ' + statusCode + '/' + explanation);
        this.authToken_ = null;
        this.forceTokenRefresh_ = true;
        this.realtime_.close();
        if (statusCode === 'invalid_token' || statusCode === 'permission_denied') {
            // We'll wait a couple times before logging the warning / increasing the
            // retry period since oauth tokens will report as "invalid" if they're
            // just expired. Plus there may be transient issues that resolve themselves.
            this.invalidAuthTokenCount_++;
            if (this.invalidAuthTokenCount_ >= INVALID_TOKEN_THRESHOLD) {
                // Set a long reconnect delay because recovery is unlikely
                this.reconnectDelay_ = RECONNECT_MAX_DELAY_FOR_ADMINS;
                // Notify the auth token provider that the token is invalid, which will log
                // a warning
                this.authTokenProvider_.notifyForInvalidToken();
            }
        }
    };
    PersistentConnection.prototype.onAppCheckRevoked_ = function (statusCode, explanation) {
        log('App check token revoked: ' + statusCode + '/' + explanation);
        this.appCheckToken_ = null;
        this.forceTokenRefresh_ = true;
        // Note: We don't close the connection as the developer may not have
        // enforcement enabled. The backend closes connections with enforcements.
        if (statusCode === 'invalid_token' || statusCode === 'permission_denied') {
            // We'll wait a couple times before logging the warning / increasing the
            // retry period since oauth tokens will report as "invalid" if they're
            // just expired. Plus there may be transient issues that resolve themselves.
            this.invalidAppCheckTokenCount_++;
            if (this.invalidAppCheckTokenCount_ >= INVALID_TOKEN_THRESHOLD) {
                this.appCheckTokenProvider_.notifyForInvalidToken();
            }
        }
    };
    PersistentConnection.prototype.onSecurityDebugPacket_ = function (body) {
        if (this.securityDebugCallback_) {
            this.securityDebugCallback_(body);
        }
        else {
            if ('msg' in body) {
                console.log('FIREBASE: ' + body['msg'].replace('\n', '\nFIREBASE: '));
            }
        }
    };
    PersistentConnection.prototype.restoreState_ = function () {
        var e_1, _a, e_2, _b;
        //Re-authenticate ourselves if we have a credential stored.
        this.tryAuth();
        this.tryAppCheck();
        try {
            // Puts depend on having received the corresponding data update from the server before they complete, so we must
            // make sure to send listens before puts.
            for (var _c = __values(this.listens.values()), _d = _c.next(); !_d.done; _d = _c.next()) {
                var queries = _d.value;
                try {
                    for (var _e = (e_2 = void 0, __values(queries.values())), _f = _e.next(); !_f.done; _f = _e.next()) {
                        var listenSpec = _f.value;
                        this.sendListen_(listenSpec);
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            }
            finally { if (e_1) throw e_1.error; }
        }
        for (var i = 0; i < this.outstandingPuts_.length; i++) {
            if (this.outstandingPuts_[i]) {
                this.sendPut_(i);
            }
        }
        while (this.onDisconnectRequestQueue_.length) {
            var request = this.onDisconnectRequestQueue_.shift();
            this.sendOnDisconnect_(request.action, request.pathString, request.data, request.onComplete);
        }
        for (var i = 0; i < this.outstandingGets_.length; i++) {
            if (this.outstandingGets_[i]) {
                this.sendGet_(i);
            }
        }
    };
    /**
     * Sends client stats for first connection
     */
    PersistentConnection.prototype.sendConnectStats_ = function () {
        var stats = {};
        var clientName = 'js';
        if (isNodeSdk()) {
            if (this.repoInfo_.nodeAdmin) {
                clientName = 'admin_node';
            }
            else {
                clientName = 'node';
            }
        }
        stats['sdk.' + clientName + '.' + SDK_VERSION.replace(/\./g, '-')] = 1;
        if (isMobileCordova()) {
            stats['framework.cordova'] = 1;
        }
        else if (isReactNative()) {
            stats['framework.reactnative'] = 1;
        }
        this.reportStats(stats);
    };
    PersistentConnection.prototype.shouldReconnect_ = function () {
        var online = OnlineMonitor.getInstance().currentlyOnline();
        return isEmpty(this.interruptReasons_) && online;
    };
    PersistentConnection.nextPersistentConnectionId_ = 0;
    /**
     * Counter for number of connections created. Mainly used for tagging in the logs
     */
    PersistentConnection.nextConnectionId_ = 0;
    return PersistentConnection;
}(ServerActions));

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var NamedNode = /** @class */ (function () {
    function NamedNode(name, node) {
        this.name = name;
        this.node = node;
    }
    NamedNode.Wrap = function (name, node) {
        return new NamedNode(name, node);
    };
    return NamedNode;
}());

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var Index = /** @class */ (function () {
    function Index() {
    }
    /**
     * @returns A standalone comparison function for
     * this index
     */
    Index.prototype.getCompare = function () {
        return this.compare.bind(this);
    };
    /**
     * Given a before and after value for a node, determine if the indexed value has changed. Even if they are different,
     * it's possible that the changes are isolated to parts of the snapshot that are not indexed.
     *
     *
     * @returns True if the portion of the snapshot being indexed changed between oldNode and newNode
     */
    Index.prototype.indexedValueChanged = function (oldNode, newNode) {
        var oldWrapped = new NamedNode(MIN_NAME, oldNode);
        var newWrapped = new NamedNode(MIN_NAME, newNode);
        return this.compare(oldWrapped, newWrapped) !== 0;
    };
    /**
     * @returns a node wrapper that will sort equal to or less than
     * any other node wrapper, using this index
     */
    Index.prototype.minPost = function () {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        return NamedNode.MIN;
    };
    return Index;
}());

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __EMPTY_NODE;
var KeyIndex = /** @class */ (function (_super) {
    __extends(KeyIndex, _super);
    function KeyIndex() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(KeyIndex, "__EMPTY_NODE", {
        get: function () {
            return __EMPTY_NODE;
        },
        set: function (val) {
            __EMPTY_NODE = val;
        },
        enumerable: false,
        configurable: true
    });
    KeyIndex.prototype.compare = function (a, b) {
        return nameCompare(a.name, b.name);
    };
    KeyIndex.prototype.isDefinedOn = function (node) {
        // We could probably return true here (since every node has a key), but it's never called
        // so just leaving unimplemented for now.
        throw assertionError('KeyIndex.isDefinedOn not expected to be called.');
    };
    KeyIndex.prototype.indexedValueChanged = function (oldNode, newNode) {
        return false; // The key for a node never changes.
    };
    KeyIndex.prototype.minPost = function () {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        return NamedNode.MIN;
    };
    KeyIndex.prototype.maxPost = function () {
        // TODO: This should really be created once and cached in a static property, but
        // NamedNode isn't defined yet, so I can't use it in a static.  Bleh.
        return new NamedNode(MAX_NAME, __EMPTY_NODE);
    };
    KeyIndex.prototype.makePost = function (indexValue, name) {
        assert(typeof indexValue === 'string', 'KeyIndex indexValue must always be a string.');
        // We just use empty node, but it'll never be compared, since our comparator only looks at name.
        return new NamedNode(indexValue, __EMPTY_NODE);
    };
    /**
     * @returns String representation for inclusion in a query spec
     */
    KeyIndex.prototype.toString = function () {
        return '.key';
    };
    return KeyIndex;
}(Index));
var KEY_INDEX = new KeyIndex();

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * An iterator over an LLRBNode.
 */
var SortedMapIterator = /** @class */ (function () {
    /**
     * @param node - Node to iterate.
     * @param isReverse_ - Whether or not to iterate in reverse
     */
    function SortedMapIterator(node, startKey, comparator, isReverse_, resultGenerator_) {
        if (resultGenerator_ === void 0) { resultGenerator_ = null; }
        this.isReverse_ = isReverse_;
        this.resultGenerator_ = resultGenerator_;
        this.nodeStack_ = [];
        var cmp = 1;
        while (!node.isEmpty()) {
            node = node;
            cmp = startKey ? comparator(node.key, startKey) : 1;
            // flip the comparison if we're going in reverse
            if (isReverse_) {
                cmp *= -1;
            }
            if (cmp < 0) {
                // This node is less than our start key. ignore it
                if (this.isReverse_) {
                    node = node.left;
                }
                else {
                    node = node.right;
                }
            }
            else if (cmp === 0) {
                // This node is exactly equal to our start key. Push it on the stack, but stop iterating;
                this.nodeStack_.push(node);
                break;
            }
            else {
                // This node is greater than our start key, add it to the stack and move to the next one
                this.nodeStack_.push(node);
                if (this.isReverse_) {
                    node = node.right;
                }
                else {
                    node = node.left;
                }
            }
        }
    }
    SortedMapIterator.prototype.getNext = function () {
        if (this.nodeStack_.length === 0) {
            return null;
        }
        var node = this.nodeStack_.pop();
        var result;
        if (this.resultGenerator_) {
            result = this.resultGenerator_(node.key, node.value);
        }
        else {
            result = { key: node.key, value: node.value };
        }
        if (this.isReverse_) {
            node = node.left;
            while (!node.isEmpty()) {
                this.nodeStack_.push(node);
                node = node.right;
            }
        }
        else {
            node = node.right;
            while (!node.isEmpty()) {
                this.nodeStack_.push(node);
                node = node.left;
            }
        }
        return result;
    };
    SortedMapIterator.prototype.hasNext = function () {
        return this.nodeStack_.length > 0;
    };
    SortedMapIterator.prototype.peek = function () {
        if (this.nodeStack_.length === 0) {
            return null;
        }
        var node = this.nodeStack_[this.nodeStack_.length - 1];
        if (this.resultGenerator_) {
            return this.resultGenerator_(node.key, node.value);
        }
        else {
            return { key: node.key, value: node.value };
        }
    };
    return SortedMapIterator;
}());
/**
 * Represents a node in a Left-leaning Red-Black tree.
 */
var LLRBNode = /** @class */ (function () {
    /**
     * @param key - Key associated with this node.
     * @param value - Value associated with this node.
     * @param color - Whether this node is red.
     * @param left - Left child.
     * @param right - Right child.
     */
    function LLRBNode(key, value, color, left, right) {
        this.key = key;
        this.value = value;
        this.color = color != null ? color : LLRBNode.RED;
        this.left =
            left != null ? left : SortedMap.EMPTY_NODE;
        this.right =
            right != null ? right : SortedMap.EMPTY_NODE;
    }
    /**
     * Returns a copy of the current node, optionally replacing pieces of it.
     *
     * @param key - New key for the node, or null.
     * @param value - New value for the node, or null.
     * @param color - New color for the node, or null.
     * @param left - New left child for the node, or null.
     * @param right - New right child for the node, or null.
     * @returns The node copy.
     */
    LLRBNode.prototype.copy = function (key, value, color, left, right) {
        return new LLRBNode(key != null ? key : this.key, value != null ? value : this.value, color != null ? color : this.color, left != null ? left : this.left, right != null ? right : this.right);
    };
    /**
     * @returns The total number of nodes in the tree.
     */
    LLRBNode.prototype.count = function () {
        return this.left.count() + 1 + this.right.count();
    };
    /**
     * @returns True if the tree is empty.
     */
    LLRBNode.prototype.isEmpty = function () {
        return false;
    };
    /**
     * Traverses the tree in key order and calls the specified action function
     * for each node.
     *
     * @param action - Callback function to be called for each
     *   node.  If it returns true, traversal is aborted.
     * @returns The first truthy value returned by action, or the last falsey
     *   value returned by action
     */
    LLRBNode.prototype.inorderTraversal = function (action) {
        return (this.left.inorderTraversal(action) ||
            !!action(this.key, this.value) ||
            this.right.inorderTraversal(action));
    };
    /**
     * Traverses the tree in reverse key order and calls the specified action function
     * for each node.
     *
     * @param action - Callback function to be called for each
     * node.  If it returns true, traversal is aborted.
     * @returns True if traversal was aborted.
     */
    LLRBNode.prototype.reverseTraversal = function (action) {
        return (this.right.reverseTraversal(action) ||
            action(this.key, this.value) ||
            this.left.reverseTraversal(action));
    };
    /**
     * @returns The minimum node in the tree.
     */
    LLRBNode.prototype.min_ = function () {
        if (this.left.isEmpty()) {
            return this;
        }
        else {
            return this.left.min_();
        }
    };
    /**
     * @returns The maximum key in the tree.
     */
    LLRBNode.prototype.minKey = function () {
        return this.min_().key;
    };
    /**
     * @returns The maximum key in the tree.
     */
    LLRBNode.prototype.maxKey = function () {
        if (this.right.isEmpty()) {
            return this.key;
        }
        else {
            return this.right.maxKey();
        }
    };
    /**
     * @param key - Key to insert.
     * @param value - Value to insert.
     * @param comparator - Comparator.
     * @returns New tree, with the key/value added.
     */
    LLRBNode.prototype.insert = function (key, value, comparator) {
        var n = this;
        var cmp = comparator(key, n.key);
        if (cmp < 0) {
            n = n.copy(null, null, null, n.left.insert(key, value, comparator), null);
        }
        else if (cmp === 0) {
            n = n.copy(null, value, null, null, null);
        }
        else {
            n = n.copy(null, null, null, null, n.right.insert(key, value, comparator));
        }
        return n.fixUp_();
    };
    /**
     * @returns New tree, with the minimum key removed.
     */
    LLRBNode.prototype.removeMin_ = function () {
        if (this.left.isEmpty()) {
            return SortedMap.EMPTY_NODE;
        }
        var n = this;
        if (!n.left.isRed_() && !n.left.left.isRed_()) {
            n = n.moveRedLeft_();
        }
        n = n.copy(null, null, null, n.left.removeMin_(), null);
        return n.fixUp_();
    };
    /**
     * @param key - The key of the item to remove.
     * @param comparator - Comparator.
     * @returns New tree, with the specified item removed.
     */
    LLRBNode.prototype.remove = function (key, comparator) {
        var n, smallest;
        n = this;
        if (comparator(key, n.key) < 0) {
            if (!n.left.isEmpty() && !n.left.isRed_() && !n.left.left.isRed_()) {
                n = n.moveRedLeft_();
            }
            n = n.copy(null, null, null, n.left.remove(key, comparator), null);
        }
        else {
            if (n.left.isRed_()) {
                n = n.rotateRight_();
            }
            if (!n.right.isEmpty() && !n.right.isRed_() && !n.right.left.isRed_()) {
                n = n.moveRedRight_();
            }
            if (comparator(key, n.key) === 0) {
                if (n.right.isEmpty()) {
                    return SortedMap.EMPTY_NODE;
                }
                else {
                    smallest = n.right.min_();
                    n = n.copy(smallest.key, smallest.value, null, null, n.right.removeMin_());
                }
            }
            n = n.copy(null, null, null, null, n.right.remove(key, comparator));
        }
        return n.fixUp_();
    };
    /**
     * @returns Whether this is a RED node.
     */
    LLRBNode.prototype.isRed_ = function () {
        return this.color;
    };
    /**
     * @returns New tree after performing any needed rotations.
     */
    LLRBNode.prototype.fixUp_ = function () {
        var n = this;
        if (n.right.isRed_() && !n.left.isRed_()) {
            n = n.rotateLeft_();
        }
        if (n.left.isRed_() && n.left.left.isRed_()) {
            n = n.rotateRight_();
        }
        if (n.left.isRed_() && n.right.isRed_()) {
            n = n.colorFlip_();
        }
        return n;
    };
    /**
     * @returns New tree, after moveRedLeft.
     */
    LLRBNode.prototype.moveRedLeft_ = function () {
        var n = this.colorFlip_();
        if (n.right.left.isRed_()) {
            n = n.copy(null, null, null, null, n.right.rotateRight_());
            n = n.rotateLeft_();
            n = n.colorFlip_();
        }
        return n;
    };
    /**
     * @returns New tree, after moveRedRight.
     */
    LLRBNode.prototype.moveRedRight_ = function () {
        var n = this.colorFlip_();
        if (n.left.left.isRed_()) {
            n = n.rotateRight_();
            n = n.colorFlip_();
        }
        return n;
    };
    /**
     * @returns New tree, after rotateLeft.
     */
    LLRBNode.prototype.rotateLeft_ = function () {
        var nl = this.copy(null, null, LLRBNode.RED, null, this.right.left);
        return this.right.copy(null, null, this.color, nl, null);
    };
    /**
     * @returns New tree, after rotateRight.
     */
    LLRBNode.prototype.rotateRight_ = function () {
        var nr = this.copy(null, null, LLRBNode.RED, this.left.right, null);
        return this.left.copy(null, null, this.color, null, nr);
    };
    /**
     * @returns Newt ree, after colorFlip.
     */
    LLRBNode.prototype.colorFlip_ = function () {
        var left = this.left.copy(null, null, !this.left.color, null, null);
        var right = this.right.copy(null, null, !this.right.color, null, null);
        return this.copy(null, null, !this.color, left, right);
    };
    /**
     * For testing.
     *
     * @returns True if all is well.
     */
    LLRBNode.prototype.checkMaxDepth_ = function () {
        var blackDepth = this.check_();
        return Math.pow(2.0, blackDepth) <= this.count() + 1;
    };
    LLRBNode.prototype.check_ = function () {
        if (this.isRed_() && this.left.isRed_()) {
            throw new Error('Red node has red child(' + this.key + ',' + this.value + ')');
        }
        if (this.right.isRed_()) {
            throw new Error('Right child of (' + this.key + ',' + this.value + ') is red');
        }
        var blackDepth = this.left.check_();
        if (blackDepth !== this.right.check_()) {
            throw new Error('Black depths differ');
        }
        else {
            return blackDepth + (this.isRed_() ? 0 : 1);
        }
    };
    LLRBNode.RED = true;
    LLRBNode.BLACK = false;
    return LLRBNode;
}());
/**
 * Represents an empty node (a leaf node in the Red-Black Tree).
 */
var LLRBEmptyNode = /** @class */ (function () {
    function LLRBEmptyNode() {
    }
    /**
     * Returns a copy of the current node.
     *
     * @returns The node copy.
     */
    LLRBEmptyNode.prototype.copy = function (key, value, color, left, right) {
        return this;
    };
    /**
     * Returns a copy of the tree, with the specified key/value added.
     *
     * @param key - Key to be added.
     * @param value - Value to be added.
     * @param comparator - Comparator.
     * @returns New tree, with item added.
     */
    LLRBEmptyNode.prototype.insert = function (key, value, comparator) {
        return new LLRBNode(key, value, null);
    };
    /**
     * Returns a copy of the tree, with the specified key removed.
     *
     * @param key - The key to remove.
     * @param comparator - Comparator.
     * @returns New tree, with item removed.
     */
    LLRBEmptyNode.prototype.remove = function (key, comparator) {
        return this;
    };
    /**
     * @returns The total number of nodes in the tree.
     */
    LLRBEmptyNode.prototype.count = function () {
        return 0;
    };
    /**
     * @returns True if the tree is empty.
     */
    LLRBEmptyNode.prototype.isEmpty = function () {
        return true;
    };
    /**
     * Traverses the tree in key order and calls the specified action function
     * for each node.
     *
     * @param action - Callback function to be called for each
     * node.  If it returns true, traversal is aborted.
     * @returns True if traversal was aborted.
     */
    LLRBEmptyNode.prototype.inorderTraversal = function (action) {
        return false;
    };
    /**
     * Traverses the tree in reverse key order and calls the specified action function
     * for each node.
     *
     * @param action - Callback function to be called for each
     * node.  If it returns true, traversal is aborted.
     * @returns True if traversal was aborted.
     */
    LLRBEmptyNode.prototype.reverseTraversal = function (action) {
        return false;
    };
    LLRBEmptyNode.prototype.minKey = function () {
        return null;
    };
    LLRBEmptyNode.prototype.maxKey = function () {
        return null;
    };
    LLRBEmptyNode.prototype.check_ = function () {
        return 0;
    };
    /**
     * @returns Whether this node is red.
     */
    LLRBEmptyNode.prototype.isRed_ = function () {
        return false;
    };
    return LLRBEmptyNode;
}());
/**
 * An immutable sorted map implementation, based on a Left-leaning Red-Black
 * tree.
 */
var SortedMap = /** @class */ (function () {
    /**
     * @param comparator_ - Key comparator.
     * @param root_ - Optional root node for the map.
     */
    function SortedMap(comparator_, root_) {
        if (root_ === void 0) { root_ = SortedMap.EMPTY_NODE; }
        this.comparator_ = comparator_;
        this.root_ = root_;
    }
    /**
     * Returns a copy of the map, with the specified key/value added or replaced.
     * (TODO: We should perhaps rename this method to 'put')
     *
     * @param key - Key to be added.
     * @param value - Value to be added.
     * @returns New map, with item added.
     */
    SortedMap.prototype.insert = function (key, value) {
        return new SortedMap(this.comparator_, this.root_
            .insert(key, value, this.comparator_)
            .copy(null, null, LLRBNode.BLACK, null, null));
    };
    /**
     * Returns a copy of the map, with the specified key removed.
     *
     * @param key - The key to remove.
     * @returns New map, with item removed.
     */
    SortedMap.prototype.remove = function (key) {
        return new SortedMap(this.comparator_, this.root_
            .remove(key, this.comparator_)
            .copy(null, null, LLRBNode.BLACK, null, null));
    };
    /**
     * Returns the value of the node with the given key, or null.
     *
     * @param key - The key to look up.
     * @returns The value of the node with the given key, or null if the
     * key doesn't exist.
     */
    SortedMap.prototype.get = function (key) {
        var cmp;
        var node = this.root_;
        while (!node.isEmpty()) {
            cmp = this.comparator_(key, node.key);
            if (cmp === 0) {
                return node.value;
            }
            else if (cmp < 0) {
                node = node.left;
            }
            else if (cmp > 0) {
                node = node.right;
            }
        }
        return null;
    };
    /**
     * Returns the key of the item *before* the specified key, or null if key is the first item.
     * @param key - The key to find the predecessor of
     * @returns The predecessor key.
     */
    SortedMap.prototype.getPredecessorKey = function (key) {
        var cmp, node = this.root_, rightParent = null;
        while (!node.isEmpty()) {
            cmp = this.comparator_(key, node.key);
            if (cmp === 0) {
                if (!node.left.isEmpty()) {
                    node = node.left;
                    while (!node.right.isEmpty()) {
                        node = node.right;
                    }
                    return node.key;
                }
                else if (rightParent) {
                    return rightParent.key;
                }
                else {
                    return null; // first item.
                }
            }
            else if (cmp < 0) {
                node = node.left;
            }
            else if (cmp > 0) {
                rightParent = node;
                node = node.right;
            }
        }
        throw new Error('Attempted to find predecessor key for a nonexistent key.  What gives?');
    };
    /**
     * @returns True if the map is empty.
     */
    SortedMap.prototype.isEmpty = function () {
        return this.root_.isEmpty();
    };
    /**
     * @returns The total number of nodes in the map.
     */
    SortedMap.prototype.count = function () {
        return this.root_.count();
    };
    /**
     * @returns The minimum key in the map.
     */
    SortedMap.prototype.minKey = function () {
        return this.root_.minKey();
    };
    /**
     * @returns The maximum key in the map.
     */
    SortedMap.prototype.maxKey = function () {
        return this.root_.maxKey();
    };
    /**
     * Traverses the map in key order and calls the specified action function
     * for each key/value pair.
     *
     * @param action - Callback function to be called
     * for each key/value pair.  If action returns true, traversal is aborted.
     * @returns The first truthy value returned by action, or the last falsey
     *   value returned by action
     */
    SortedMap.prototype.inorderTraversal = function (action) {
        return this.root_.inorderTraversal(action);
    };
    /**
     * Traverses the map in reverse key order and calls the specified action function
     * for each key/value pair.
     *
     * @param action - Callback function to be called
     * for each key/value pair.  If action returns true, traversal is aborted.
     * @returns True if the traversal was aborted.
     */
    SortedMap.prototype.reverseTraversal = function (action) {
        return this.root_.reverseTraversal(action);
    };
    /**
     * Returns an iterator over the SortedMap.
     * @returns The iterator.
     */
    SortedMap.prototype.getIterator = function (resultGenerator) {
        return new SortedMapIterator(this.root_, null, this.comparator_, false, resultGenerator);
    };
    SortedMap.prototype.getIteratorFrom = function (key, resultGenerator) {
        return new SortedMapIterator(this.root_, key, this.comparator_, false, resultGenerator);
    };
    SortedMap.prototype.getReverseIteratorFrom = function (key, resultGenerator) {
        return new SortedMapIterator(this.root_, key, this.comparator_, true, resultGenerator);
    };
    SortedMap.prototype.getReverseIterator = function (resultGenerator) {
        return new SortedMapIterator(this.root_, null, this.comparator_, true, resultGenerator);
    };
    /**
     * Always use the same empty node, to reduce memory.
     */
    SortedMap.EMPTY_NODE = new LLRBEmptyNode();
    return SortedMap;
}());

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function NAME_ONLY_COMPARATOR(left, right) {
    return nameCompare(left.name, right.name);
}
function NAME_COMPARATOR(left, right) {
    return nameCompare(left, right);
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var MAX_NODE$2;
function setMaxNode$1(val) {
    MAX_NODE$2 = val;
}
var priorityHashText = function (priority) {
    if (typeof priority === 'number') {
        return 'number:' + doubleToIEEE754String(priority);
    }
    else {
        return 'string:' + priority;
    }
};
/**
 * Validates that a priority snapshot Node is valid.
 */
var validatePriorityNode = function (priorityNode) {
    if (priorityNode.isLeafNode()) {
        var val = priorityNode.val();
        assert(typeof val === 'string' ||
            typeof val === 'number' ||
            (typeof val === 'object' && contains(val, '.sv')), 'Priority must be a string or number.');
    }
    else {
        assert(priorityNode === MAX_NODE$2 || priorityNode.isEmpty(), 'priority of unexpected type.');
    }
    // Don't call getPriority() on MAX_NODE to avoid hitting assertion.
    assert(priorityNode === MAX_NODE$2 || priorityNode.getPriority().isEmpty(), "Priority nodes can't have a priority of their own.");
};

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __childrenNodeConstructor;
/**
 * LeafNode is a class for storing leaf nodes in a DataSnapshot.  It
 * implements Node and stores the value of the node (a string,
 * number, or boolean) accessible via getValue().
 */
var LeafNode = /** @class */ (function () {
    /**
     * @param value_ - The value to store in this leaf node. The object type is
     * possible in the event of a deferred value
     * @param priorityNode_ - The priority of this node.
     */
    function LeafNode(value_, priorityNode_) {
        if (priorityNode_ === void 0) { priorityNode_ = LeafNode.__childrenNodeConstructor.EMPTY_NODE; }
        this.value_ = value_;
        this.priorityNode_ = priorityNode_;
        this.lazyHash_ = null;
        assert(this.value_ !== undefined && this.value_ !== null, "LeafNode shouldn't be created with null/undefined value.");
        validatePriorityNode(this.priorityNode_);
    }
    Object.defineProperty(LeafNode, "__childrenNodeConstructor", {
        get: function () {
            return __childrenNodeConstructor;
        },
        set: function (val) {
            __childrenNodeConstructor = val;
        },
        enumerable: false,
        configurable: true
    });
    /** @inheritDoc */
    LeafNode.prototype.isLeafNode = function () {
        return true;
    };
    /** @inheritDoc */
    LeafNode.prototype.getPriority = function () {
        return this.priorityNode_;
    };
    /** @inheritDoc */
    LeafNode.prototype.updatePriority = function (newPriorityNode) {
        return new LeafNode(this.value_, newPriorityNode);
    };
    /** @inheritDoc */
    LeafNode.prototype.getImmediateChild = function (childName) {
        // Hack to treat priority as a regular child
        if (childName === '.priority') {
            return this.priorityNode_;
        }
        else {
            return LeafNode.__childrenNodeConstructor.EMPTY_NODE;
        }
    };
    /** @inheritDoc */
    LeafNode.prototype.getChild = function (path) {
        if (pathIsEmpty(path)) {
            return this;
        }
        else if (pathGetFront(path) === '.priority') {
            return this.priorityNode_;
        }
        else {
            return LeafNode.__childrenNodeConstructor.EMPTY_NODE;
        }
    };
    LeafNode.prototype.hasChild = function () {
        return false;
    };
    /** @inheritDoc */
    LeafNode.prototype.getPredecessorChildName = function (childName, childNode) {
        return null;
    };
    /** @inheritDoc */
    LeafNode.prototype.updateImmediateChild = function (childName, newChildNode) {
        if (childName === '.priority') {
            return this.updatePriority(newChildNode);
        }
        else if (newChildNode.isEmpty() && childName !== '.priority') {
            return this;
        }
        else {
            return LeafNode.__childrenNodeConstructor.EMPTY_NODE.updateImmediateChild(childName, newChildNode).updatePriority(this.priorityNode_);
        }
    };
    /** @inheritDoc */
    LeafNode.prototype.updateChild = function (path, newChildNode) {
        var front = pathGetFront(path);
        if (front === null) {
            return newChildNode;
        }
        else if (newChildNode.isEmpty() && front !== '.priority') {
            return this;
        }
        else {
            assert(front !== '.priority' || pathGetLength(path) === 1, '.priority must be the last token in a path');
            return this.updateImmediateChild(front, LeafNode.__childrenNodeConstructor.EMPTY_NODE.updateChild(pathPopFront(path), newChildNode));
        }
    };
    /** @inheritDoc */
    LeafNode.prototype.isEmpty = function () {
        return false;
    };
    /** @inheritDoc */
    LeafNode.prototype.numChildren = function () {
        return 0;
    };
    /** @inheritDoc */
    LeafNode.prototype.forEachChild = function (index, action) {
        return false;
    };
    LeafNode.prototype.val = function (exportFormat) {
        if (exportFormat && !this.getPriority().isEmpty()) {
            return {
                '.value': this.getValue(),
                '.priority': this.getPriority().val()
            };
        }
        else {
            return this.getValue();
        }
    };
    /** @inheritDoc */
    LeafNode.prototype.hash = function () {
        if (this.lazyHash_ === null) {
            var toHash = '';
            if (!this.priorityNode_.isEmpty()) {
                toHash +=
                    'priority:' +
                        priorityHashText(this.priorityNode_.val()) +
                        ':';
            }
            var type = typeof this.value_;
            toHash += type + ':';
            if (type === 'number') {
                toHash += doubleToIEEE754String(this.value_);
            }
            else {
                toHash += this.value_;
            }
            this.lazyHash_ = sha1(toHash);
        }
        return this.lazyHash_;
    };
    /**
     * Returns the value of the leaf node.
     * @returns The value of the node.
     */
    LeafNode.prototype.getValue = function () {
        return this.value_;
    };
    LeafNode.prototype.compareTo = function (other) {
        if (other === LeafNode.__childrenNodeConstructor.EMPTY_NODE) {
            return 1;
        }
        else if (other instanceof LeafNode.__childrenNodeConstructor) {
            return -1;
        }
        else {
            assert(other.isLeafNode(), 'Unknown node type');
            return this.compareToLeafNode_(other);
        }
    };
    /**
     * Comparison specifically for two leaf nodes
     */
    LeafNode.prototype.compareToLeafNode_ = function (otherLeaf) {
        var otherLeafType = typeof otherLeaf.value_;
        var thisLeafType = typeof this.value_;
        var otherIndex = LeafNode.VALUE_TYPE_ORDER.indexOf(otherLeafType);
        var thisIndex = LeafNode.VALUE_TYPE_ORDER.indexOf(thisLeafType);
        assert(otherIndex >= 0, 'Unknown leaf type: ' + otherLeafType);
        assert(thisIndex >= 0, 'Unknown leaf type: ' + thisLeafType);
        if (otherIndex === thisIndex) {
            // Same type, compare values
            if (thisLeafType === 'object') {
                // Deferred value nodes are all equal, but we should also never get to this point...
                return 0;
            }
            else {
                // Note that this works because true > false, all others are number or string comparisons
                if (this.value_ < otherLeaf.value_) {
                    return -1;
                }
                else if (this.value_ === otherLeaf.value_) {
                    return 0;
                }
                else {
                    return 1;
                }
            }
        }
        else {
            return thisIndex - otherIndex;
        }
    };
    LeafNode.prototype.withIndex = function () {
        return this;
    };
    LeafNode.prototype.isIndexed = function () {
        return true;
    };
    LeafNode.prototype.equals = function (other) {
        if (other === this) {
            return true;
        }
        else if (other.isLeafNode()) {
            var otherLeaf = other;
            return (this.value_ === otherLeaf.value_ &&
                this.priorityNode_.equals(otherLeaf.priorityNode_));
        }
        else {
            return false;
        }
    };
    /**
     * The sort order for comparing leaf nodes of different types. If two leaf nodes have
     * the same type, the comparison falls back to their value
     */
    LeafNode.VALUE_TYPE_ORDER = ['object', 'boolean', 'number', 'string'];
    return LeafNode;
}());

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var nodeFromJSON$1;
var MAX_NODE$1;
function setNodeFromJSON(val) {
    nodeFromJSON$1 = val;
}
function setMaxNode(val) {
    MAX_NODE$1 = val;
}
var PriorityIndex = /** @class */ (function (_super) {
    __extends(PriorityIndex, _super);
    function PriorityIndex() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    PriorityIndex.prototype.compare = function (a, b) {
        var aPriority = a.node.getPriority();
        var bPriority = b.node.getPriority();
        var indexCmp = aPriority.compareTo(bPriority);
        if (indexCmp === 0) {
            return nameCompare(a.name, b.name);
        }
        else {
            return indexCmp;
        }
    };
    PriorityIndex.prototype.isDefinedOn = function (node) {
        return !node.getPriority().isEmpty();
    };
    PriorityIndex.prototype.indexedValueChanged = function (oldNode, newNode) {
        return !oldNode.getPriority().equals(newNode.getPriority());
    };
    PriorityIndex.prototype.minPost = function () {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        return NamedNode.MIN;
    };
    PriorityIndex.prototype.maxPost = function () {
        return new NamedNode(MAX_NAME, new LeafNode('[PRIORITY-POST]', MAX_NODE$1));
    };
    PriorityIndex.prototype.makePost = function (indexValue, name) {
        var priorityNode = nodeFromJSON$1(indexValue);
        return new NamedNode(name, new LeafNode('[PRIORITY-POST]', priorityNode));
    };
    /**
     * @returns String representation for inclusion in a query spec
     */
    PriorityIndex.prototype.toString = function () {
        return '.priority';
    };
    return PriorityIndex;
}(Index));
var PRIORITY_INDEX = new PriorityIndex();

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var LOG_2 = Math.log(2);
var Base12Num = /** @class */ (function () {
    function Base12Num(length) {
        var logBase2 = function (num) {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            return parseInt((Math.log(num) / LOG_2), 10);
        };
        var bitMask = function (bits) { return parseInt(Array(bits + 1).join('1'), 2); };
        this.count = logBase2(length + 1);
        this.current_ = this.count - 1;
        var mask = bitMask(this.count);
        this.bits_ = (length + 1) & mask;
    }
    Base12Num.prototype.nextBitIsOne = function () {
        //noinspection JSBitwiseOperatorUsage
        var result = !(this.bits_ & (0x1 << this.current_));
        this.current_--;
        return result;
    };
    return Base12Num;
}());
/**
 * Takes a list of child nodes and constructs a SortedSet using the given comparison
 * function
 *
 * Uses the algorithm described in the paper linked here:
 * http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.46.1458
 *
 * @param childList - Unsorted list of children
 * @param cmp - The comparison method to be used
 * @param keyFn - An optional function to extract K from a node wrapper, if K's
 * type is not NamedNode
 * @param mapSortFn - An optional override for comparator used by the generated sorted map
 */
var buildChildSet = function (childList, cmp, keyFn, mapSortFn) {
    childList.sort(cmp);
    var buildBalancedTree = function (low, high) {
        var length = high - low;
        var namedNode;
        var key;
        if (length === 0) {
            return null;
        }
        else if (length === 1) {
            namedNode = childList[low];
            key = keyFn ? keyFn(namedNode) : namedNode;
            return new LLRBNode(key, namedNode.node, LLRBNode.BLACK, null, null);
        }
        else {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            var middle = parseInt((length / 2), 10) + low;
            var left = buildBalancedTree(low, middle);
            var right = buildBalancedTree(middle + 1, high);
            namedNode = childList[middle];
            key = keyFn ? keyFn(namedNode) : namedNode;
            return new LLRBNode(key, namedNode.node, LLRBNode.BLACK, left, right);
        }
    };
    var buildFrom12Array = function (base12) {
        var node = null;
        var root = null;
        var index = childList.length;
        var buildPennant = function (chunkSize, color) {
            var low = index - chunkSize;
            var high = index;
            index -= chunkSize;
            var childTree = buildBalancedTree(low + 1, high);
            var namedNode = childList[low];
            var key = keyFn ? keyFn(namedNode) : namedNode;
            attachPennant(new LLRBNode(key, namedNode.node, color, null, childTree));
        };
        var attachPennant = function (pennant) {
            if (node) {
                node.left = pennant;
                node = pennant;
            }
            else {
                root = pennant;
                node = pennant;
            }
        };
        for (var i = 0; i < base12.count; ++i) {
            var isOne = base12.nextBitIsOne();
            // The number of nodes taken in each slice is 2^(arr.length - (i + 1))
            var chunkSize = Math.pow(2, base12.count - (i + 1));
            if (isOne) {
                buildPennant(chunkSize, LLRBNode.BLACK);
            }
            else {
                // current == 2
                buildPennant(chunkSize, LLRBNode.BLACK);
                buildPennant(chunkSize, LLRBNode.RED);
            }
        }
        return root;
    };
    var base12 = new Base12Num(childList.length);
    var root = buildFrom12Array(base12);
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    return new SortedMap(mapSortFn || cmp, root);
};

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var _defaultIndexMap;
var fallbackObject = {};
var IndexMap = /** @class */ (function () {
    function IndexMap(indexes_, indexSet_) {
        this.indexes_ = indexes_;
        this.indexSet_ = indexSet_;
    }
    Object.defineProperty(IndexMap, "Default", {
        /**
         * The default IndexMap for nodes without a priority
         */
        get: function () {
            assert(fallbackObject && PRIORITY_INDEX, 'ChildrenNode.ts has not been loaded');
            _defaultIndexMap =
                _defaultIndexMap ||
                    new IndexMap({ '.priority': fallbackObject }, { '.priority': PRIORITY_INDEX });
            return _defaultIndexMap;
        },
        enumerable: false,
        configurable: true
    });
    IndexMap.prototype.get = function (indexKey) {
        var sortedMap = safeGet(this.indexes_, indexKey);
        if (!sortedMap) {
            throw new Error('No index defined for ' + indexKey);
        }
        if (sortedMap instanceof SortedMap) {
            return sortedMap;
        }
        else {
            // The index exists, but it falls back to just name comparison. Return null so that the calling code uses the
            // regular child map
            return null;
        }
    };
    IndexMap.prototype.hasIndex = function (indexDefinition) {
        return contains(this.indexSet_, indexDefinition.toString());
    };
    IndexMap.prototype.addIndex = function (indexDefinition, existingChildren) {
        assert(indexDefinition !== KEY_INDEX, "KeyIndex always exists and isn't meant to be added to the IndexMap.");
        var childList = [];
        var sawIndexedValue = false;
        var iter = existingChildren.getIterator(NamedNode.Wrap);
        var next = iter.getNext();
        while (next) {
            sawIndexedValue =
                sawIndexedValue || indexDefinition.isDefinedOn(next.node);
            childList.push(next);
            next = iter.getNext();
        }
        var newIndex;
        if (sawIndexedValue) {
            newIndex = buildChildSet(childList, indexDefinition.getCompare());
        }
        else {
            newIndex = fallbackObject;
        }
        var indexName = indexDefinition.toString();
        var newIndexSet = __assign({}, this.indexSet_);
        newIndexSet[indexName] = indexDefinition;
        var newIndexes = __assign({}, this.indexes_);
        newIndexes[indexName] = newIndex;
        return new IndexMap(newIndexes, newIndexSet);
    };
    /**
     * Ensure that this node is properly tracked in any indexes that we're maintaining
     */
    IndexMap.prototype.addToIndexes = function (namedNode, existingChildren) {
        var _this = this;
        var newIndexes = map(this.indexes_, function (indexedChildren, indexName) {
            var index = safeGet(_this.indexSet_, indexName);
            assert(index, 'Missing index implementation for ' + indexName);
            if (indexedChildren === fallbackObject) {
                // Check to see if we need to index everything
                if (index.isDefinedOn(namedNode.node)) {
                    // We need to build this index
                    var childList = [];
                    var iter = existingChildren.getIterator(NamedNode.Wrap);
                    var next = iter.getNext();
                    while (next) {
                        if (next.name !== namedNode.name) {
                            childList.push(next);
                        }
                        next = iter.getNext();
                    }
                    childList.push(namedNode);
                    return buildChildSet(childList, index.getCompare());
                }
                else {
                    // No change, this remains a fallback
                    return fallbackObject;
                }
            }
            else {
                var existingSnap = existingChildren.get(namedNode.name);
                var newChildren = indexedChildren;
                if (existingSnap) {
                    newChildren = newChildren.remove(new NamedNode(namedNode.name, existingSnap));
                }
                return newChildren.insert(namedNode, namedNode.node);
            }
        });
        return new IndexMap(newIndexes, this.indexSet_);
    };
    /**
     * Create a new IndexMap instance with the given value removed
     */
    IndexMap.prototype.removeFromIndexes = function (namedNode, existingChildren) {
        var newIndexes = map(this.indexes_, function (indexedChildren) {
            if (indexedChildren === fallbackObject) {
                // This is the fallback. Just return it, nothing to do in this case
                return indexedChildren;
            }
            else {
                var existingSnap = existingChildren.get(namedNode.name);
                if (existingSnap) {
                    return indexedChildren.remove(new NamedNode(namedNode.name, existingSnap));
                }
                else {
                    // No record of this child
                    return indexedChildren;
                }
            }
        });
        return new IndexMap(newIndexes, this.indexSet_);
    };
    return IndexMap;
}());

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// TODO: For memory savings, don't store priorityNode_ if it's empty.
var EMPTY_NODE;
/**
 * ChildrenNode is a class for storing internal nodes in a DataSnapshot
 * (i.e. nodes with children).  It implements Node and stores the
 * list of children in the children property, sorted by child name.
 */
var ChildrenNode = /** @class */ (function () {
    /**
     * @param children_ - List of children of this node..
     * @param priorityNode_ - The priority of this node (as a snapshot node).
     */
    function ChildrenNode(children_, priorityNode_, indexMap_) {
        this.children_ = children_;
        this.priorityNode_ = priorityNode_;
        this.indexMap_ = indexMap_;
        this.lazyHash_ = null;
        /**
         * Note: The only reason we allow null priority is for EMPTY_NODE, since we can't use
         * EMPTY_NODE as the priority of EMPTY_NODE.  We might want to consider making EMPTY_NODE its own
         * class instead of an empty ChildrenNode.
         */
        if (this.priorityNode_) {
            validatePriorityNode(this.priorityNode_);
        }
        if (this.children_.isEmpty()) {
            assert(!this.priorityNode_ || this.priorityNode_.isEmpty(), 'An empty node cannot have a priority');
        }
    }
    Object.defineProperty(ChildrenNode, "EMPTY_NODE", {
        get: function () {
            return (EMPTY_NODE ||
                (EMPTY_NODE = new ChildrenNode(new SortedMap(NAME_COMPARATOR), null, IndexMap.Default)));
        },
        enumerable: false,
        configurable: true
    });
    /** @inheritDoc */
    ChildrenNode.prototype.isLeafNode = function () {
        return false;
    };
    /** @inheritDoc */
    ChildrenNode.prototype.getPriority = function () {
        return this.priorityNode_ || EMPTY_NODE;
    };
    /** @inheritDoc */
    ChildrenNode.prototype.updatePriority = function (newPriorityNode) {
        if (this.children_.isEmpty()) {
            // Don't allow priorities on empty nodes
            return this;
        }
        else {
            return new ChildrenNode(this.children_, newPriorityNode, this.indexMap_);
        }
    };
    /** @inheritDoc */
    ChildrenNode.prototype.getImmediateChild = function (childName) {
        // Hack to treat priority as a regular child
        if (childName === '.priority') {
            return this.getPriority();
        }
        else {
            var child = this.children_.get(childName);
            return child === null ? EMPTY_NODE : child;
        }
    };
    /** @inheritDoc */
    ChildrenNode.prototype.getChild = function (path) {
        var front = pathGetFront(path);
        if (front === null) {
            return this;
        }
        return this.getImmediateChild(front).getChild(pathPopFront(path));
    };
    /** @inheritDoc */
    ChildrenNode.prototype.hasChild = function (childName) {
        return this.children_.get(childName) !== null;
    };
    /** @inheritDoc */
    ChildrenNode.prototype.updateImmediateChild = function (childName, newChildNode) {
        assert(newChildNode, 'We should always be passing snapshot nodes');
        if (childName === '.priority') {
            return this.updatePriority(newChildNode);
        }
        else {
            var namedNode = new NamedNode(childName, newChildNode);
            var newChildren = void 0, newIndexMap = void 0;
            if (newChildNode.isEmpty()) {
                newChildren = this.children_.remove(childName);
                newIndexMap = this.indexMap_.removeFromIndexes(namedNode, this.children_);
            }
            else {
                newChildren = this.children_.insert(childName, newChildNode);
                newIndexMap = this.indexMap_.addToIndexes(namedNode, this.children_);
            }
            var newPriority = newChildren.isEmpty()
                ? EMPTY_NODE
                : this.priorityNode_;
            return new ChildrenNode(newChildren, newPriority, newIndexMap);
        }
    };
    /** @inheritDoc */
    ChildrenNode.prototype.updateChild = function (path, newChildNode) {
        var front = pathGetFront(path);
        if (front === null) {
            return newChildNode;
        }
        else {
            assert(pathGetFront(path) !== '.priority' || pathGetLength(path) === 1, '.priority must be the last token in a path');
            var newImmediateChild = this.getImmediateChild(front).updateChild(pathPopFront(path), newChildNode);
            return this.updateImmediateChild(front, newImmediateChild);
        }
    };
    /** @inheritDoc */
    ChildrenNode.prototype.isEmpty = function () {
        return this.children_.isEmpty();
    };
    /** @inheritDoc */
    ChildrenNode.prototype.numChildren = function () {
        return this.children_.count();
    };
    /** @inheritDoc */
    ChildrenNode.prototype.val = function (exportFormat) {
        if (this.isEmpty()) {
            return null;
        }
        var obj = {};
        var numKeys = 0, maxKey = 0, allIntegerKeys = true;
        this.forEachChild(PRIORITY_INDEX, function (key, childNode) {
            obj[key] = childNode.val(exportFormat);
            numKeys++;
            if (allIntegerKeys && ChildrenNode.INTEGER_REGEXP_.test(key)) {
                maxKey = Math.max(maxKey, Number(key));
            }
            else {
                allIntegerKeys = false;
            }
        });
        if (!exportFormat && allIntegerKeys && maxKey < 2 * numKeys) {
            // convert to array.
            var array = [];
            // eslint-disable-next-line guard-for-in
            for (var key in obj) {
                array[key] = obj[key];
            }
            return array;
        }
        else {
            if (exportFormat && !this.getPriority().isEmpty()) {
                obj['.priority'] = this.getPriority().val();
            }
            return obj;
        }
    };
    /** @inheritDoc */
    ChildrenNode.prototype.hash = function () {
        if (this.lazyHash_ === null) {
            var toHash_1 = '';
            if (!this.getPriority().isEmpty()) {
                toHash_1 +=
                    'priority:' +
                        priorityHashText(this.getPriority().val()) +
                        ':';
            }
            this.forEachChild(PRIORITY_INDEX, function (key, childNode) {
                var childHash = childNode.hash();
                if (childHash !== '') {
                    toHash_1 += ':' + key + ':' + childHash;
                }
            });
            this.lazyHash_ = toHash_1 === '' ? '' : sha1(toHash_1);
        }
        return this.lazyHash_;
    };
    /** @inheritDoc */
    ChildrenNode.prototype.getPredecessorChildName = function (childName, childNode, index) {
        var idx = this.resolveIndex_(index);
        if (idx) {
            var predecessor = idx.getPredecessorKey(new NamedNode(childName, childNode));
            return predecessor ? predecessor.name : null;
        }
        else {
            return this.children_.getPredecessorKey(childName);
        }
    };
    ChildrenNode.prototype.getFirstChildName = function (indexDefinition) {
        var idx = this.resolveIndex_(indexDefinition);
        if (idx) {
            var minKey = idx.minKey();
            return minKey && minKey.name;
        }
        else {
            return this.children_.minKey();
        }
    };
    ChildrenNode.prototype.getFirstChild = function (indexDefinition) {
        var minKey = this.getFirstChildName(indexDefinition);
        if (minKey) {
            return new NamedNode(minKey, this.children_.get(minKey));
        }
        else {
            return null;
        }
    };
    /**
     * Given an index, return the key name of the largest value we have, according to that index
     */
    ChildrenNode.prototype.getLastChildName = function (indexDefinition) {
        var idx = this.resolveIndex_(indexDefinition);
        if (idx) {
            var maxKey = idx.maxKey();
            return maxKey && maxKey.name;
        }
        else {
            return this.children_.maxKey();
        }
    };
    ChildrenNode.prototype.getLastChild = function (indexDefinition) {
        var maxKey = this.getLastChildName(indexDefinition);
        if (maxKey) {
            return new NamedNode(maxKey, this.children_.get(maxKey));
        }
        else {
            return null;
        }
    };
    ChildrenNode.prototype.forEachChild = function (index, action) {
        var idx = this.resolveIndex_(index);
        if (idx) {
            return idx.inorderTraversal(function (wrappedNode) {
                return action(wrappedNode.name, wrappedNode.node);
            });
        }
        else {
            return this.children_.inorderTraversal(action);
        }
    };
    ChildrenNode.prototype.getIterator = function (indexDefinition) {
        return this.getIteratorFrom(indexDefinition.minPost(), indexDefinition);
    };
    ChildrenNode.prototype.getIteratorFrom = function (startPost, indexDefinition) {
        var idx = this.resolveIndex_(indexDefinition);
        if (idx) {
            return idx.getIteratorFrom(startPost, function (key) { return key; });
        }
        else {
            var iterator = this.children_.getIteratorFrom(startPost.name, NamedNode.Wrap);
            var next = iterator.peek();
            while (next != null && indexDefinition.compare(next, startPost) < 0) {
                iterator.getNext();
                next = iterator.peek();
            }
            return iterator;
        }
    };
    ChildrenNode.prototype.getReverseIterator = function (indexDefinition) {
        return this.getReverseIteratorFrom(indexDefinition.maxPost(), indexDefinition);
    };
    ChildrenNode.prototype.getReverseIteratorFrom = function (endPost, indexDefinition) {
        var idx = this.resolveIndex_(indexDefinition);
        if (idx) {
            return idx.getReverseIteratorFrom(endPost, function (key) {
                return key;
            });
        }
        else {
            var iterator = this.children_.getReverseIteratorFrom(endPost.name, NamedNode.Wrap);
            var next = iterator.peek();
            while (next != null && indexDefinition.compare(next, endPost) > 0) {
                iterator.getNext();
                next = iterator.peek();
            }
            return iterator;
        }
    };
    ChildrenNode.prototype.compareTo = function (other) {
        if (this.isEmpty()) {
            if (other.isEmpty()) {
                return 0;
            }
            else {
                return -1;
            }
        }
        else if (other.isLeafNode() || other.isEmpty()) {
            return 1;
        }
        else if (other === MAX_NODE) {
            return -1;
        }
        else {
            // Must be another node with children.
            return 0;
        }
    };
    ChildrenNode.prototype.withIndex = function (indexDefinition) {
        if (indexDefinition === KEY_INDEX ||
            this.indexMap_.hasIndex(indexDefinition)) {
            return this;
        }
        else {
            var newIndexMap = this.indexMap_.addIndex(indexDefinition, this.children_);
            return new ChildrenNode(this.children_, this.priorityNode_, newIndexMap);
        }
    };
    ChildrenNode.prototype.isIndexed = function (index) {
        return index === KEY_INDEX || this.indexMap_.hasIndex(index);
    };
    ChildrenNode.prototype.equals = function (other) {
        if (other === this) {
            return true;
        }
        else if (other.isLeafNode()) {
            return false;
        }
        else {
            var otherChildrenNode = other;
            if (!this.getPriority().equals(otherChildrenNode.getPriority())) {
                return false;
            }
            else if (this.children_.count() === otherChildrenNode.children_.count()) {
                var thisIter = this.getIterator(PRIORITY_INDEX);
                var otherIter = otherChildrenNode.getIterator(PRIORITY_INDEX);
                var thisCurrent = thisIter.getNext();
                var otherCurrent = otherIter.getNext();
                while (thisCurrent && otherCurrent) {
                    if (thisCurrent.name !== otherCurrent.name ||
                        !thisCurrent.node.equals(otherCurrent.node)) {
                        return false;
                    }
                    thisCurrent = thisIter.getNext();
                    otherCurrent = otherIter.getNext();
                }
                return thisCurrent === null && otherCurrent === null;
            }
            else {
                return false;
            }
        }
    };
    /**
     * Returns a SortedMap ordered by index, or null if the default (by-key) ordering can be used
     * instead.
     *
     */
    ChildrenNode.prototype.resolveIndex_ = function (indexDefinition) {
        if (indexDefinition === KEY_INDEX) {
            return null;
        }
        else {
            return this.indexMap_.get(indexDefinition.toString());
        }
    };
    ChildrenNode.INTEGER_REGEXP_ = /^(0|[1-9]\d*)$/;
    return ChildrenNode;
}());
var MaxNode = /** @class */ (function (_super) {
    __extends(MaxNode, _super);
    function MaxNode() {
        return _super.call(this, new SortedMap(NAME_COMPARATOR), ChildrenNode.EMPTY_NODE, IndexMap.Default) || this;
    }
    MaxNode.prototype.compareTo = function (other) {
        if (other === this) {
            return 0;
        }
        else {
            return 1;
        }
    };
    MaxNode.prototype.equals = function (other) {
        // Not that we every compare it, but MAX_NODE is only ever equal to itself
        return other === this;
    };
    MaxNode.prototype.getPriority = function () {
        return this;
    };
    MaxNode.prototype.getImmediateChild = function (childName) {
        return ChildrenNode.EMPTY_NODE;
    };
    MaxNode.prototype.isEmpty = function () {
        return false;
    };
    return MaxNode;
}(ChildrenNode));
/**
 * Marker that will sort higher than any other snapshot.
 */
var MAX_NODE = new MaxNode();
Object.defineProperties(NamedNode, {
    MIN: {
        value: new NamedNode(MIN_NAME, ChildrenNode.EMPTY_NODE)
    },
    MAX: {
        value: new NamedNode(MAX_NAME, MAX_NODE)
    }
});
/**
 * Reference Extensions
 */
KeyIndex.__EMPTY_NODE = ChildrenNode.EMPTY_NODE;
LeafNode.__childrenNodeConstructor = ChildrenNode;
setMaxNode$1(MAX_NODE);
setMaxNode(MAX_NODE);

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var USE_HINZE = true;
/**
 * Constructs a snapshot node representing the passed JSON and returns it.
 * @param json - JSON to create a node for.
 * @param priority - Optional priority to use.  This will be ignored if the
 * passed JSON contains a .priority property.
 */
function nodeFromJSON(json, priority) {
    if (priority === void 0) { priority = null; }
    if (json === null) {
        return ChildrenNode.EMPTY_NODE;
    }
    if (typeof json === 'object' && '.priority' in json) {
        priority = json['.priority'];
    }
    assert(priority === null ||
        typeof priority === 'string' ||
        typeof priority === 'number' ||
        (typeof priority === 'object' && '.sv' in priority), 'Invalid priority type found: ' + typeof priority);
    if (typeof json === 'object' && '.value' in json && json['.value'] !== null) {
        json = json['.value'];
    }
    // Valid leaf nodes include non-objects or server-value wrapper objects
    if (typeof json !== 'object' || '.sv' in json) {
        var jsonLeaf = json;
        return new LeafNode(jsonLeaf, nodeFromJSON(priority));
    }
    if (!(json instanceof Array) && USE_HINZE) {
        var children_1 = [];
        var childrenHavePriority_1 = false;
        var hinzeJsonObj = json;
        each(hinzeJsonObj, function (key, child) {
            if (key.substring(0, 1) !== '.') {
                // Ignore metadata nodes
                var childNode = nodeFromJSON(child);
                if (!childNode.isEmpty()) {
                    childrenHavePriority_1 =
                        childrenHavePriority_1 || !childNode.getPriority().isEmpty();
                    children_1.push(new NamedNode(key, childNode));
                }
            }
        });
        if (children_1.length === 0) {
            return ChildrenNode.EMPTY_NODE;
        }
        var childSet = buildChildSet(children_1, NAME_ONLY_COMPARATOR, function (namedNode) { return namedNode.name; }, NAME_COMPARATOR);
        if (childrenHavePriority_1) {
            var sortedChildSet = buildChildSet(children_1, PRIORITY_INDEX.getCompare());
            return new ChildrenNode(childSet, nodeFromJSON(priority), new IndexMap({ '.priority': sortedChildSet }, { '.priority': PRIORITY_INDEX }));
        }
        else {
            return new ChildrenNode(childSet, nodeFromJSON(priority), IndexMap.Default);
        }
    }
    else {
        var node_1 = ChildrenNode.EMPTY_NODE;
        each(json, function (key, childData) {
            if (contains(json, key)) {
                if (key.substring(0, 1) !== '.') {
                    // ignore metadata nodes.
                    var childNode = nodeFromJSON(childData);
                    if (childNode.isLeafNode() || !childNode.isEmpty()) {
                        node_1 = node_1.updateImmediateChild(key, childNode);
                    }
                }
            }
        });
        return node_1.updatePriority(nodeFromJSON(priority));
    }
}
setNodeFromJSON(nodeFromJSON);

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var PathIndex = /** @class */ (function (_super) {
    __extends(PathIndex, _super);
    function PathIndex(indexPath_) {
        var _this = _super.call(this) || this;
        _this.indexPath_ = indexPath_;
        assert(!pathIsEmpty(indexPath_) && pathGetFront(indexPath_) !== '.priority', "Can't create PathIndex with empty path or .priority key");
        return _this;
    }
    PathIndex.prototype.extractChild = function (snap) {
        return snap.getChild(this.indexPath_);
    };
    PathIndex.prototype.isDefinedOn = function (node) {
        return !node.getChild(this.indexPath_).isEmpty();
    };
    PathIndex.prototype.compare = function (a, b) {
        var aChild = this.extractChild(a.node);
        var bChild = this.extractChild(b.node);
        var indexCmp = aChild.compareTo(bChild);
        if (indexCmp === 0) {
            return nameCompare(a.name, b.name);
        }
        else {
            return indexCmp;
        }
    };
    PathIndex.prototype.makePost = function (indexValue, name) {
        var valueNode = nodeFromJSON(indexValue);
        var node = ChildrenNode.EMPTY_NODE.updateChild(this.indexPath_, valueNode);
        return new NamedNode(name, node);
    };
    PathIndex.prototype.maxPost = function () {
        var node = ChildrenNode.EMPTY_NODE.updateChild(this.indexPath_, MAX_NODE);
        return new NamedNode(MAX_NAME, node);
    };
    PathIndex.prototype.toString = function () {
        return pathSlice(this.indexPath_, 0).join('/');
    };
    return PathIndex;
}(Index));

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var ValueIndex = /** @class */ (function (_super) {
    __extends(ValueIndex, _super);
    function ValueIndex() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ValueIndex.prototype.compare = function (a, b) {
        var indexCmp = a.node.compareTo(b.node);
        if (indexCmp === 0) {
            return nameCompare(a.name, b.name);
        }
        else {
            return indexCmp;
        }
    };
    ValueIndex.prototype.isDefinedOn = function (node) {
        return true;
    };
    ValueIndex.prototype.indexedValueChanged = function (oldNode, newNode) {
        return !oldNode.equals(newNode);
    };
    ValueIndex.prototype.minPost = function () {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        return NamedNode.MIN;
    };
    ValueIndex.prototype.maxPost = function () {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        return NamedNode.MAX;
    };
    ValueIndex.prototype.makePost = function (indexValue, name) {
        var valueNode = nodeFromJSON(indexValue);
        return new NamedNode(name, valueNode);
    };
    /**
     * @returns String representation for inclusion in a query spec
     */
    ValueIndex.prototype.toString = function () {
        return '.value';
    };
    return ValueIndex;
}(Index));
var VALUE_INDEX = new ValueIndex();

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function changeValue(snapshotNode) {
    return { type: "value" /* ChangeType.VALUE */, snapshotNode: snapshotNode };
}
function changeChildAdded(childName, snapshotNode) {
    return { type: "child_added" /* ChangeType.CHILD_ADDED */, snapshotNode: snapshotNode, childName: childName };
}
function changeChildRemoved(childName, snapshotNode) {
    return { type: "child_removed" /* ChangeType.CHILD_REMOVED */, snapshotNode: snapshotNode, childName: childName };
}
function changeChildChanged(childName, snapshotNode, oldSnap) {
    return {
        type: "child_changed" /* ChangeType.CHILD_CHANGED */,
        snapshotNode: snapshotNode,
        childName: childName,
        oldSnap: oldSnap
    };
}
function changeChildMoved(childName, snapshotNode) {
    return { type: "child_moved" /* ChangeType.CHILD_MOVED */, snapshotNode: snapshotNode, childName: childName };
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Doesn't really filter nodes but applies an index to the node and keeps track of any changes
 */
var IndexedFilter = /** @class */ (function () {
    function IndexedFilter(index_) {
        this.index_ = index_;
    }
    IndexedFilter.prototype.updateChild = function (snap, key, newChild, affectedPath, source, optChangeAccumulator) {
        assert(snap.isIndexed(this.index_), 'A node must be indexed if only a child is updated');
        var oldChild = snap.getImmediateChild(key);
        // Check if anything actually changed.
        if (oldChild.getChild(affectedPath).equals(newChild.getChild(affectedPath))) {
            // There's an edge case where a child can enter or leave the view because affectedPath was set to null.
            // In this case, affectedPath will appear null in both the old and new snapshots.  So we need
            // to avoid treating these cases as "nothing changed."
            if (oldChild.isEmpty() === newChild.isEmpty()) {
                // Nothing changed.
                // This assert should be valid, but it's expensive (can dominate perf testing) so don't actually do it.
                //assert(oldChild.equals(newChild), 'Old and new snapshots should be equal.');
                return snap;
            }
        }
        if (optChangeAccumulator != null) {
            if (newChild.isEmpty()) {
                if (snap.hasChild(key)) {
                    optChangeAccumulator.trackChildChange(changeChildRemoved(key, oldChild));
                }
                else {
                    assert(snap.isLeafNode(), 'A child remove without an old child only makes sense on a leaf node');
                }
            }
            else if (oldChild.isEmpty()) {
                optChangeAccumulator.trackChildChange(changeChildAdded(key, newChild));
            }
            else {
                optChangeAccumulator.trackChildChange(changeChildChanged(key, newChild, oldChild));
            }
        }
        if (snap.isLeafNode() && newChild.isEmpty()) {
            return snap;
        }
        else {
            // Make sure the node is indexed
            return snap.updateImmediateChild(key, newChild).withIndex(this.index_);
        }
    };
    IndexedFilter.prototype.updateFullNode = function (oldSnap, newSnap, optChangeAccumulator) {
        if (optChangeAccumulator != null) {
            if (!oldSnap.isLeafNode()) {
                oldSnap.forEachChild(PRIORITY_INDEX, function (key, childNode) {
                    if (!newSnap.hasChild(key)) {
                        optChangeAccumulator.trackChildChange(changeChildRemoved(key, childNode));
                    }
                });
            }
            if (!newSnap.isLeafNode()) {
                newSnap.forEachChild(PRIORITY_INDEX, function (key, childNode) {
                    if (oldSnap.hasChild(key)) {
                        var oldChild = oldSnap.getImmediateChild(key);
                        if (!oldChild.equals(childNode)) {
                            optChangeAccumulator.trackChildChange(changeChildChanged(key, childNode, oldChild));
                        }
                    }
                    else {
                        optChangeAccumulator.trackChildChange(changeChildAdded(key, childNode));
                    }
                });
            }
        }
        return newSnap.withIndex(this.index_);
    };
    IndexedFilter.prototype.updatePriority = function (oldSnap, newPriority) {
        if (oldSnap.isEmpty()) {
            return ChildrenNode.EMPTY_NODE;
        }
        else {
            return oldSnap.updatePriority(newPriority);
        }
    };
    IndexedFilter.prototype.filtersNodes = function () {
        return false;
    };
    IndexedFilter.prototype.getIndexedFilter = function () {
        return this;
    };
    IndexedFilter.prototype.getIndex = function () {
        return this.index_;
    };
    return IndexedFilter;
}());

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Filters nodes by range and uses an IndexFilter to track any changes after filtering the node
 */
var RangedFilter = /** @class */ (function () {
    function RangedFilter(params) {
        this.indexedFilter_ = new IndexedFilter(params.getIndex());
        this.index_ = params.getIndex();
        this.startPost_ = RangedFilter.getStartPost_(params);
        this.endPost_ = RangedFilter.getEndPost_(params);
        this.startIsInclusive_ = !params.startAfterSet_;
        this.endIsInclusive_ = !params.endBeforeSet_;
    }
    RangedFilter.prototype.getStartPost = function () {
        return this.startPost_;
    };
    RangedFilter.prototype.getEndPost = function () {
        return this.endPost_;
    };
    RangedFilter.prototype.matches = function (node) {
        var isWithinStart = this.startIsInclusive_
            ? this.index_.compare(this.getStartPost(), node) <= 0
            : this.index_.compare(this.getStartPost(), node) < 0;
        var isWithinEnd = this.endIsInclusive_
            ? this.index_.compare(node, this.getEndPost()) <= 0
            : this.index_.compare(node, this.getEndPost()) < 0;
        return isWithinStart && isWithinEnd;
    };
    RangedFilter.prototype.updateChild = function (snap, key, newChild, affectedPath, source, optChangeAccumulator) {
        if (!this.matches(new NamedNode(key, newChild))) {
            newChild = ChildrenNode.EMPTY_NODE;
        }
        return this.indexedFilter_.updateChild(snap, key, newChild, affectedPath, source, optChangeAccumulator);
    };
    RangedFilter.prototype.updateFullNode = function (oldSnap, newSnap, optChangeAccumulator) {
        if (newSnap.isLeafNode()) {
            // Make sure we have a children node with the correct index, not a leaf node;
            newSnap = ChildrenNode.EMPTY_NODE;
        }
        var filtered = newSnap.withIndex(this.index_);
        // Don't support priorities on queries
        filtered = filtered.updatePriority(ChildrenNode.EMPTY_NODE);
        var self = this;
        newSnap.forEachChild(PRIORITY_INDEX, function (key, childNode) {
            if (!self.matches(new NamedNode(key, childNode))) {
                filtered = filtered.updateImmediateChild(key, ChildrenNode.EMPTY_NODE);
            }
        });
        return this.indexedFilter_.updateFullNode(oldSnap, filtered, optChangeAccumulator);
    };
    RangedFilter.prototype.updatePriority = function (oldSnap, newPriority) {
        // Don't support priorities on queries
        return oldSnap;
    };
    RangedFilter.prototype.filtersNodes = function () {
        return true;
    };
    RangedFilter.prototype.getIndexedFilter = function () {
        return this.indexedFilter_;
    };
    RangedFilter.prototype.getIndex = function () {
        return this.index_;
    };
    RangedFilter.getStartPost_ = function (params) {
        if (params.hasStart()) {
            var startName = params.getIndexStartName();
            return params.getIndex().makePost(params.getIndexStartValue(), startName);
        }
        else {
            return params.getIndex().minPost();
        }
    };
    RangedFilter.getEndPost_ = function (params) {
        if (params.hasEnd()) {
            var endName = params.getIndexEndName();
            return params.getIndex().makePost(params.getIndexEndValue(), endName);
        }
        else {
            return params.getIndex().maxPost();
        }
    };
    return RangedFilter;
}());

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Applies a limit and a range to a node and uses RangedFilter to do the heavy lifting where possible
 */
var LimitedFilter = /** @class */ (function () {
    function LimitedFilter(params) {
        var _this = this;
        this.withinDirectionalStart = function (node) {
            return _this.reverse_ ? _this.withinEndPost(node) : _this.withinStartPost(node);
        };
        this.withinDirectionalEnd = function (node) {
            return _this.reverse_ ? _this.withinStartPost(node) : _this.withinEndPost(node);
        };
        this.withinStartPost = function (node) {
            var compareRes = _this.index_.compare(_this.rangedFilter_.getStartPost(), node);
            return _this.startIsInclusive_ ? compareRes <= 0 : compareRes < 0;
        };
        this.withinEndPost = function (node) {
            var compareRes = _this.index_.compare(node, _this.rangedFilter_.getEndPost());
            return _this.endIsInclusive_ ? compareRes <= 0 : compareRes < 0;
        };
        this.rangedFilter_ = new RangedFilter(params);
        this.index_ = params.getIndex();
        this.limit_ = params.getLimit();
        this.reverse_ = !params.isViewFromLeft();
        this.startIsInclusive_ = !params.startAfterSet_;
        this.endIsInclusive_ = !params.endBeforeSet_;
    }
    LimitedFilter.prototype.updateChild = function (snap, key, newChild, affectedPath, source, optChangeAccumulator) {
        if (!this.rangedFilter_.matches(new NamedNode(key, newChild))) {
            newChild = ChildrenNode.EMPTY_NODE;
        }
        if (snap.getImmediateChild(key).equals(newChild)) {
            // No change
            return snap;
        }
        else if (snap.numChildren() < this.limit_) {
            return this.rangedFilter_
                .getIndexedFilter()
                .updateChild(snap, key, newChild, affectedPath, source, optChangeAccumulator);
        }
        else {
            return this.fullLimitUpdateChild_(snap, key, newChild, source, optChangeAccumulator);
        }
    };
    LimitedFilter.prototype.updateFullNode = function (oldSnap, newSnap, optChangeAccumulator) {
        var filtered;
        if (newSnap.isLeafNode() || newSnap.isEmpty()) {
            // Make sure we have a children node with the correct index, not a leaf node;
            filtered = ChildrenNode.EMPTY_NODE.withIndex(this.index_);
        }
        else {
            if (this.limit_ * 2 < newSnap.numChildren() &&
                newSnap.isIndexed(this.index_)) {
                // Easier to build up a snapshot, since what we're given has more than twice the elements we want
                filtered = ChildrenNode.EMPTY_NODE.withIndex(this.index_);
                // anchor to the startPost, endPost, or last element as appropriate
                var iterator = void 0;
                if (this.reverse_) {
                    iterator = newSnap.getReverseIteratorFrom(this.rangedFilter_.getEndPost(), this.index_);
                }
                else {
                    iterator = newSnap.getIteratorFrom(this.rangedFilter_.getStartPost(), this.index_);
                }
                var count = 0;
                while (iterator.hasNext() && count < this.limit_) {
                    var next = iterator.getNext();
                    if (!this.withinDirectionalStart(next)) {
                        // if we have not reached the start, skip to the next element
                        continue;
                    }
                    else if (!this.withinDirectionalEnd(next)) {
                        // if we have reached the end, stop adding elements
                        break;
                    }
                    else {
                        filtered = filtered.updateImmediateChild(next.name, next.node);
                        count++;
                    }
                }
            }
            else {
                // The snap contains less than twice the limit. Faster to delete from the snap than build up a new one
                filtered = newSnap.withIndex(this.index_);
                // Don't support priorities on queries
                filtered = filtered.updatePriority(ChildrenNode.EMPTY_NODE);
                var iterator = void 0;
                if (this.reverse_) {
                    iterator = filtered.getReverseIterator(this.index_);
                }
                else {
                    iterator = filtered.getIterator(this.index_);
                }
                var count = 0;
                while (iterator.hasNext()) {
                    var next = iterator.getNext();
                    var inRange = count < this.limit_ &&
                        this.withinDirectionalStart(next) &&
                        this.withinDirectionalEnd(next);
                    if (inRange) {
                        count++;
                    }
                    else {
                        filtered = filtered.updateImmediateChild(next.name, ChildrenNode.EMPTY_NODE);
                    }
                }
            }
        }
        return this.rangedFilter_
            .getIndexedFilter()
            .updateFullNode(oldSnap, filtered, optChangeAccumulator);
    };
    LimitedFilter.prototype.updatePriority = function (oldSnap, newPriority) {
        // Don't support priorities on queries
        return oldSnap;
    };
    LimitedFilter.prototype.filtersNodes = function () {
        return true;
    };
    LimitedFilter.prototype.getIndexedFilter = function () {
        return this.rangedFilter_.getIndexedFilter();
    };
    LimitedFilter.prototype.getIndex = function () {
        return this.index_;
    };
    LimitedFilter.prototype.fullLimitUpdateChild_ = function (snap, childKey, childSnap, source, changeAccumulator) {
        // TODO: rename all cache stuff etc to general snap terminology
        var cmp;
        if (this.reverse_) {
            var indexCmp_1 = this.index_.getCompare();
            cmp = function (a, b) { return indexCmp_1(b, a); };
        }
        else {
            cmp = this.index_.getCompare();
        }
        var oldEventCache = snap;
        assert(oldEventCache.numChildren() === this.limit_, '');
        var newChildNamedNode = new NamedNode(childKey, childSnap);
        var windowBoundary = this.reverse_
            ? oldEventCache.getFirstChild(this.index_)
            : oldEventCache.getLastChild(this.index_);
        var inRange = this.rangedFilter_.matches(newChildNamedNode);
        if (oldEventCache.hasChild(childKey)) {
            var oldChildSnap = oldEventCache.getImmediateChild(childKey);
            var nextChild = source.getChildAfterChild(this.index_, windowBoundary, this.reverse_);
            while (nextChild != null &&
                (nextChild.name === childKey || oldEventCache.hasChild(nextChild.name))) {
                // There is a weird edge case where a node is updated as part of a merge in the write tree, but hasn't
                // been applied to the limited filter yet. Ignore this next child which will be updated later in
                // the limited filter...
                nextChild = source.getChildAfterChild(this.index_, nextChild, this.reverse_);
            }
            var compareNext = nextChild == null ? 1 : cmp(nextChild, newChildNamedNode);
            var remainsInWindow = inRange && !childSnap.isEmpty() && compareNext >= 0;
            if (remainsInWindow) {
                if (changeAccumulator != null) {
                    changeAccumulator.trackChildChange(changeChildChanged(childKey, childSnap, oldChildSnap));
                }
                return oldEventCache.updateImmediateChild(childKey, childSnap);
            }
            else {
                if (changeAccumulator != null) {
                    changeAccumulator.trackChildChange(changeChildRemoved(childKey, oldChildSnap));
                }
                var newEventCache = oldEventCache.updateImmediateChild(childKey, ChildrenNode.EMPTY_NODE);
                var nextChildInRange = nextChild != null && this.rangedFilter_.matches(nextChild);
                if (nextChildInRange) {
                    if (changeAccumulator != null) {
                        changeAccumulator.trackChildChange(changeChildAdded(nextChild.name, nextChild.node));
                    }
                    return newEventCache.updateImmediateChild(nextChild.name, nextChild.node);
                }
                else {
                    return newEventCache;
                }
            }
        }
        else if (childSnap.isEmpty()) {
            // we're deleting a node, but it was not in the window, so ignore it
            return snap;
        }
        else if (inRange) {
            if (cmp(windowBoundary, newChildNamedNode) >= 0) {
                if (changeAccumulator != null) {
                    changeAccumulator.trackChildChange(changeChildRemoved(windowBoundary.name, windowBoundary.node));
                    changeAccumulator.trackChildChange(changeChildAdded(childKey, childSnap));
                }
                return oldEventCache
                    .updateImmediateChild(childKey, childSnap)
                    .updateImmediateChild(windowBoundary.name, ChildrenNode.EMPTY_NODE);
            }
            else {
                return snap;
            }
        }
        else {
            return snap;
        }
    };
    return LimitedFilter;
}());

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * This class is an immutable-from-the-public-api struct containing a set of query parameters defining a
 * range to be returned for a particular location. It is assumed that validation of parameters is done at the
 * user-facing API level, so it is not done here.
 *
 * @internal
 */
var QueryParams = /** @class */ (function () {
    function QueryParams() {
        this.limitSet_ = false;
        this.startSet_ = false;
        this.startNameSet_ = false;
        this.startAfterSet_ = false; // can only be true if startSet_ is true
        this.endSet_ = false;
        this.endNameSet_ = false;
        this.endBeforeSet_ = false; // can only be true if endSet_ is true
        this.limit_ = 0;
        this.viewFrom_ = '';
        this.indexStartValue_ = null;
        this.indexStartName_ = '';
        this.indexEndValue_ = null;
        this.indexEndName_ = '';
        this.index_ = PRIORITY_INDEX;
    }
    QueryParams.prototype.hasStart = function () {
        return this.startSet_;
    };
    /**
     * @returns True if it would return from left.
     */
    QueryParams.prototype.isViewFromLeft = function () {
        if (this.viewFrom_ === '') {
            // limit(), rather than limitToFirst or limitToLast was called.
            // This means that only one of startSet_ and endSet_ is true. Use them
            // to calculate which side of the view to anchor to. If neither is set,
            // anchor to the end.
            return this.startSet_;
        }
        else {
            return this.viewFrom_ === "l" /* WIRE_PROTOCOL_CONSTANTS.VIEW_FROM_LEFT */;
        }
    };
    /**
     * Only valid to call if hasStart() returns true
     */
    QueryParams.prototype.getIndexStartValue = function () {
        assert(this.startSet_, 'Only valid if start has been set');
        return this.indexStartValue_;
    };
    /**
     * Only valid to call if hasStart() returns true.
     * Returns the starting key name for the range defined by these query parameters
     */
    QueryParams.prototype.getIndexStartName = function () {
        assert(this.startSet_, 'Only valid if start has been set');
        if (this.startNameSet_) {
            return this.indexStartName_;
        }
        else {
            return MIN_NAME;
        }
    };
    QueryParams.prototype.hasEnd = function () {
        return this.endSet_;
    };
    /**
     * Only valid to call if hasEnd() returns true.
     */
    QueryParams.prototype.getIndexEndValue = function () {
        assert(this.endSet_, 'Only valid if end has been set');
        return this.indexEndValue_;
    };
    /**
     * Only valid to call if hasEnd() returns true.
     * Returns the end key name for the range defined by these query parameters
     */
    QueryParams.prototype.getIndexEndName = function () {
        assert(this.endSet_, 'Only valid if end has been set');
        if (this.endNameSet_) {
            return this.indexEndName_;
        }
        else {
            return MAX_NAME;
        }
    };
    QueryParams.prototype.hasLimit = function () {
        return this.limitSet_;
    };
    /**
     * @returns True if a limit has been set and it has been explicitly anchored
     */
    QueryParams.prototype.hasAnchoredLimit = function () {
        return this.limitSet_ && this.viewFrom_ !== '';
    };
    /**
     * Only valid to call if hasLimit() returns true
     */
    QueryParams.prototype.getLimit = function () {
        assert(this.limitSet_, 'Only valid if limit has been set');
        return this.limit_;
    };
    QueryParams.prototype.getIndex = function () {
        return this.index_;
    };
    QueryParams.prototype.loadsAllData = function () {
        return !(this.startSet_ || this.endSet_ || this.limitSet_);
    };
    QueryParams.prototype.isDefault = function () {
        return this.loadsAllData() && this.index_ === PRIORITY_INDEX;
    };
    QueryParams.prototype.copy = function () {
        var copy = new QueryParams();
        copy.limitSet_ = this.limitSet_;
        copy.limit_ = this.limit_;
        copy.startSet_ = this.startSet_;
        copy.startAfterSet_ = this.startAfterSet_;
        copy.indexStartValue_ = this.indexStartValue_;
        copy.startNameSet_ = this.startNameSet_;
        copy.indexStartName_ = this.indexStartName_;
        copy.endSet_ = this.endSet_;
        copy.endBeforeSet_ = this.endBeforeSet_;
        copy.indexEndValue_ = this.indexEndValue_;
        copy.endNameSet_ = this.endNameSet_;
        copy.indexEndName_ = this.indexEndName_;
        copy.index_ = this.index_;
        copy.viewFrom_ = this.viewFrom_;
        return copy;
    };
    return QueryParams;
}());
function queryParamsGetNodeFilter(queryParams) {
    if (queryParams.loadsAllData()) {
        return new IndexedFilter(queryParams.getIndex());
    }
    else if (queryParams.hasLimit()) {
        return new LimitedFilter(queryParams);
    }
    else {
        return new RangedFilter(queryParams);
    }
}
function queryParamsLimitToFirst(queryParams, newLimit) {
    var newParams = queryParams.copy();
    newParams.limitSet_ = true;
    newParams.limit_ = newLimit;
    newParams.viewFrom_ = "l" /* WIRE_PROTOCOL_CONSTANTS.VIEW_FROM_LEFT */;
    return newParams;
}
function queryParamsLimitToLast(queryParams, newLimit) {
    var newParams = queryParams.copy();
    newParams.limitSet_ = true;
    newParams.limit_ = newLimit;
    newParams.viewFrom_ = "r" /* WIRE_PROTOCOL_CONSTANTS.VIEW_FROM_RIGHT */;
    return newParams;
}
function queryParamsStartAt(queryParams, indexValue, key) {
    var newParams = queryParams.copy();
    newParams.startSet_ = true;
    if (indexValue === undefined) {
        indexValue = null;
    }
    newParams.indexStartValue_ = indexValue;
    if (key != null) {
        newParams.startNameSet_ = true;
        newParams.indexStartName_ = key;
    }
    else {
        newParams.startNameSet_ = false;
        newParams.indexStartName_ = '';
    }
    return newParams;
}
function queryParamsStartAfter(queryParams, indexValue, key) {
    var params;
    if (queryParams.index_ === KEY_INDEX || !!key) {
        params = queryParamsStartAt(queryParams, indexValue, key);
    }
    else {
        params = queryParamsStartAt(queryParams, indexValue, MAX_NAME);
    }
    params.startAfterSet_ = true;
    return params;
}
function queryParamsEndAt(queryParams, indexValue, key) {
    var newParams = queryParams.copy();
    newParams.endSet_ = true;
    if (indexValue === undefined) {
        indexValue = null;
    }
    newParams.indexEndValue_ = indexValue;
    if (key !== undefined) {
        newParams.endNameSet_ = true;
        newParams.indexEndName_ = key;
    }
    else {
        newParams.endNameSet_ = false;
        newParams.indexEndName_ = '';
    }
    return newParams;
}
function queryParamsEndBefore(queryParams, indexValue, key) {
    var params;
    if (queryParams.index_ === KEY_INDEX || !!key) {
        params = queryParamsEndAt(queryParams, indexValue, key);
    }
    else {
        params = queryParamsEndAt(queryParams, indexValue, MIN_NAME);
    }
    params.endBeforeSet_ = true;
    return params;
}
function queryParamsOrderBy(queryParams, index) {
    var newParams = queryParams.copy();
    newParams.index_ = index;
    return newParams;
}
/**
 * Returns a set of REST query string parameters representing this query.
 *
 * @returns query string parameters
 */
function queryParamsToRestQueryStringParameters(queryParams) {
    var qs = {};
    if (queryParams.isDefault()) {
        return qs;
    }
    var orderBy;
    if (queryParams.index_ === PRIORITY_INDEX) {
        orderBy = "$priority" /* REST_QUERY_CONSTANTS.PRIORITY_INDEX */;
    }
    else if (queryParams.index_ === VALUE_INDEX) {
        orderBy = "$value" /* REST_QUERY_CONSTANTS.VALUE_INDEX */;
    }
    else if (queryParams.index_ === KEY_INDEX) {
        orderBy = "$key" /* REST_QUERY_CONSTANTS.KEY_INDEX */;
    }
    else {
        assert(queryParams.index_ instanceof PathIndex, 'Unrecognized index type!');
        orderBy = queryParams.index_.toString();
    }
    qs["orderBy" /* REST_QUERY_CONSTANTS.ORDER_BY */] = stringify(orderBy);
    if (queryParams.startSet_) {
        var startParam = queryParams.startAfterSet_
            ? "startAfter" /* REST_QUERY_CONSTANTS.START_AFTER */
            : "startAt" /* REST_QUERY_CONSTANTS.START_AT */;
        qs[startParam] = stringify(queryParams.indexStartValue_);
        if (queryParams.startNameSet_) {
            qs[startParam] += ',' + stringify(queryParams.indexStartName_);
        }
    }
    if (queryParams.endSet_) {
        var endParam = queryParams.endBeforeSet_
            ? "endBefore" /* REST_QUERY_CONSTANTS.END_BEFORE */
            : "endAt" /* REST_QUERY_CONSTANTS.END_AT */;
        qs[endParam] = stringify(queryParams.indexEndValue_);
        if (queryParams.endNameSet_) {
            qs[endParam] += ',' + stringify(queryParams.indexEndName_);
        }
    }
    if (queryParams.limitSet_) {
        if (queryParams.isViewFromLeft()) {
            qs["limitToFirst" /* REST_QUERY_CONSTANTS.LIMIT_TO_FIRST */] = queryParams.limit_;
        }
        else {
            qs["limitToLast" /* REST_QUERY_CONSTANTS.LIMIT_TO_LAST */] = queryParams.limit_;
        }
    }
    return qs;
}
function queryParamsGetQueryObject(queryParams) {
    var obj = {};
    if (queryParams.startSet_) {
        obj["sp" /* WIRE_PROTOCOL_CONSTANTS.INDEX_START_VALUE */] =
            queryParams.indexStartValue_;
        if (queryParams.startNameSet_) {
            obj["sn" /* WIRE_PROTOCOL_CONSTANTS.INDEX_START_NAME */] =
                queryParams.indexStartName_;
        }
        obj["sin" /* WIRE_PROTOCOL_CONSTANTS.INDEX_START_IS_INCLUSIVE */] =
            !queryParams.startAfterSet_;
    }
    if (queryParams.endSet_) {
        obj["ep" /* WIRE_PROTOCOL_CONSTANTS.INDEX_END_VALUE */] = queryParams.indexEndValue_;
        if (queryParams.endNameSet_) {
            obj["en" /* WIRE_PROTOCOL_CONSTANTS.INDEX_END_NAME */] = queryParams.indexEndName_;
        }
        obj["ein" /* WIRE_PROTOCOL_CONSTANTS.INDEX_END_IS_INCLUSIVE */] =
            !queryParams.endBeforeSet_;
    }
    if (queryParams.limitSet_) {
        obj["l" /* WIRE_PROTOCOL_CONSTANTS.LIMIT */] = queryParams.limit_;
        var viewFrom = queryParams.viewFrom_;
        if (viewFrom === '') {
            if (queryParams.isViewFromLeft()) {
                viewFrom = "l" /* WIRE_PROTOCOL_CONSTANTS.VIEW_FROM_LEFT */;
            }
            else {
                viewFrom = "r" /* WIRE_PROTOCOL_CONSTANTS.VIEW_FROM_RIGHT */;
            }
        }
        obj["vf" /* WIRE_PROTOCOL_CONSTANTS.VIEW_FROM */] = viewFrom;
    }
    // For now, priority index is the default, so we only specify if it's some other index
    if (queryParams.index_ !== PRIORITY_INDEX) {
        obj["i" /* WIRE_PROTOCOL_CONSTANTS.INDEX */] = queryParams.index_.toString();
    }
    return obj;
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * An implementation of ServerActions that communicates with the server via REST requests.
 * This is mostly useful for compatibility with crawlers, where we don't want to spin up a full
 * persistent connection (using WebSockets or long-polling)
 */
var ReadonlyRestClient = /** @class */ (function (_super) {
    __extends(ReadonlyRestClient, _super);
    /**
     * @param repoInfo_ - Data about the namespace we are connecting to
     * @param onDataUpdate_ - A callback for new data from the server
     */
    function ReadonlyRestClient(repoInfo_, onDataUpdate_, authTokenProvider_, appCheckTokenProvider_) {
        var _this = _super.call(this) || this;
        _this.repoInfo_ = repoInfo_;
        _this.onDataUpdate_ = onDataUpdate_;
        _this.authTokenProvider_ = authTokenProvider_;
        _this.appCheckTokenProvider_ = appCheckTokenProvider_;
        /** @private {function(...[*])} */
        _this.log_ = logWrapper('p:rest:');
        /**
         * We don't actually need to track listens, except to prevent us calling an onComplete for a listen
         * that's been removed. :-/
         */
        _this.listens_ = {};
        return _this;
    }
    ReadonlyRestClient.prototype.reportStats = function (stats) {
        throw new Error('Method not implemented.');
    };
    ReadonlyRestClient.getListenId_ = function (query, tag) {
        if (tag !== undefined) {
            return 'tag$' + tag;
        }
        else {
            assert(query._queryParams.isDefault(), "should have a tag if it's not a default query.");
            return query._path.toString();
        }
    };
    /** @inheritDoc */
    ReadonlyRestClient.prototype.listen = function (query, currentHashFn, tag, onComplete) {
        var _this = this;
        var pathString = query._path.toString();
        this.log_('Listen called for ' + pathString + ' ' + query._queryIdentifier);
        // Mark this listener so we can tell if it's removed.
        var listenId = ReadonlyRestClient.getListenId_(query, tag);
        var thisListen = {};
        this.listens_[listenId] = thisListen;
        var queryStringParameters = queryParamsToRestQueryStringParameters(query._queryParams);
        this.restRequest_(pathString + '.json', queryStringParameters, function (error, result) {
            var data = result;
            if (error === 404) {
                data = null;
                error = null;
            }
            if (error === null) {
                _this.onDataUpdate_(pathString, data, /*isMerge=*/ false, tag);
            }
            if (safeGet(_this.listens_, listenId) === thisListen) {
                var status_1;
                if (!error) {
                    status_1 = 'ok';
                }
                else if (error === 401) {
                    status_1 = 'permission_denied';
                }
                else {
                    status_1 = 'rest_error:' + error;
                }
                onComplete(status_1, null);
            }
        });
    };
    /** @inheritDoc */
    ReadonlyRestClient.prototype.unlisten = function (query, tag) {
        var listenId = ReadonlyRestClient.getListenId_(query, tag);
        delete this.listens_[listenId];
    };
    ReadonlyRestClient.prototype.get = function (query) {
        var _this = this;
        var queryStringParameters = queryParamsToRestQueryStringParameters(query._queryParams);
        var pathString = query._path.toString();
        var deferred = new Deferred();
        this.restRequest_(pathString + '.json', queryStringParameters, function (error, result) {
            var data = result;
            if (error === 404) {
                data = null;
                error = null;
            }
            if (error === null) {
                _this.onDataUpdate_(pathString, data, 
                /*isMerge=*/ false, 
                /*tag=*/ null);
                deferred.resolve(data);
            }
            else {
                deferred.reject(new Error(data));
            }
        });
        return deferred.promise;
    };
    /** @inheritDoc */
    ReadonlyRestClient.prototype.refreshAuthToken = function (token) {
        // no-op since we just always call getToken.
    };
    /**
     * Performs a REST request to the given path, with the provided query string parameters,
     * and any auth credentials we have.
     */
    ReadonlyRestClient.prototype.restRequest_ = function (pathString, queryStringParameters, callback) {
        var _this = this;
        if (queryStringParameters === void 0) { queryStringParameters = {}; }
        queryStringParameters['format'] = 'export';
        return Promise.all([
            this.authTokenProvider_.getToken(/*forceRefresh=*/ false),
            this.appCheckTokenProvider_.getToken(/*forceRefresh=*/ false)
        ]).then(function (_a) {
            var _b = __read(_a, 2), authToken = _b[0], appCheckToken = _b[1];
            if (authToken && authToken.accessToken) {
                queryStringParameters['auth'] = authToken.accessToken;
            }
            if (appCheckToken && appCheckToken.token) {
                queryStringParameters['ac'] = appCheckToken.token;
            }
            var url = (_this.repoInfo_.secure ? 'https://' : 'http://') +
                _this.repoInfo_.host +
                pathString +
                '?' +
                'ns=' +
                _this.repoInfo_.namespace +
                querystring(queryStringParameters);
            _this.log_('Sending REST request for ' + url);
            var xhr = new XMLHttpRequest();
            xhr.onreadystatechange = function () {
                if (callback && xhr.readyState === 4) {
                    _this.log_('REST Response for ' + url + ' received. status:', xhr.status, 'response:', xhr.responseText);
                    var res = null;
                    if (xhr.status >= 200 && xhr.status < 300) {
                        try {
                            res = jsonEval(xhr.responseText);
                        }
                        catch (e) {
                            warn('Failed to parse JSON response for ' +
                                url +
                                ': ' +
                                xhr.responseText);
                        }
                        callback(null, res);
                    }
                    else {
                        // 401 and 404 are expected.
                        if (xhr.status !== 401 && xhr.status !== 404) {
                            warn('Got unsuccessful REST response for ' +
                                url +
                                ' Status: ' +
                                xhr.status);
                        }
                        callback(xhr.status);
                    }
                    callback = null;
                }
            };
            xhr.open('GET', url, /*asynchronous=*/ true);
            xhr.send();
        });
    };
    return ReadonlyRestClient;
}(ServerActions));

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Mutable object which basically just stores a reference to the "latest" immutable snapshot.
 */
var SnapshotHolder = /** @class */ (function () {
    function SnapshotHolder() {
        this.rootNode_ = ChildrenNode.EMPTY_NODE;
    }
    SnapshotHolder.prototype.getNode = function (path) {
        return this.rootNode_.getChild(path);
    };
    SnapshotHolder.prototype.updateSnapshot = function (path, newSnapshotNode) {
        this.rootNode_ = this.rootNode_.updateChild(path, newSnapshotNode);
    };
    return SnapshotHolder;
}());

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function newSparseSnapshotTree() {
    return {
        value: null,
        children: new Map()
    };
}
/**
 * Stores the given node at the specified path. If there is already a node
 * at a shallower path, it merges the new data into that snapshot node.
 *
 * @param path - Path to look up snapshot for.
 * @param data - The new data, or null.
 */
function sparseSnapshotTreeRemember(sparseSnapshotTree, path, data) {
    if (pathIsEmpty(path)) {
        sparseSnapshotTree.value = data;
        sparseSnapshotTree.children.clear();
    }
    else if (sparseSnapshotTree.value !== null) {
        sparseSnapshotTree.value = sparseSnapshotTree.value.updateChild(path, data);
    }
    else {
        var childKey = pathGetFront(path);
        if (!sparseSnapshotTree.children.has(childKey)) {
            sparseSnapshotTree.children.set(childKey, newSparseSnapshotTree());
        }
        var child = sparseSnapshotTree.children.get(childKey);
        path = pathPopFront(path);
        sparseSnapshotTreeRemember(child, path, data);
    }
}
/**
 * Purge the data at path from the cache.
 *
 * @param path - Path to look up snapshot for.
 * @returns True if this node should now be removed.
 */
function sparseSnapshotTreeForget(sparseSnapshotTree, path) {
    if (pathIsEmpty(path)) {
        sparseSnapshotTree.value = null;
        sparseSnapshotTree.children.clear();
        return true;
    }
    else {
        if (sparseSnapshotTree.value !== null) {
            if (sparseSnapshotTree.value.isLeafNode()) {
                // We're trying to forget a node that doesn't exist
                return false;
            }
            else {
                var value = sparseSnapshotTree.value;
                sparseSnapshotTree.value = null;
                value.forEachChild(PRIORITY_INDEX, function (key, tree) {
                    sparseSnapshotTreeRemember(sparseSnapshotTree, new Path(key), tree);
                });
                return sparseSnapshotTreeForget(sparseSnapshotTree, path);
            }
        }
        else if (sparseSnapshotTree.children.size > 0) {
            var childKey = pathGetFront(path);
            path = pathPopFront(path);
            if (sparseSnapshotTree.children.has(childKey)) {
                var safeToRemove = sparseSnapshotTreeForget(sparseSnapshotTree.children.get(childKey), path);
                if (safeToRemove) {
                    sparseSnapshotTree.children.delete(childKey);
                }
            }
            return sparseSnapshotTree.children.size === 0;
        }
        else {
            return true;
        }
    }
}
/**
 * Recursively iterates through all of the stored tree and calls the
 * callback on each one.
 *
 * @param prefixPath - Path to look up node for.
 * @param func - The function to invoke for each tree.
 */
function sparseSnapshotTreeForEachTree(sparseSnapshotTree, prefixPath, func) {
    if (sparseSnapshotTree.value !== null) {
        func(prefixPath, sparseSnapshotTree.value);
    }
    else {
        sparseSnapshotTreeForEachChild(sparseSnapshotTree, function (key, tree) {
            var path = new Path(prefixPath.toString() + '/' + key);
            sparseSnapshotTreeForEachTree(tree, path, func);
        });
    }
}
/**
 * Iterates through each immediate child and triggers the callback.
 * Only seems to be used in tests.
 *
 * @param func - The function to invoke for each child.
 */
function sparseSnapshotTreeForEachChild(sparseSnapshotTree, func) {
    sparseSnapshotTree.children.forEach(function (tree, key) {
        func(key, tree);
    });
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Returns the delta from the previous call to get stats.
 *
 * @param collection_ - The collection to "listen" to.
 */
var StatsListener = /** @class */ (function () {
    function StatsListener(collection_) {
        this.collection_ = collection_;
        this.last_ = null;
    }
    StatsListener.prototype.get = function () {
        var newStats = this.collection_.get();
        var delta = __assign({}, newStats);
        if (this.last_) {
            each(this.last_, function (stat, value) {
                delta[stat] = delta[stat] - value;
            });
        }
        this.last_ = newStats;
        return delta;
    };
    return StatsListener;
}());

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Assuming some apps may have a short amount of time on page, and a bulk of firebase operations probably
// happen on page load, we try to report our first set of stats pretty quickly, but we wait at least 10
// seconds to try to ensure the Firebase connection is established / settled.
var FIRST_STATS_MIN_TIME = 10 * 1000;
var FIRST_STATS_MAX_TIME = 30 * 1000;
// We'll continue to report stats on average every 5 minutes.
var REPORT_STATS_INTERVAL = 5 * 60 * 1000;
var StatsReporter = /** @class */ (function () {
    function StatsReporter(collection, server_) {
        this.server_ = server_;
        this.statsToReport_ = {};
        this.statsListener_ = new StatsListener(collection);
        var timeout = FIRST_STATS_MIN_TIME +
            (FIRST_STATS_MAX_TIME - FIRST_STATS_MIN_TIME) * Math.random();
        setTimeoutNonBlocking(this.reportStats_.bind(this), Math.floor(timeout));
    }
    StatsReporter.prototype.reportStats_ = function () {
        var _this = this;
        var stats = this.statsListener_.get();
        var reportedStats = {};
        var haveStatsToReport = false;
        each(stats, function (stat, value) {
            if (value > 0 && contains(_this.statsToReport_, stat)) {
                reportedStats[stat] = value;
                haveStatsToReport = true;
            }
        });
        if (haveStatsToReport) {
            this.server_.reportStats(reportedStats);
        }
        // queue our next run.
        setTimeoutNonBlocking(this.reportStats_.bind(this), Math.floor(Math.random() * 2 * REPORT_STATS_INTERVAL));
    };
    return StatsReporter;
}());

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 *
 * @enum
 */
var OperationType;
(function (OperationType) {
    OperationType[OperationType["OVERWRITE"] = 0] = "OVERWRITE";
    OperationType[OperationType["MERGE"] = 1] = "MERGE";
    OperationType[OperationType["ACK_USER_WRITE"] = 2] = "ACK_USER_WRITE";
    OperationType[OperationType["LISTEN_COMPLETE"] = 3] = "LISTEN_COMPLETE";
})(OperationType || (OperationType = {}));
function newOperationSourceUser() {
    return {
        fromUser: true,
        fromServer: false,
        queryId: null,
        tagged: false
    };
}
function newOperationSourceServer() {
    return {
        fromUser: false,
        fromServer: true,
        queryId: null,
        tagged: false
    };
}
function newOperationSourceServerTaggedQuery(queryId) {
    return {
        fromUser: false,
        fromServer: true,
        queryId: queryId,
        tagged: true
    };
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var AckUserWrite = /** @class */ (function () {
    /**
     * @param affectedTree - A tree containing true for each affected path. Affected paths can't overlap.
     */
    function AckUserWrite(
    /** @inheritDoc */ path, 
    /** @inheritDoc */ affectedTree, 
    /** @inheritDoc */ revert) {
        this.path = path;
        this.affectedTree = affectedTree;
        this.revert = revert;
        /** @inheritDoc */
        this.type = OperationType.ACK_USER_WRITE;
        /** @inheritDoc */
        this.source = newOperationSourceUser();
    }
    AckUserWrite.prototype.operationForChild = function (childName) {
        if (!pathIsEmpty(this.path)) {
            assert(pathGetFront(this.path) === childName, 'operationForChild called for unrelated child.');
            return new AckUserWrite(pathPopFront(this.path), this.affectedTree, this.revert);
        }
        else if (this.affectedTree.value != null) {
            assert(this.affectedTree.children.isEmpty(), 'affectedTree should not have overlapping affected paths.');
            // All child locations are affected as well; just return same operation.
            return this;
        }
        else {
            var childTree = this.affectedTree.subtree(new Path(childName));
            return new AckUserWrite(newEmptyPath(), childTree, this.revert);
        }
    };
    return AckUserWrite;
}());

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var ListenComplete = /** @class */ (function () {
    function ListenComplete(source, path) {
        this.source = source;
        this.path = path;
        /** @inheritDoc */
        this.type = OperationType.LISTEN_COMPLETE;
    }
    ListenComplete.prototype.operationForChild = function (childName) {
        if (pathIsEmpty(this.path)) {
            return new ListenComplete(this.source, newEmptyPath());
        }
        else {
            return new ListenComplete(this.source, pathPopFront(this.path));
        }
    };
    return ListenComplete;
}());

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var Overwrite = /** @class */ (function () {
    function Overwrite(source, path, snap) {
        this.source = source;
        this.path = path;
        this.snap = snap;
        /** @inheritDoc */
        this.type = OperationType.OVERWRITE;
    }
    Overwrite.prototype.operationForChild = function (childName) {
        if (pathIsEmpty(this.path)) {
            return new Overwrite(this.source, newEmptyPath(), this.snap.getImmediateChild(childName));
        }
        else {
            return new Overwrite(this.source, pathPopFront(this.path), this.snap);
        }
    };
    return Overwrite;
}());

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var Merge = /** @class */ (function () {
    function Merge(
    /** @inheritDoc */ source, 
    /** @inheritDoc */ path, 
    /** @inheritDoc */ children) {
        this.source = source;
        this.path = path;
        this.children = children;
        /** @inheritDoc */
        this.type = OperationType.MERGE;
    }
    Merge.prototype.operationForChild = function (childName) {
        if (pathIsEmpty(this.path)) {
            var childTree = this.children.subtree(new Path(childName));
            if (childTree.isEmpty()) {
                // This child is unaffected
                return null;
            }
            else if (childTree.value) {
                // We have a snapshot for the child in question.  This becomes an overwrite of the child.
                return new Overwrite(this.source, newEmptyPath(), childTree.value);
            }
            else {
                // This is a merge at a deeper level
                return new Merge(this.source, newEmptyPath(), childTree);
            }
        }
        else {
            assert(pathGetFront(this.path) === childName, "Can't get a merge for a child not on the path of the operation");
            return new Merge(this.source, pathPopFront(this.path), this.children);
        }
    };
    Merge.prototype.toString = function () {
        return ('Operation(' +
            this.path +
            ': ' +
            this.source.toString() +
            ' merge: ' +
            this.children.toString() +
            ')');
    };
    return Merge;
}());

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * A cache node only stores complete children. Additionally it holds a flag whether the node can be considered fully
 * initialized in the sense that we know at one point in time this represented a valid state of the world, e.g.
 * initialized with data from the server, or a complete overwrite by the client. The filtered flag also tracks
 * whether a node potentially had children removed due to a filter.
 */
var CacheNode = /** @class */ (function () {
    function CacheNode(node_, fullyInitialized_, filtered_) {
        this.node_ = node_;
        this.fullyInitialized_ = fullyInitialized_;
        this.filtered_ = filtered_;
    }
    /**
     * Returns whether this node was fully initialized with either server data or a complete overwrite by the client
     */
    CacheNode.prototype.isFullyInitialized = function () {
        return this.fullyInitialized_;
    };
    /**
     * Returns whether this node is potentially missing children due to a filter applied to the node
     */
    CacheNode.prototype.isFiltered = function () {
        return this.filtered_;
    };
    CacheNode.prototype.isCompleteForPath = function (path) {
        if (pathIsEmpty(path)) {
            return this.isFullyInitialized() && !this.filtered_;
        }
        var childKey = pathGetFront(path);
        return this.isCompleteForChild(childKey);
    };
    CacheNode.prototype.isCompleteForChild = function (key) {
        return ((this.isFullyInitialized() && !this.filtered_) || this.node_.hasChild(key));
    };
    CacheNode.prototype.getNode = function () {
        return this.node_;
    };
    return CacheNode;
}());

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * An EventGenerator is used to convert "raw" changes (Change) as computed by the
 * CacheDiffer into actual events (Event) that can be raised.  See generateEventsForChanges()
 * for details.
 *
 */
var EventGenerator = /** @class */ (function () {
    function EventGenerator(query_) {
        this.query_ = query_;
        this.index_ = this.query_._queryParams.getIndex();
    }
    return EventGenerator;
}());
/**
 * Given a set of raw changes (no moved events and prevName not specified yet), and a set of
 * EventRegistrations that should be notified of these changes, generate the actual events to be raised.
 *
 * Notes:
 *  - child_moved events will be synthesized at this time for any child_changed events that affect
 *    our index.
 *  - prevName will be calculated based on the index ordering.
 */
function eventGeneratorGenerateEventsForChanges(eventGenerator, changes, eventCache, eventRegistrations) {
    var events = [];
    var moves = [];
    changes.forEach(function (change) {
        if (change.type === "child_changed" /* ChangeType.CHILD_CHANGED */ &&
            eventGenerator.index_.indexedValueChanged(change.oldSnap, change.snapshotNode)) {
            moves.push(changeChildMoved(change.childName, change.snapshotNode));
        }
    });
    eventGeneratorGenerateEventsForType(eventGenerator, events, "child_removed" /* ChangeType.CHILD_REMOVED */, changes, eventRegistrations, eventCache);
    eventGeneratorGenerateEventsForType(eventGenerator, events, "child_added" /* ChangeType.CHILD_ADDED */, changes, eventRegistrations, eventCache);
    eventGeneratorGenerateEventsForType(eventGenerator, events, "child_moved" /* ChangeType.CHILD_MOVED */, moves, eventRegistrations, eventCache);
    eventGeneratorGenerateEventsForType(eventGenerator, events, "child_changed" /* ChangeType.CHILD_CHANGED */, changes, eventRegistrations, eventCache);
    eventGeneratorGenerateEventsForType(eventGenerator, events, "value" /* ChangeType.VALUE */, changes, eventRegistrations, eventCache);
    return events;
}
/**
 * Given changes of a single change type, generate the corresponding events.
 */
function eventGeneratorGenerateEventsForType(eventGenerator, events, eventType, changes, registrations, eventCache) {
    var filteredChanges = changes.filter(function (change) { return change.type === eventType; });
    filteredChanges.sort(function (a, b) {
        return eventGeneratorCompareChanges(eventGenerator, a, b);
    });
    filteredChanges.forEach(function (change) {
        var materializedChange = eventGeneratorMaterializeSingleChange(eventGenerator, change, eventCache);
        registrations.forEach(function (registration) {
            if (registration.respondsTo(change.type)) {
                events.push(registration.createEvent(materializedChange, eventGenerator.query_));
            }
        });
    });
}
function eventGeneratorMaterializeSingleChange(eventGenerator, change, eventCache) {
    if (change.type === 'value' || change.type === 'child_removed') {
        return change;
    }
    else {
        change.prevName = eventCache.getPredecessorChildName(change.childName, change.snapshotNode, eventGenerator.index_);
        return change;
    }
}
function eventGeneratorCompareChanges(eventGenerator, a, b) {
    if (a.childName == null || b.childName == null) {
        throw assertionError('Should only compare child_ events.');
    }
    var aWrapped = new NamedNode(a.childName, a.snapshotNode);
    var bWrapped = new NamedNode(b.childName, b.snapshotNode);
    return eventGenerator.index_.compare(aWrapped, bWrapped);
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function newViewCache(eventCache, serverCache) {
    return { eventCache: eventCache, serverCache: serverCache };
}
function viewCacheUpdateEventSnap(viewCache, eventSnap, complete, filtered) {
    return newViewCache(new CacheNode(eventSnap, complete, filtered), viewCache.serverCache);
}
function viewCacheUpdateServerSnap(viewCache, serverSnap, complete, filtered) {
    return newViewCache(viewCache.eventCache, new CacheNode(serverSnap, complete, filtered));
}
function viewCacheGetCompleteEventSnap(viewCache) {
    return viewCache.eventCache.isFullyInitialized()
        ? viewCache.eventCache.getNode()
        : null;
}
function viewCacheGetCompleteServerSnap(viewCache) {
    return viewCache.serverCache.isFullyInitialized()
        ? viewCache.serverCache.getNode()
        : null;
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var emptyChildrenSingleton;
/**
 * Singleton empty children collection.
 *
 */
var EmptyChildren = function () {
    if (!emptyChildrenSingleton) {
        emptyChildrenSingleton = new SortedMap(stringCompare);
    }
    return emptyChildrenSingleton;
};
/**
 * A tree with immutable elements.
 */
var ImmutableTree = /** @class */ (function () {
    function ImmutableTree(value, children) {
        if (children === void 0) { children = EmptyChildren(); }
        this.value = value;
        this.children = children;
    }
    ImmutableTree.fromObject = function (obj) {
        var tree = new ImmutableTree(null);
        each(obj, function (childPath, childSnap) {
            tree = tree.set(new Path(childPath), childSnap);
        });
        return tree;
    };
    /**
     * True if the value is empty and there are no children
     */
    ImmutableTree.prototype.isEmpty = function () {
        return this.value === null && this.children.isEmpty();
    };
    /**
     * Given a path and predicate, return the first node and the path to that node
     * where the predicate returns true.
     *
     * TODO Do a perf test -- If we're creating a bunch of `{path: value:}`
     * objects on the way back out, it may be better to pass down a pathSoFar obj.
     *
     * @param relativePath - The remainder of the path
     * @param predicate - The predicate to satisfy to return a node
     */
    ImmutableTree.prototype.findRootMostMatchingPathAndValue = function (relativePath, predicate) {
        if (this.value != null && predicate(this.value)) {
            return { path: newEmptyPath(), value: this.value };
        }
        else {
            if (pathIsEmpty(relativePath)) {
                return null;
            }
            else {
                var front = pathGetFront(relativePath);
                var child = this.children.get(front);
                if (child !== null) {
                    var childExistingPathAndValue = child.findRootMostMatchingPathAndValue(pathPopFront(relativePath), predicate);
                    if (childExistingPathAndValue != null) {
                        var fullPath = pathChild(new Path(front), childExistingPathAndValue.path);
                        return { path: fullPath, value: childExistingPathAndValue.value };
                    }
                    else {
                        return null;
                    }
                }
                else {
                    return null;
                }
            }
        }
    };
    /**
     * Find, if it exists, the shortest subpath of the given path that points a defined
     * value in the tree
     */
    ImmutableTree.prototype.findRootMostValueAndPath = function (relativePath) {
        return this.findRootMostMatchingPathAndValue(relativePath, function () { return true; });
    };
    /**
     * @returns The subtree at the given path
     */
    ImmutableTree.prototype.subtree = function (relativePath) {
        if (pathIsEmpty(relativePath)) {
            return this;
        }
        else {
            var front = pathGetFront(relativePath);
            var childTree = this.children.get(front);
            if (childTree !== null) {
                return childTree.subtree(pathPopFront(relativePath));
            }
            else {
                return new ImmutableTree(null);
            }
        }
    };
    /**
     * Sets a value at the specified path.
     *
     * @param relativePath - Path to set value at.
     * @param toSet - Value to set.
     * @returns Resulting tree.
     */
    ImmutableTree.prototype.set = function (relativePath, toSet) {
        if (pathIsEmpty(relativePath)) {
            return new ImmutableTree(toSet, this.children);
        }
        else {
            var front = pathGetFront(relativePath);
            var child = this.children.get(front) || new ImmutableTree(null);
            var newChild = child.set(pathPopFront(relativePath), toSet);
            var newChildren = this.children.insert(front, newChild);
            return new ImmutableTree(this.value, newChildren);
        }
    };
    /**
     * Removes the value at the specified path.
     *
     * @param relativePath - Path to value to remove.
     * @returns Resulting tree.
     */
    ImmutableTree.prototype.remove = function (relativePath) {
        if (pathIsEmpty(relativePath)) {
            if (this.children.isEmpty()) {
                return new ImmutableTree(null);
            }
            else {
                return new ImmutableTree(null, this.children);
            }
        }
        else {
            var front = pathGetFront(relativePath);
            var child = this.children.get(front);
            if (child) {
                var newChild = child.remove(pathPopFront(relativePath));
                var newChildren = void 0;
                if (newChild.isEmpty()) {
                    newChildren = this.children.remove(front);
                }
                else {
                    newChildren = this.children.insert(front, newChild);
                }
                if (this.value === null && newChildren.isEmpty()) {
                    return new ImmutableTree(null);
                }
                else {
                    return new ImmutableTree(this.value, newChildren);
                }
            }
            else {
                return this;
            }
        }
    };
    /**
     * Gets a value from the tree.
     *
     * @param relativePath - Path to get value for.
     * @returns Value at path, or null.
     */
    ImmutableTree.prototype.get = function (relativePath) {
        if (pathIsEmpty(relativePath)) {
            return this.value;
        }
        else {
            var front = pathGetFront(relativePath);
            var child = this.children.get(front);
            if (child) {
                return child.get(pathPopFront(relativePath));
            }
            else {
                return null;
            }
        }
    };
    /**
     * Replace the subtree at the specified path with the given new tree.
     *
     * @param relativePath - Path to replace subtree for.
     * @param newTree - New tree.
     * @returns Resulting tree.
     */
    ImmutableTree.prototype.setTree = function (relativePath, newTree) {
        if (pathIsEmpty(relativePath)) {
            return newTree;
        }
        else {
            var front = pathGetFront(relativePath);
            var child = this.children.get(front) || new ImmutableTree(null);
            var newChild = child.setTree(pathPopFront(relativePath), newTree);
            var newChildren = void 0;
            if (newChild.isEmpty()) {
                newChildren = this.children.remove(front);
            }
            else {
                newChildren = this.children.insert(front, newChild);
            }
            return new ImmutableTree(this.value, newChildren);
        }
    };
    /**
     * Performs a depth first fold on this tree. Transforms a tree into a single
     * value, given a function that operates on the path to a node, an optional
     * current value, and a map of child names to folded subtrees
     */
    ImmutableTree.prototype.fold = function (fn) {
        return this.fold_(newEmptyPath(), fn);
    };
    /**
     * Recursive helper for public-facing fold() method
     */
    ImmutableTree.prototype.fold_ = function (pathSoFar, fn) {
        var accum = {};
        this.children.inorderTraversal(function (childKey, childTree) {
            accum[childKey] = childTree.fold_(pathChild(pathSoFar, childKey), fn);
        });
        return fn(pathSoFar, this.value, accum);
    };
    /**
     * Find the first matching value on the given path. Return the result of applying f to it.
     */
    ImmutableTree.prototype.findOnPath = function (path, f) {
        return this.findOnPath_(path, newEmptyPath(), f);
    };
    ImmutableTree.prototype.findOnPath_ = function (pathToFollow, pathSoFar, f) {
        var result = this.value ? f(pathSoFar, this.value) : false;
        if (result) {
            return result;
        }
        else {
            if (pathIsEmpty(pathToFollow)) {
                return null;
            }
            else {
                var front = pathGetFront(pathToFollow);
                var nextChild = this.children.get(front);
                if (nextChild) {
                    return nextChild.findOnPath_(pathPopFront(pathToFollow), pathChild(pathSoFar, front), f);
                }
                else {
                    return null;
                }
            }
        }
    };
    ImmutableTree.prototype.foreachOnPath = function (path, f) {
        return this.foreachOnPath_(path, newEmptyPath(), f);
    };
    ImmutableTree.prototype.foreachOnPath_ = function (pathToFollow, currentRelativePath, f) {
        if (pathIsEmpty(pathToFollow)) {
            return this;
        }
        else {
            if (this.value) {
                f(currentRelativePath, this.value);
            }
            var front = pathGetFront(pathToFollow);
            var nextChild = this.children.get(front);
            if (nextChild) {
                return nextChild.foreachOnPath_(pathPopFront(pathToFollow), pathChild(currentRelativePath, front), f);
            }
            else {
                return new ImmutableTree(null);
            }
        }
    };
    /**
     * Calls the given function for each node in the tree that has a value.
     *
     * @param f - A function to be called with the path from the root of the tree to
     * a node, and the value at that node. Called in depth-first order.
     */
    ImmutableTree.prototype.foreach = function (f) {
        this.foreach_(newEmptyPath(), f);
    };
    ImmutableTree.prototype.foreach_ = function (currentRelativePath, f) {
        this.children.inorderTraversal(function (childName, childTree) {
            childTree.foreach_(pathChild(currentRelativePath, childName), f);
        });
        if (this.value) {
            f(currentRelativePath, this.value);
        }
    };
    ImmutableTree.prototype.foreachChild = function (f) {
        this.children.inorderTraversal(function (childName, childTree) {
            if (childTree.value) {
                f(childName, childTree.value);
            }
        });
    };
    return ImmutableTree;
}());

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * This class holds a collection of writes that can be applied to nodes in unison. It abstracts away the logic with
 * dealing with priority writes and multiple nested writes. At any given path there is only allowed to be one write
 * modifying that path. Any write to an existing path or shadowing an existing path will modify that existing write
 * to reflect the write added.
 */
var CompoundWrite = /** @class */ (function () {
    function CompoundWrite(writeTree_) {
        this.writeTree_ = writeTree_;
    }
    CompoundWrite.empty = function () {
        return new CompoundWrite(new ImmutableTree(null));
    };
    return CompoundWrite;
}());
function compoundWriteAddWrite(compoundWrite, path, node) {
    if (pathIsEmpty(path)) {
        return new CompoundWrite(new ImmutableTree(node));
    }
    else {
        var rootmost = compoundWrite.writeTree_.findRootMostValueAndPath(path);
        if (rootmost != null) {
            var rootMostPath = rootmost.path;
            var value = rootmost.value;
            var relativePath = newRelativePath(rootMostPath, path);
            value = value.updateChild(relativePath, node);
            return new CompoundWrite(compoundWrite.writeTree_.set(rootMostPath, value));
        }
        else {
            var subtree = new ImmutableTree(node);
            var newWriteTree = compoundWrite.writeTree_.setTree(path, subtree);
            return new CompoundWrite(newWriteTree);
        }
    }
}
function compoundWriteAddWrites(compoundWrite, path, updates) {
    var newWrite = compoundWrite;
    each(updates, function (childKey, node) {
        newWrite = compoundWriteAddWrite(newWrite, pathChild(path, childKey), node);
    });
    return newWrite;
}
/**
 * Will remove a write at the given path and deeper paths. This will <em>not</em> modify a write at a higher
 * location, which must be removed by calling this method with that path.
 *
 * @param compoundWrite - The CompoundWrite to remove.
 * @param path - The path at which a write and all deeper writes should be removed
 * @returns The new CompoundWrite with the removed path
 */
function compoundWriteRemoveWrite(compoundWrite, path) {
    if (pathIsEmpty(path)) {
        return CompoundWrite.empty();
    }
    else {
        var newWriteTree = compoundWrite.writeTree_.setTree(path, new ImmutableTree(null));
        return new CompoundWrite(newWriteTree);
    }
}
/**
 * Returns whether this CompoundWrite will fully overwrite a node at a given location and can therefore be
 * considered "complete".
 *
 * @param compoundWrite - The CompoundWrite to check.
 * @param path - The path to check for
 * @returns Whether there is a complete write at that path
 */
function compoundWriteHasCompleteWrite(compoundWrite, path) {
    return compoundWriteGetCompleteNode(compoundWrite, path) != null;
}
/**
 * Returns a node for a path if and only if the node is a "complete" overwrite at that path. This will not aggregate
 * writes from deeper paths, but will return child nodes from a more shallow path.
 *
 * @param compoundWrite - The CompoundWrite to get the node from.
 * @param path - The path to get a complete write
 * @returns The node if complete at that path, or null otherwise.
 */
function compoundWriteGetCompleteNode(compoundWrite, path) {
    var rootmost = compoundWrite.writeTree_.findRootMostValueAndPath(path);
    if (rootmost != null) {
        return compoundWrite.writeTree_
            .get(rootmost.path)
            .getChild(newRelativePath(rootmost.path, path));
    }
    else {
        return null;
    }
}
/**
 * Returns all children that are guaranteed to be a complete overwrite.
 *
 * @param compoundWrite - The CompoundWrite to get children from.
 * @returns A list of all complete children.
 */
function compoundWriteGetCompleteChildren(compoundWrite) {
    var children = [];
    var node = compoundWrite.writeTree_.value;
    if (node != null) {
        // If it's a leaf node, it has no children; so nothing to do.
        if (!node.isLeafNode()) {
            node.forEachChild(PRIORITY_INDEX, function (childName, childNode) {
                children.push(new NamedNode(childName, childNode));
            });
        }
    }
    else {
        compoundWrite.writeTree_.children.inorderTraversal(function (childName, childTree) {
            if (childTree.value != null) {
                children.push(new NamedNode(childName, childTree.value));
            }
        });
    }
    return children;
}
function compoundWriteChildCompoundWrite(compoundWrite, path) {
    if (pathIsEmpty(path)) {
        return compoundWrite;
    }
    else {
        var shadowingNode = compoundWriteGetCompleteNode(compoundWrite, path);
        if (shadowingNode != null) {
            return new CompoundWrite(new ImmutableTree(shadowingNode));
        }
        else {
            return new CompoundWrite(compoundWrite.writeTree_.subtree(path));
        }
    }
}
/**
 * Returns true if this CompoundWrite is empty and therefore does not modify any nodes.
 * @returns Whether this CompoundWrite is empty
 */
function compoundWriteIsEmpty(compoundWrite) {
    return compoundWrite.writeTree_.isEmpty();
}
/**
 * Applies this CompoundWrite to a node. The node is returned with all writes from this CompoundWrite applied to the
 * node
 * @param node - The node to apply this CompoundWrite to
 * @returns The node with all writes applied
 */
function compoundWriteApply(compoundWrite, node) {
    return applySubtreeWrite(newEmptyPath(), compoundWrite.writeTree_, node);
}
function applySubtreeWrite(relativePath, writeTree, node) {
    if (writeTree.value != null) {
        // Since there a write is always a leaf, we're done here
        return node.updateChild(relativePath, writeTree.value);
    }
    else {
        var priorityWrite_1 = null;
        writeTree.children.inorderTraversal(function (childKey, childTree) {
            if (childKey === '.priority') {
                // Apply priorities at the end so we don't update priorities for either empty nodes or forget
                // to apply priorities to empty nodes that are later filled
                assert(childTree.value !== null, 'Priority writes must always be leaf nodes');
                priorityWrite_1 = childTree.value;
            }
            else {
                node = applySubtreeWrite(pathChild(relativePath, childKey), childTree, node);
            }
        });
        // If there was a priority write, we only apply it if the node is not empty
        if (!node.getChild(relativePath).isEmpty() && priorityWrite_1 !== null) {
            node = node.updateChild(pathChild(relativePath, '.priority'), priorityWrite_1);
        }
        return node;
    }
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Create a new WriteTreeRef for the given path. For use with a new sync point at the given path.
 *
 */
function writeTreeChildWrites(writeTree, path) {
    return newWriteTreeRef(path, writeTree);
}
/**
 * Record a new overwrite from user code.
 *
 * @param visible - This is set to false by some transactions. It should be excluded from event caches
 */
function writeTreeAddOverwrite(writeTree, path, snap, writeId, visible) {
    assert(writeId > writeTree.lastWriteId, 'Stacking an older write on top of newer ones');
    if (visible === undefined) {
        visible = true;
    }
    writeTree.allWrites.push({
        path: path,
        snap: snap,
        writeId: writeId,
        visible: visible
    });
    if (visible) {
        writeTree.visibleWrites = compoundWriteAddWrite(writeTree.visibleWrites, path, snap);
    }
    writeTree.lastWriteId = writeId;
}
/**
 * Record a new merge from user code.
 */
function writeTreeAddMerge(writeTree, path, changedChildren, writeId) {
    assert(writeId > writeTree.lastWriteId, 'Stacking an older merge on top of newer ones');
    writeTree.allWrites.push({
        path: path,
        children: changedChildren,
        writeId: writeId,
        visible: true
    });
    writeTree.visibleWrites = compoundWriteAddWrites(writeTree.visibleWrites, path, changedChildren);
    writeTree.lastWriteId = writeId;
}
function writeTreeGetWrite(writeTree, writeId) {
    for (var i = 0; i < writeTree.allWrites.length; i++) {
        var record = writeTree.allWrites[i];
        if (record.writeId === writeId) {
            return record;
        }
    }
    return null;
}
/**
 * Remove a write (either an overwrite or merge) that has been successfully acknowledge by the server. Recalculates
 * the tree if necessary.  We return true if it may have been visible, meaning views need to reevaluate.
 *
 * @returns true if the write may have been visible (meaning we'll need to reevaluate / raise
 * events as a result).
 */
function writeTreeRemoveWrite(writeTree, writeId) {
    // Note: disabling this check. It could be a transaction that preempted another transaction, and thus was applied
    // out of order.
    //const validClear = revert || this.allWrites_.length === 0 || writeId <= this.allWrites_[0].writeId;
    //assert(validClear, "Either we don't have this write, or it's the first one in the queue");
    var idx = writeTree.allWrites.findIndex(function (s) {
        return s.writeId === writeId;
    });
    assert(idx >= 0, 'removeWrite called with nonexistent writeId.');
    var writeToRemove = writeTree.allWrites[idx];
    writeTree.allWrites.splice(idx, 1);
    var removedWriteWasVisible = writeToRemove.visible;
    var removedWriteOverlapsWithOtherWrites = false;
    var i = writeTree.allWrites.length - 1;
    while (removedWriteWasVisible && i >= 0) {
        var currentWrite = writeTree.allWrites[i];
        if (currentWrite.visible) {
            if (i >= idx &&
                writeTreeRecordContainsPath_(currentWrite, writeToRemove.path)) {
                // The removed write was completely shadowed by a subsequent write.
                removedWriteWasVisible = false;
            }
            else if (pathContains(writeToRemove.path, currentWrite.path)) {
                // Either we're covering some writes or they're covering part of us (depending on which came first).
                removedWriteOverlapsWithOtherWrites = true;
            }
        }
        i--;
    }
    if (!removedWriteWasVisible) {
        return false;
    }
    else if (removedWriteOverlapsWithOtherWrites) {
        // There's some shadowing going on. Just rebuild the visible writes from scratch.
        writeTreeResetTree_(writeTree);
        return true;
    }
    else {
        // There's no shadowing.  We can safely just remove the write(s) from visibleWrites.
        if (writeToRemove.snap) {
            writeTree.visibleWrites = compoundWriteRemoveWrite(writeTree.visibleWrites, writeToRemove.path);
        }
        else {
            var children = writeToRemove.children;
            each(children, function (childName) {
                writeTree.visibleWrites = compoundWriteRemoveWrite(writeTree.visibleWrites, pathChild(writeToRemove.path, childName));
            });
        }
        return true;
    }
}
function writeTreeRecordContainsPath_(writeRecord, path) {
    if (writeRecord.snap) {
        return pathContains(writeRecord.path, path);
    }
    else {
        for (var childName in writeRecord.children) {
            if (writeRecord.children.hasOwnProperty(childName) &&
                pathContains(pathChild(writeRecord.path, childName), path)) {
                return true;
            }
        }
        return false;
    }
}
/**
 * Re-layer the writes and merges into a tree so we can efficiently calculate event snapshots
 */
function writeTreeResetTree_(writeTree) {
    writeTree.visibleWrites = writeTreeLayerTree_(writeTree.allWrites, writeTreeDefaultFilter_, newEmptyPath());
    if (writeTree.allWrites.length > 0) {
        writeTree.lastWriteId =
            writeTree.allWrites[writeTree.allWrites.length - 1].writeId;
    }
    else {
        writeTree.lastWriteId = -1;
    }
}
/**
 * The default filter used when constructing the tree. Keep everything that's visible.
 */
function writeTreeDefaultFilter_(write) {
    return write.visible;
}
/**
 * Static method. Given an array of WriteRecords, a filter for which ones to include, and a path, construct the tree of
 * event data at that path.
 */
function writeTreeLayerTree_(writes, filter, treeRoot) {
    var compoundWrite = CompoundWrite.empty();
    for (var i = 0; i < writes.length; ++i) {
        var write = writes[i];
        // Theory, a later set will either:
        // a) abort a relevant transaction, so no need to worry about excluding it from calculating that transaction
        // b) not be relevant to a transaction (separate branch), so again will not affect the data for that transaction
        if (filter(write)) {
            var writePath = write.path;
            var relativePath = void 0;
            if (write.snap) {
                if (pathContains(treeRoot, writePath)) {
                    relativePath = newRelativePath(treeRoot, writePath);
                    compoundWrite = compoundWriteAddWrite(compoundWrite, relativePath, write.snap);
                }
                else if (pathContains(writePath, treeRoot)) {
                    relativePath = newRelativePath(writePath, treeRoot);
                    compoundWrite = compoundWriteAddWrite(compoundWrite, newEmptyPath(), write.snap.getChild(relativePath));
                }
                else ;
            }
            else if (write.children) {
                if (pathContains(treeRoot, writePath)) {
                    relativePath = newRelativePath(treeRoot, writePath);
                    compoundWrite = compoundWriteAddWrites(compoundWrite, relativePath, write.children);
                }
                else if (pathContains(writePath, treeRoot)) {
                    relativePath = newRelativePath(writePath, treeRoot);
                    if (pathIsEmpty(relativePath)) {
                        compoundWrite = compoundWriteAddWrites(compoundWrite, newEmptyPath(), write.children);
                    }
                    else {
                        var child = safeGet(write.children, pathGetFront(relativePath));
                        if (child) {
                            // There exists a child in this node that matches the root path
                            var deepNode = child.getChild(pathPopFront(relativePath));
                            compoundWrite = compoundWriteAddWrite(compoundWrite, newEmptyPath(), deepNode);
                        }
                    }
                }
                else ;
            }
            else {
                throw assertionError('WriteRecord should have .snap or .children');
            }
        }
    }
    return compoundWrite;
}
/**
 * Given optional, underlying server data, and an optional set of constraints (exclude some sets, include hidden
 * writes), attempt to calculate a complete snapshot for the given path
 *
 * @param writeIdsToExclude - An optional set to be excluded
 * @param includeHiddenWrites - Defaults to false, whether or not to layer on writes with visible set to false
 */
function writeTreeCalcCompleteEventCache(writeTree, treePath, completeServerCache, writeIdsToExclude, includeHiddenWrites) {
    if (!writeIdsToExclude && !includeHiddenWrites) {
        var shadowingNode = compoundWriteGetCompleteNode(writeTree.visibleWrites, treePath);
        if (shadowingNode != null) {
            return shadowingNode;
        }
        else {
            var subMerge = compoundWriteChildCompoundWrite(writeTree.visibleWrites, treePath);
            if (compoundWriteIsEmpty(subMerge)) {
                return completeServerCache;
            }
            else if (completeServerCache == null &&
                !compoundWriteHasCompleteWrite(subMerge, newEmptyPath())) {
                // We wouldn't have a complete snapshot, since there's no underlying data and no complete shadow
                return null;
            }
            else {
                var layeredCache = completeServerCache || ChildrenNode.EMPTY_NODE;
                return compoundWriteApply(subMerge, layeredCache);
            }
        }
    }
    else {
        var merge = compoundWriteChildCompoundWrite(writeTree.visibleWrites, treePath);
        if (!includeHiddenWrites && compoundWriteIsEmpty(merge)) {
            return completeServerCache;
        }
        else {
            // If the server cache is null, and we don't have a complete cache, we need to return null
            if (!includeHiddenWrites &&
                completeServerCache == null &&
                !compoundWriteHasCompleteWrite(merge, newEmptyPath())) {
                return null;
            }
            else {
                var filter = function (write) {
                    return ((write.visible || includeHiddenWrites) &&
                        (!writeIdsToExclude ||
                            !~writeIdsToExclude.indexOf(write.writeId)) &&
                        (pathContains(write.path, treePath) ||
                            pathContains(treePath, write.path)));
                };
                var mergeAtPath = writeTreeLayerTree_(writeTree.allWrites, filter, treePath);
                var layeredCache = completeServerCache || ChildrenNode.EMPTY_NODE;
                return compoundWriteApply(mergeAtPath, layeredCache);
            }
        }
    }
}
/**
 * With optional, underlying server data, attempt to return a children node of children that we have complete data for.
 * Used when creating new views, to pre-fill their complete event children snapshot.
 */
function writeTreeCalcCompleteEventChildren(writeTree, treePath, completeServerChildren) {
    var completeChildren = ChildrenNode.EMPTY_NODE;
    var topLevelSet = compoundWriteGetCompleteNode(writeTree.visibleWrites, treePath);
    if (topLevelSet) {
        if (!topLevelSet.isLeafNode()) {
            // we're shadowing everything. Return the children.
            topLevelSet.forEachChild(PRIORITY_INDEX, function (childName, childSnap) {
                completeChildren = completeChildren.updateImmediateChild(childName, childSnap);
            });
        }
        return completeChildren;
    }
    else if (completeServerChildren) {
        // Layer any children we have on top of this
        // We know we don't have a top-level set, so just enumerate existing children
        var merge_1 = compoundWriteChildCompoundWrite(writeTree.visibleWrites, treePath);
        completeServerChildren.forEachChild(PRIORITY_INDEX, function (childName, childNode) {
            var node = compoundWriteApply(compoundWriteChildCompoundWrite(merge_1, new Path(childName)), childNode);
            completeChildren = completeChildren.updateImmediateChild(childName, node);
        });
        // Add any complete children we have from the set
        compoundWriteGetCompleteChildren(merge_1).forEach(function (namedNode) {
            completeChildren = completeChildren.updateImmediateChild(namedNode.name, namedNode.node);
        });
        return completeChildren;
    }
    else {
        // We don't have anything to layer on top of. Layer on any children we have
        // Note that we can return an empty snap if we have a defined delete
        var merge = compoundWriteChildCompoundWrite(writeTree.visibleWrites, treePath);
        compoundWriteGetCompleteChildren(merge).forEach(function (namedNode) {
            completeChildren = completeChildren.updateImmediateChild(namedNode.name, namedNode.node);
        });
        return completeChildren;
    }
}
/**
 * Given that the underlying server data has updated, determine what, if anything, needs to be
 * applied to the event cache.
 *
 * Possibilities:
 *
 * 1. No writes are shadowing. Events should be raised, the snap to be applied comes from the server data
 *
 * 2. Some write is completely shadowing. No events to be raised
 *
 * 3. Is partially shadowed. Events
 *
 * Either existingEventSnap or existingServerSnap must exist
 */
function writeTreeCalcEventCacheAfterServerOverwrite(writeTree, treePath, childPath, existingEventSnap, existingServerSnap) {
    assert(existingEventSnap || existingServerSnap, 'Either existingEventSnap or existingServerSnap must exist');
    var path = pathChild(treePath, childPath);
    if (compoundWriteHasCompleteWrite(writeTree.visibleWrites, path)) {
        // At this point we can probably guarantee that we're in case 2, meaning no events
        // May need to check visibility while doing the findRootMostValueAndPath call
        return null;
    }
    else {
        // No complete shadowing. We're either partially shadowing or not shadowing at all.
        var childMerge = compoundWriteChildCompoundWrite(writeTree.visibleWrites, path);
        if (compoundWriteIsEmpty(childMerge)) {
            // We're not shadowing at all. Case 1
            return existingServerSnap.getChild(childPath);
        }
        else {
            // This could be more efficient if the serverNode + updates doesn't change the eventSnap
            // However this is tricky to find out, since user updates don't necessary change the server
            // snap, e.g. priority updates on empty nodes, or deep deletes. Another special case is if the server
            // adds nodes, but doesn't change any existing writes. It is therefore not enough to
            // only check if the updates change the serverNode.
            // Maybe check if the merge tree contains these special cases and only do a full overwrite in that case?
            return compoundWriteApply(childMerge, existingServerSnap.getChild(childPath));
        }
    }
}
/**
 * Returns a complete child for a given server snap after applying all user writes or null if there is no
 * complete child for this ChildKey.
 */
function writeTreeCalcCompleteChild(writeTree, treePath, childKey, existingServerSnap) {
    var path = pathChild(treePath, childKey);
    var shadowingNode = compoundWriteGetCompleteNode(writeTree.visibleWrites, path);
    if (shadowingNode != null) {
        return shadowingNode;
    }
    else {
        if (existingServerSnap.isCompleteForChild(childKey)) {
            var childMerge = compoundWriteChildCompoundWrite(writeTree.visibleWrites, path);
            return compoundWriteApply(childMerge, existingServerSnap.getNode().getImmediateChild(childKey));
        }
        else {
            return null;
        }
    }
}
/**
 * Returns a node if there is a complete overwrite for this path. More specifically, if there is a write at
 * a higher path, this will return the child of that write relative to the write and this path.
 * Returns null if there is no write at this path.
 */
function writeTreeShadowingWrite(writeTree, path) {
    return compoundWriteGetCompleteNode(writeTree.visibleWrites, path);
}
/**
 * This method is used when processing child remove events on a query. If we can, we pull in children that were outside
 * the window, but may now be in the window.
 */
function writeTreeCalcIndexedSlice(writeTree, treePath, completeServerData, startPost, count, reverse, index) {
    var toIterate;
    var merge = compoundWriteChildCompoundWrite(writeTree.visibleWrites, treePath);
    var shadowingNode = compoundWriteGetCompleteNode(merge, newEmptyPath());
    if (shadowingNode != null) {
        toIterate = shadowingNode;
    }
    else if (completeServerData != null) {
        toIterate = compoundWriteApply(merge, completeServerData);
    }
    else {
        // no children to iterate on
        return [];
    }
    toIterate = toIterate.withIndex(index);
    if (!toIterate.isEmpty() && !toIterate.isLeafNode()) {
        var nodes = [];
        var cmp = index.getCompare();
        var iter = reverse
            ? toIterate.getReverseIteratorFrom(startPost, index)
            : toIterate.getIteratorFrom(startPost, index);
        var next = iter.getNext();
        while (next && nodes.length < count) {
            if (cmp(next, startPost) !== 0) {
                nodes.push(next);
            }
            next = iter.getNext();
        }
        return nodes;
    }
    else {
        return [];
    }
}
function newWriteTree() {
    return {
        visibleWrites: CompoundWrite.empty(),
        allWrites: [],
        lastWriteId: -1
    };
}
/**
 * If possible, returns a complete event cache, using the underlying server data if possible. In addition, can be used
 * to get a cache that includes hidden writes, and excludes arbitrary writes. Note that customizing the returned node
 * can lead to a more expensive calculation.
 *
 * @param writeIdsToExclude - Optional writes to exclude.
 * @param includeHiddenWrites - Defaults to false, whether or not to layer on writes with visible set to false
 */
function writeTreeRefCalcCompleteEventCache(writeTreeRef, completeServerCache, writeIdsToExclude, includeHiddenWrites) {
    return writeTreeCalcCompleteEventCache(writeTreeRef.writeTree, writeTreeRef.treePath, completeServerCache, writeIdsToExclude, includeHiddenWrites);
}
/**
 * If possible, returns a children node containing all of the complete children we have data for. The returned data is a
 * mix of the given server data and write data.
 *
 */
function writeTreeRefCalcCompleteEventChildren(writeTreeRef, completeServerChildren) {
    return writeTreeCalcCompleteEventChildren(writeTreeRef.writeTree, writeTreeRef.treePath, completeServerChildren);
}
/**
 * Given that either the underlying server data has updated or the outstanding writes have updated, determine what,
 * if anything, needs to be applied to the event cache.
 *
 * Possibilities:
 *
 * 1. No writes are shadowing. Events should be raised, the snap to be applied comes from the server data
 *
 * 2. Some write is completely shadowing. No events to be raised
 *
 * 3. Is partially shadowed. Events should be raised
 *
 * Either existingEventSnap or existingServerSnap must exist, this is validated via an assert
 *
 *
 */
function writeTreeRefCalcEventCacheAfterServerOverwrite(writeTreeRef, path, existingEventSnap, existingServerSnap) {
    return writeTreeCalcEventCacheAfterServerOverwrite(writeTreeRef.writeTree, writeTreeRef.treePath, path, existingEventSnap, existingServerSnap);
}
/**
 * Returns a node if there is a complete overwrite for this path. More specifically, if there is a write at
 * a higher path, this will return the child of that write relative to the write and this path.
 * Returns null if there is no write at this path.
 *
 */
function writeTreeRefShadowingWrite(writeTreeRef, path) {
    return writeTreeShadowingWrite(writeTreeRef.writeTree, pathChild(writeTreeRef.treePath, path));
}
/**
 * This method is used when processing child remove events on a query. If we can, we pull in children that were outside
 * the window, but may now be in the window
 */
function writeTreeRefCalcIndexedSlice(writeTreeRef, completeServerData, startPost, count, reverse, index) {
    return writeTreeCalcIndexedSlice(writeTreeRef.writeTree, writeTreeRef.treePath, completeServerData, startPost, count, reverse, index);
}
/**
 * Returns a complete child for a given server snap after applying all user writes or null if there is no
 * complete child for this ChildKey.
 */
function writeTreeRefCalcCompleteChild(writeTreeRef, childKey, existingServerCache) {
    return writeTreeCalcCompleteChild(writeTreeRef.writeTree, writeTreeRef.treePath, childKey, existingServerCache);
}
/**
 * Return a WriteTreeRef for a child.
 */
function writeTreeRefChild(writeTreeRef, childName) {
    return newWriteTreeRef(pathChild(writeTreeRef.treePath, childName), writeTreeRef.writeTree);
}
function newWriteTreeRef(path, writeTree) {
    return {
        treePath: path,
        writeTree: writeTree
    };
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var ChildChangeAccumulator = /** @class */ (function () {
    function ChildChangeAccumulator() {
        this.changeMap = new Map();
    }
    ChildChangeAccumulator.prototype.trackChildChange = function (change) {
        var type = change.type;
        var childKey = change.childName;
        assert(type === "child_added" /* ChangeType.CHILD_ADDED */ ||
            type === "child_changed" /* ChangeType.CHILD_CHANGED */ ||
            type === "child_removed" /* ChangeType.CHILD_REMOVED */, 'Only child changes supported for tracking');
        assert(childKey !== '.priority', 'Only non-priority child changes can be tracked.');
        var oldChange = this.changeMap.get(childKey);
        if (oldChange) {
            var oldType = oldChange.type;
            if (type === "child_added" /* ChangeType.CHILD_ADDED */ &&
                oldType === "child_removed" /* ChangeType.CHILD_REMOVED */) {
                this.changeMap.set(childKey, changeChildChanged(childKey, change.snapshotNode, oldChange.snapshotNode));
            }
            else if (type === "child_removed" /* ChangeType.CHILD_REMOVED */ &&
                oldType === "child_added" /* ChangeType.CHILD_ADDED */) {
                this.changeMap.delete(childKey);
            }
            else if (type === "child_removed" /* ChangeType.CHILD_REMOVED */ &&
                oldType === "child_changed" /* ChangeType.CHILD_CHANGED */) {
                this.changeMap.set(childKey, changeChildRemoved(childKey, oldChange.oldSnap));
            }
            else if (type === "child_changed" /* ChangeType.CHILD_CHANGED */ &&
                oldType === "child_added" /* ChangeType.CHILD_ADDED */) {
                this.changeMap.set(childKey, changeChildAdded(childKey, change.snapshotNode));
            }
            else if (type === "child_changed" /* ChangeType.CHILD_CHANGED */ &&
                oldType === "child_changed" /* ChangeType.CHILD_CHANGED */) {
                this.changeMap.set(childKey, changeChildChanged(childKey, change.snapshotNode, oldChange.oldSnap));
            }
            else {
                throw assertionError('Illegal combination of changes: ' +
                    change +
                    ' occurred after ' +
                    oldChange);
            }
        }
        else {
            this.changeMap.set(childKey, change);
        }
    };
    ChildChangeAccumulator.prototype.getChanges = function () {
        return Array.from(this.changeMap.values());
    };
    return ChildChangeAccumulator;
}());

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * An implementation of CompleteChildSource that never returns any additional children
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
var NoCompleteChildSource_ = /** @class */ (function () {
    function NoCompleteChildSource_() {
    }
    NoCompleteChildSource_.prototype.getCompleteChild = function (childKey) {
        return null;
    };
    NoCompleteChildSource_.prototype.getChildAfterChild = function (index, child, reverse) {
        return null;
    };
    return NoCompleteChildSource_;
}());
/**
 * Singleton instance.
 */
var NO_COMPLETE_CHILD_SOURCE = new NoCompleteChildSource_();
/**
 * An implementation of CompleteChildSource that uses a WriteTree in addition to any other server data or
 * old event caches available to calculate complete children.
 */
var WriteTreeCompleteChildSource = /** @class */ (function () {
    function WriteTreeCompleteChildSource(writes_, viewCache_, optCompleteServerCache_) {
        if (optCompleteServerCache_ === void 0) { optCompleteServerCache_ = null; }
        this.writes_ = writes_;
        this.viewCache_ = viewCache_;
        this.optCompleteServerCache_ = optCompleteServerCache_;
    }
    WriteTreeCompleteChildSource.prototype.getCompleteChild = function (childKey) {
        var node = this.viewCache_.eventCache;
        if (node.isCompleteForChild(childKey)) {
            return node.getNode().getImmediateChild(childKey);
        }
        else {
            var serverNode = this.optCompleteServerCache_ != null
                ? new CacheNode(this.optCompleteServerCache_, true, false)
                : this.viewCache_.serverCache;
            return writeTreeRefCalcCompleteChild(this.writes_, childKey, serverNode);
        }
    };
    WriteTreeCompleteChildSource.prototype.getChildAfterChild = function (index, child, reverse) {
        var completeServerData = this.optCompleteServerCache_ != null
            ? this.optCompleteServerCache_
            : viewCacheGetCompleteServerSnap(this.viewCache_);
        var nodes = writeTreeRefCalcIndexedSlice(this.writes_, completeServerData, child, 1, reverse, index);
        if (nodes.length === 0) {
            return null;
        }
        else {
            return nodes[0];
        }
    };
    return WriteTreeCompleteChildSource;
}());

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function newViewProcessor(filter) {
    return { filter: filter };
}
function viewProcessorAssertIndexed(viewProcessor, viewCache) {
    assert(viewCache.eventCache.getNode().isIndexed(viewProcessor.filter.getIndex()), 'Event snap not indexed');
    assert(viewCache.serverCache.getNode().isIndexed(viewProcessor.filter.getIndex()), 'Server snap not indexed');
}
function viewProcessorApplyOperation(viewProcessor, oldViewCache, operation, writesCache, completeCache) {
    var accumulator = new ChildChangeAccumulator();
    var newViewCache, filterServerNode;
    if (operation.type === OperationType.OVERWRITE) {
        var overwrite = operation;
        if (overwrite.source.fromUser) {
            newViewCache = viewProcessorApplyUserOverwrite(viewProcessor, oldViewCache, overwrite.path, overwrite.snap, writesCache, completeCache, accumulator);
        }
        else {
            assert(overwrite.source.fromServer, 'Unknown source.');
            // We filter the node if it's a tagged update or the node has been previously filtered  and the
            // update is not at the root in which case it is ok (and necessary) to mark the node unfiltered
            // again
            filterServerNode =
                overwrite.source.tagged ||
                    (oldViewCache.serverCache.isFiltered() && !pathIsEmpty(overwrite.path));
            newViewCache = viewProcessorApplyServerOverwrite(viewProcessor, oldViewCache, overwrite.path, overwrite.snap, writesCache, completeCache, filterServerNode, accumulator);
        }
    }
    else if (operation.type === OperationType.MERGE) {
        var merge = operation;
        if (merge.source.fromUser) {
            newViewCache = viewProcessorApplyUserMerge(viewProcessor, oldViewCache, merge.path, merge.children, writesCache, completeCache, accumulator);
        }
        else {
            assert(merge.source.fromServer, 'Unknown source.');
            // We filter the node if it's a tagged update or the node has been previously filtered
            filterServerNode =
                merge.source.tagged || oldViewCache.serverCache.isFiltered();
            newViewCache = viewProcessorApplyServerMerge(viewProcessor, oldViewCache, merge.path, merge.children, writesCache, completeCache, filterServerNode, accumulator);
        }
    }
    else if (operation.type === OperationType.ACK_USER_WRITE) {
        var ackUserWrite = operation;
        if (!ackUserWrite.revert) {
            newViewCache = viewProcessorAckUserWrite(viewProcessor, oldViewCache, ackUserWrite.path, ackUserWrite.affectedTree, writesCache, completeCache, accumulator);
        }
        else {
            newViewCache = viewProcessorRevertUserWrite(viewProcessor, oldViewCache, ackUserWrite.path, writesCache, completeCache, accumulator);
        }
    }
    else if (operation.type === OperationType.LISTEN_COMPLETE) {
        newViewCache = viewProcessorListenComplete(viewProcessor, oldViewCache, operation.path, writesCache, accumulator);
    }
    else {
        throw assertionError('Unknown operation type: ' + operation.type);
    }
    var changes = accumulator.getChanges();
    viewProcessorMaybeAddValueEvent(oldViewCache, newViewCache, changes);
    return { viewCache: newViewCache, changes: changes };
}
function viewProcessorMaybeAddValueEvent(oldViewCache, newViewCache, accumulator) {
    var eventSnap = newViewCache.eventCache;
    if (eventSnap.isFullyInitialized()) {
        var isLeafOrEmpty = eventSnap.getNode().isLeafNode() || eventSnap.getNode().isEmpty();
        var oldCompleteSnap = viewCacheGetCompleteEventSnap(oldViewCache);
        if (accumulator.length > 0 ||
            !oldViewCache.eventCache.isFullyInitialized() ||
            (isLeafOrEmpty && !eventSnap.getNode().equals(oldCompleteSnap)) ||
            !eventSnap.getNode().getPriority().equals(oldCompleteSnap.getPriority())) {
            accumulator.push(changeValue(viewCacheGetCompleteEventSnap(newViewCache)));
        }
    }
}
function viewProcessorGenerateEventCacheAfterServerEvent(viewProcessor, viewCache, changePath, writesCache, source, accumulator) {
    var oldEventSnap = viewCache.eventCache;
    if (writeTreeRefShadowingWrite(writesCache, changePath) != null) {
        // we have a shadowing write, ignore changes
        return viewCache;
    }
    else {
        var newEventCache = void 0, serverNode = void 0;
        if (pathIsEmpty(changePath)) {
            // TODO: figure out how this plays with "sliding ack windows"
            assert(viewCache.serverCache.isFullyInitialized(), 'If change path is empty, we must have complete server data');
            if (viewCache.serverCache.isFiltered()) {
                // We need to special case this, because we need to only apply writes to complete children, or
                // we might end up raising events for incomplete children. If the server data is filtered deep
                // writes cannot be guaranteed to be complete
                var serverCache = viewCacheGetCompleteServerSnap(viewCache);
                var completeChildren = serverCache instanceof ChildrenNode
                    ? serverCache
                    : ChildrenNode.EMPTY_NODE;
                var completeEventChildren = writeTreeRefCalcCompleteEventChildren(writesCache, completeChildren);
                newEventCache = viewProcessor.filter.updateFullNode(viewCache.eventCache.getNode(), completeEventChildren, accumulator);
            }
            else {
                var completeNode = writeTreeRefCalcCompleteEventCache(writesCache, viewCacheGetCompleteServerSnap(viewCache));
                newEventCache = viewProcessor.filter.updateFullNode(viewCache.eventCache.getNode(), completeNode, accumulator);
            }
        }
        else {
            var childKey = pathGetFront(changePath);
            if (childKey === '.priority') {
                assert(pathGetLength(changePath) === 1, "Can't have a priority with additional path components");
                var oldEventNode = oldEventSnap.getNode();
                serverNode = viewCache.serverCache.getNode();
                // we might have overwrites for this priority
                var updatedPriority = writeTreeRefCalcEventCacheAfterServerOverwrite(writesCache, changePath, oldEventNode, serverNode);
                if (updatedPriority != null) {
                    newEventCache = viewProcessor.filter.updatePriority(oldEventNode, updatedPriority);
                }
                else {
                    // priority didn't change, keep old node
                    newEventCache = oldEventSnap.getNode();
                }
            }
            else {
                var childChangePath = pathPopFront(changePath);
                // update child
                var newEventChild = void 0;
                if (oldEventSnap.isCompleteForChild(childKey)) {
                    serverNode = viewCache.serverCache.getNode();
                    var eventChildUpdate = writeTreeRefCalcEventCacheAfterServerOverwrite(writesCache, changePath, oldEventSnap.getNode(), serverNode);
                    if (eventChildUpdate != null) {
                        newEventChild = oldEventSnap
                            .getNode()
                            .getImmediateChild(childKey)
                            .updateChild(childChangePath, eventChildUpdate);
                    }
                    else {
                        // Nothing changed, just keep the old child
                        newEventChild = oldEventSnap.getNode().getImmediateChild(childKey);
                    }
                }
                else {
                    newEventChild = writeTreeRefCalcCompleteChild(writesCache, childKey, viewCache.serverCache);
                }
                if (newEventChild != null) {
                    newEventCache = viewProcessor.filter.updateChild(oldEventSnap.getNode(), childKey, newEventChild, childChangePath, source, accumulator);
                }
                else {
                    // no complete child available or no change
                    newEventCache = oldEventSnap.getNode();
                }
            }
        }
        return viewCacheUpdateEventSnap(viewCache, newEventCache, oldEventSnap.isFullyInitialized() || pathIsEmpty(changePath), viewProcessor.filter.filtersNodes());
    }
}
function viewProcessorApplyServerOverwrite(viewProcessor, oldViewCache, changePath, changedSnap, writesCache, completeCache, filterServerNode, accumulator) {
    var oldServerSnap = oldViewCache.serverCache;
    var newServerCache;
    var serverFilter = filterServerNode
        ? viewProcessor.filter
        : viewProcessor.filter.getIndexedFilter();
    if (pathIsEmpty(changePath)) {
        newServerCache = serverFilter.updateFullNode(oldServerSnap.getNode(), changedSnap, null);
    }
    else if (serverFilter.filtersNodes() && !oldServerSnap.isFiltered()) {
        // we want to filter the server node, but we didn't filter the server node yet, so simulate a full update
        var newServerNode = oldServerSnap
            .getNode()
            .updateChild(changePath, changedSnap);
        newServerCache = serverFilter.updateFullNode(oldServerSnap.getNode(), newServerNode, null);
    }
    else {
        var childKey = pathGetFront(changePath);
        if (!oldServerSnap.isCompleteForPath(changePath) &&
            pathGetLength(changePath) > 1) {
            // We don't update incomplete nodes with updates intended for other listeners
            return oldViewCache;
        }
        var childChangePath = pathPopFront(changePath);
        var childNode = oldServerSnap.getNode().getImmediateChild(childKey);
        var newChildNode = childNode.updateChild(childChangePath, changedSnap);
        if (childKey === '.priority') {
            newServerCache = serverFilter.updatePriority(oldServerSnap.getNode(), newChildNode);
        }
        else {
            newServerCache = serverFilter.updateChild(oldServerSnap.getNode(), childKey, newChildNode, childChangePath, NO_COMPLETE_CHILD_SOURCE, null);
        }
    }
    var newViewCache = viewCacheUpdateServerSnap(oldViewCache, newServerCache, oldServerSnap.isFullyInitialized() || pathIsEmpty(changePath), serverFilter.filtersNodes());
    var source = new WriteTreeCompleteChildSource(writesCache, newViewCache, completeCache);
    return viewProcessorGenerateEventCacheAfterServerEvent(viewProcessor, newViewCache, changePath, writesCache, source, accumulator);
}
function viewProcessorApplyUserOverwrite(viewProcessor, oldViewCache, changePath, changedSnap, writesCache, completeCache, accumulator) {
    var oldEventSnap = oldViewCache.eventCache;
    var newViewCache, newEventCache;
    var source = new WriteTreeCompleteChildSource(writesCache, oldViewCache, completeCache);
    if (pathIsEmpty(changePath)) {
        newEventCache = viewProcessor.filter.updateFullNode(oldViewCache.eventCache.getNode(), changedSnap, accumulator);
        newViewCache = viewCacheUpdateEventSnap(oldViewCache, newEventCache, true, viewProcessor.filter.filtersNodes());
    }
    else {
        var childKey = pathGetFront(changePath);
        if (childKey === '.priority') {
            newEventCache = viewProcessor.filter.updatePriority(oldViewCache.eventCache.getNode(), changedSnap);
            newViewCache = viewCacheUpdateEventSnap(oldViewCache, newEventCache, oldEventSnap.isFullyInitialized(), oldEventSnap.isFiltered());
        }
        else {
            var childChangePath = pathPopFront(changePath);
            var oldChild = oldEventSnap.getNode().getImmediateChild(childKey);
            var newChild = void 0;
            if (pathIsEmpty(childChangePath)) {
                // Child overwrite, we can replace the child
                newChild = changedSnap;
            }
            else {
                var childNode = source.getCompleteChild(childKey);
                if (childNode != null) {
                    if (pathGetBack(childChangePath) === '.priority' &&
                        childNode.getChild(pathParent(childChangePath)).isEmpty()) {
                        // This is a priority update on an empty node. If this node exists on the server, the
                        // server will send down the priority in the update, so ignore for now
                        newChild = childNode;
                    }
                    else {
                        newChild = childNode.updateChild(childChangePath, changedSnap);
                    }
                }
                else {
                    // There is no complete child node available
                    newChild = ChildrenNode.EMPTY_NODE;
                }
            }
            if (!oldChild.equals(newChild)) {
                var newEventSnap = viewProcessor.filter.updateChild(oldEventSnap.getNode(), childKey, newChild, childChangePath, source, accumulator);
                newViewCache = viewCacheUpdateEventSnap(oldViewCache, newEventSnap, oldEventSnap.isFullyInitialized(), viewProcessor.filter.filtersNodes());
            }
            else {
                newViewCache = oldViewCache;
            }
        }
    }
    return newViewCache;
}
function viewProcessorCacheHasChild(viewCache, childKey) {
    return viewCache.eventCache.isCompleteForChild(childKey);
}
function viewProcessorApplyUserMerge(viewProcessor, viewCache, path, changedChildren, writesCache, serverCache, accumulator) {
    // HACK: In the case of a limit query, there may be some changes that bump things out of the
    // window leaving room for new items.  It's important we process these changes first, so we
    // iterate the changes twice, first processing any that affect items currently in view.
    // TODO: I consider an item "in view" if cacheHasChild is true, which checks both the server
    // and event snap.  I'm not sure if this will result in edge cases when a child is in one but
    // not the other.
    var curViewCache = viewCache;
    changedChildren.foreach(function (relativePath, childNode) {
        var writePath = pathChild(path, relativePath);
        if (viewProcessorCacheHasChild(viewCache, pathGetFront(writePath))) {
            curViewCache = viewProcessorApplyUserOverwrite(viewProcessor, curViewCache, writePath, childNode, writesCache, serverCache, accumulator);
        }
    });
    changedChildren.foreach(function (relativePath, childNode) {
        var writePath = pathChild(path, relativePath);
        if (!viewProcessorCacheHasChild(viewCache, pathGetFront(writePath))) {
            curViewCache = viewProcessorApplyUserOverwrite(viewProcessor, curViewCache, writePath, childNode, writesCache, serverCache, accumulator);
        }
    });
    return curViewCache;
}
function viewProcessorApplyMerge(viewProcessor, node, merge) {
    merge.foreach(function (relativePath, childNode) {
        node = node.updateChild(relativePath, childNode);
    });
    return node;
}
function viewProcessorApplyServerMerge(viewProcessor, viewCache, path, changedChildren, writesCache, serverCache, filterServerNode, accumulator) {
    // If we don't have a cache yet, this merge was intended for a previously listen in the same location. Ignore it and
    // wait for the complete data update coming soon.
    if (viewCache.serverCache.getNode().isEmpty() &&
        !viewCache.serverCache.isFullyInitialized()) {
        return viewCache;
    }
    // HACK: In the case of a limit query, there may be some changes that bump things out of the
    // window leaving room for new items.  It's important we process these changes first, so we
    // iterate the changes twice, first processing any that affect items currently in view.
    // TODO: I consider an item "in view" if cacheHasChild is true, which checks both the server
    // and event snap.  I'm not sure if this will result in edge cases when a child is in one but
    // not the other.
    var curViewCache = viewCache;
    var viewMergeTree;
    if (pathIsEmpty(path)) {
        viewMergeTree = changedChildren;
    }
    else {
        viewMergeTree = new ImmutableTree(null).setTree(path, changedChildren);
    }
    var serverNode = viewCache.serverCache.getNode();
    viewMergeTree.children.inorderTraversal(function (childKey, childTree) {
        if (serverNode.hasChild(childKey)) {
            var serverChild = viewCache.serverCache
                .getNode()
                .getImmediateChild(childKey);
            var newChild = viewProcessorApplyMerge(viewProcessor, serverChild, childTree);
            curViewCache = viewProcessorApplyServerOverwrite(viewProcessor, curViewCache, new Path(childKey), newChild, writesCache, serverCache, filterServerNode, accumulator);
        }
    });
    viewMergeTree.children.inorderTraversal(function (childKey, childMergeTree) {
        var isUnknownDeepMerge = !viewCache.serverCache.isCompleteForChild(childKey) &&
            childMergeTree.value === null;
        if (!serverNode.hasChild(childKey) && !isUnknownDeepMerge) {
            var serverChild = viewCache.serverCache
                .getNode()
                .getImmediateChild(childKey);
            var newChild = viewProcessorApplyMerge(viewProcessor, serverChild, childMergeTree);
            curViewCache = viewProcessorApplyServerOverwrite(viewProcessor, curViewCache, new Path(childKey), newChild, writesCache, serverCache, filterServerNode, accumulator);
        }
    });
    return curViewCache;
}
function viewProcessorAckUserWrite(viewProcessor, viewCache, ackPath, affectedTree, writesCache, completeCache, accumulator) {
    if (writeTreeRefShadowingWrite(writesCache, ackPath) != null) {
        return viewCache;
    }
    // Only filter server node if it is currently filtered
    var filterServerNode = viewCache.serverCache.isFiltered();
    // Essentially we'll just get our existing server cache for the affected paths and re-apply it as a server update
    // now that it won't be shadowed.
    var serverCache = viewCache.serverCache;
    if (affectedTree.value != null) {
        // This is an overwrite.
        if ((pathIsEmpty(ackPath) && serverCache.isFullyInitialized()) ||
            serverCache.isCompleteForPath(ackPath)) {
            return viewProcessorApplyServerOverwrite(viewProcessor, viewCache, ackPath, serverCache.getNode().getChild(ackPath), writesCache, completeCache, filterServerNode, accumulator);
        }
        else if (pathIsEmpty(ackPath)) {
            // This is a goofy edge case where we are acking data at this location but don't have full data.  We
            // should just re-apply whatever we have in our cache as a merge.
            var changedChildren_1 = new ImmutableTree(null);
            serverCache.getNode().forEachChild(KEY_INDEX, function (name, node) {
                changedChildren_1 = changedChildren_1.set(new Path(name), node);
            });
            return viewProcessorApplyServerMerge(viewProcessor, viewCache, ackPath, changedChildren_1, writesCache, completeCache, filterServerNode, accumulator);
        }
        else {
            return viewCache;
        }
    }
    else {
        // This is a merge.
        var changedChildren_2 = new ImmutableTree(null);
        affectedTree.foreach(function (mergePath, value) {
            var serverCachePath = pathChild(ackPath, mergePath);
            if (serverCache.isCompleteForPath(serverCachePath)) {
                changedChildren_2 = changedChildren_2.set(mergePath, serverCache.getNode().getChild(serverCachePath));
            }
        });
        return viewProcessorApplyServerMerge(viewProcessor, viewCache, ackPath, changedChildren_2, writesCache, completeCache, filterServerNode, accumulator);
    }
}
function viewProcessorListenComplete(viewProcessor, viewCache, path, writesCache, accumulator) {
    var oldServerNode = viewCache.serverCache;
    var newViewCache = viewCacheUpdateServerSnap(viewCache, oldServerNode.getNode(), oldServerNode.isFullyInitialized() || pathIsEmpty(path), oldServerNode.isFiltered());
    return viewProcessorGenerateEventCacheAfterServerEvent(viewProcessor, newViewCache, path, writesCache, NO_COMPLETE_CHILD_SOURCE, accumulator);
}
function viewProcessorRevertUserWrite(viewProcessor, viewCache, path, writesCache, completeServerCache, accumulator) {
    var complete;
    if (writeTreeRefShadowingWrite(writesCache, path) != null) {
        return viewCache;
    }
    else {
        var source = new WriteTreeCompleteChildSource(writesCache, viewCache, completeServerCache);
        var oldEventCache = viewCache.eventCache.getNode();
        var newEventCache = void 0;
        if (pathIsEmpty(path) || pathGetFront(path) === '.priority') {
            var newNode = void 0;
            if (viewCache.serverCache.isFullyInitialized()) {
                newNode = writeTreeRefCalcCompleteEventCache(writesCache, viewCacheGetCompleteServerSnap(viewCache));
            }
            else {
                var serverChildren = viewCache.serverCache.getNode();
                assert(serverChildren instanceof ChildrenNode, 'serverChildren would be complete if leaf node');
                newNode = writeTreeRefCalcCompleteEventChildren(writesCache, serverChildren);
            }
            newNode = newNode;
            newEventCache = viewProcessor.filter.updateFullNode(oldEventCache, newNode, accumulator);
        }
        else {
            var childKey = pathGetFront(path);
            var newChild = writeTreeRefCalcCompleteChild(writesCache, childKey, viewCache.serverCache);
            if (newChild == null &&
                viewCache.serverCache.isCompleteForChild(childKey)) {
                newChild = oldEventCache.getImmediateChild(childKey);
            }
            if (newChild != null) {
                newEventCache = viewProcessor.filter.updateChild(oldEventCache, childKey, newChild, pathPopFront(path), source, accumulator);
            }
            else if (viewCache.eventCache.getNode().hasChild(childKey)) {
                // No complete child available, delete the existing one, if any
                newEventCache = viewProcessor.filter.updateChild(oldEventCache, childKey, ChildrenNode.EMPTY_NODE, pathPopFront(path), source, accumulator);
            }
            else {
                newEventCache = oldEventCache;
            }
            if (newEventCache.isEmpty() &&
                viewCache.serverCache.isFullyInitialized()) {
                // We might have reverted all child writes. Maybe the old event was a leaf node
                complete = writeTreeRefCalcCompleteEventCache(writesCache, viewCacheGetCompleteServerSnap(viewCache));
                if (complete.isLeafNode()) {
                    newEventCache = viewProcessor.filter.updateFullNode(newEventCache, complete, accumulator);
                }
            }
        }
        complete =
            viewCache.serverCache.isFullyInitialized() ||
                writeTreeRefShadowingWrite(writesCache, newEmptyPath()) != null;
        return viewCacheUpdateEventSnap(viewCache, newEventCache, complete, viewProcessor.filter.filtersNodes());
    }
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * A view represents a specific location and query that has 1 or more event registrations.
 *
 * It does several things:
 *  - Maintains the list of event registrations for this location/query.
 *  - Maintains a cache of the data visible for this location/query.
 *  - Applies new operations (via applyOperation), updates the cache, and based on the event
 *    registrations returns the set of events to be raised.
 */
var View = /** @class */ (function () {
    function View(query_, initialViewCache) {
        this.query_ = query_;
        this.eventRegistrations_ = [];
        var params = this.query_._queryParams;
        var indexFilter = new IndexedFilter(params.getIndex());
        var filter = queryParamsGetNodeFilter(params);
        this.processor_ = newViewProcessor(filter);
        var initialServerCache = initialViewCache.serverCache;
        var initialEventCache = initialViewCache.eventCache;
        // Don't filter server node with other filter than index, wait for tagged listen
        var serverSnap = indexFilter.updateFullNode(ChildrenNode.EMPTY_NODE, initialServerCache.getNode(), null);
        var eventSnap = filter.updateFullNode(ChildrenNode.EMPTY_NODE, initialEventCache.getNode(), null);
        var newServerCache = new CacheNode(serverSnap, initialServerCache.isFullyInitialized(), indexFilter.filtersNodes());
        var newEventCache = new CacheNode(eventSnap, initialEventCache.isFullyInitialized(), filter.filtersNodes());
        this.viewCache_ = newViewCache(newEventCache, newServerCache);
        this.eventGenerator_ = new EventGenerator(this.query_);
    }
    Object.defineProperty(View.prototype, "query", {
        get: function () {
            return this.query_;
        },
        enumerable: false,
        configurable: true
    });
    return View;
}());
function viewGetServerCache(view) {
    return view.viewCache_.serverCache.getNode();
}
function viewGetCompleteNode(view) {
    return viewCacheGetCompleteEventSnap(view.viewCache_);
}
function viewGetCompleteServerCache(view, path) {
    var cache = viewCacheGetCompleteServerSnap(view.viewCache_);
    if (cache) {
        // If this isn't a "loadsAllData" view, then cache isn't actually a complete cache and
        // we need to see if it contains the child we're interested in.
        if (view.query._queryParams.loadsAllData() ||
            (!pathIsEmpty(path) &&
                !cache.getImmediateChild(pathGetFront(path)).isEmpty())) {
            return cache.getChild(path);
        }
    }
    return null;
}
function viewIsEmpty(view) {
    return view.eventRegistrations_.length === 0;
}
function viewAddEventRegistration(view, eventRegistration) {
    view.eventRegistrations_.push(eventRegistration);
}
/**
 * @param eventRegistration - If null, remove all callbacks.
 * @param cancelError - If a cancelError is provided, appropriate cancel events will be returned.
 * @returns Cancel events, if cancelError was provided.
 */
function viewRemoveEventRegistration(view, eventRegistration, cancelError) {
    var cancelEvents = [];
    if (cancelError) {
        assert(eventRegistration == null, 'A cancel should cancel all event registrations.');
        var path_1 = view.query._path;
        view.eventRegistrations_.forEach(function (registration) {
            var maybeEvent = registration.createCancelEvent(cancelError, path_1);
            if (maybeEvent) {
                cancelEvents.push(maybeEvent);
            }
        });
    }
    if (eventRegistration) {
        var remaining = [];
        for (var i = 0; i < view.eventRegistrations_.length; ++i) {
            var existing = view.eventRegistrations_[i];
            if (!existing.matches(eventRegistration)) {
                remaining.push(existing);
            }
            else if (eventRegistration.hasAnyCallback()) {
                // We're removing just this one
                remaining = remaining.concat(view.eventRegistrations_.slice(i + 1));
                break;
            }
        }
        view.eventRegistrations_ = remaining;
    }
    else {
        view.eventRegistrations_ = [];
    }
    return cancelEvents;
}
/**
 * Applies the given Operation, updates our cache, and returns the appropriate events.
 */
function viewApplyOperation(view, operation, writesCache, completeServerCache) {
    if (operation.type === OperationType.MERGE &&
        operation.source.queryId !== null) {
        assert(viewCacheGetCompleteServerSnap(view.viewCache_), 'We should always have a full cache before handling merges');
        assert(viewCacheGetCompleteEventSnap(view.viewCache_), 'Missing event cache, even though we have a server cache');
    }
    var oldViewCache = view.viewCache_;
    var result = viewProcessorApplyOperation(view.processor_, oldViewCache, operation, writesCache, completeServerCache);
    viewProcessorAssertIndexed(view.processor_, result.viewCache);
    assert(result.viewCache.serverCache.isFullyInitialized() ||
        !oldViewCache.serverCache.isFullyInitialized(), 'Once a server snap is complete, it should never go back');
    view.viewCache_ = result.viewCache;
    return viewGenerateEventsForChanges_(view, result.changes, result.viewCache.eventCache.getNode(), null);
}
function viewGetInitialEvents(view, registration) {
    var eventSnap = view.viewCache_.eventCache;
    var initialChanges = [];
    if (!eventSnap.getNode().isLeafNode()) {
        var eventNode = eventSnap.getNode();
        eventNode.forEachChild(PRIORITY_INDEX, function (key, childNode) {
            initialChanges.push(changeChildAdded(key, childNode));
        });
    }
    if (eventSnap.isFullyInitialized()) {
        initialChanges.push(changeValue(eventSnap.getNode()));
    }
    return viewGenerateEventsForChanges_(view, initialChanges, eventSnap.getNode(), registration);
}
function viewGenerateEventsForChanges_(view, changes, eventCache, eventRegistration) {
    var registrations = eventRegistration
        ? [eventRegistration]
        : view.eventRegistrations_;
    return eventGeneratorGenerateEventsForChanges(view.eventGenerator_, changes, eventCache, registrations);
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var referenceConstructor$1;
/**
 * SyncPoint represents a single location in a SyncTree with 1 or more event registrations, meaning we need to
 * maintain 1 or more Views at this location to cache server data and raise appropriate events for server changes
 * and user writes (set, transaction, update).
 *
 * It's responsible for:
 *  - Maintaining the set of 1 or more views necessary at this location (a SyncPoint with 0 views should be removed).
 *  - Proxying user / server operations to the views as appropriate (i.e. applyServerOverwrite,
 *    applyUserOverwrite, etc.)
 */
var SyncPoint = /** @class */ (function () {
    function SyncPoint() {
        /**
         * The Views being tracked at this location in the tree, stored as a map where the key is a
         * queryId and the value is the View for that query.
         *
         * NOTE: This list will be quite small (usually 1, but perhaps 2 or 3; any more is an odd use case).
         */
        this.views = new Map();
    }
    return SyncPoint;
}());
function syncPointSetReferenceConstructor(val) {
    assert(!referenceConstructor$1, '__referenceConstructor has already been defined');
    referenceConstructor$1 = val;
}
function syncPointGetReferenceConstructor() {
    assert(referenceConstructor$1, 'Reference.ts has not been loaded');
    return referenceConstructor$1;
}
function syncPointIsEmpty(syncPoint) {
    return syncPoint.views.size === 0;
}
function syncPointApplyOperation(syncPoint, operation, writesCache, optCompleteServerCache) {
    var e_1, _a;
    var queryId = operation.source.queryId;
    if (queryId !== null) {
        var view = syncPoint.views.get(queryId);
        assert(view != null, 'SyncTree gave us an op for an invalid query.');
        return viewApplyOperation(view, operation, writesCache, optCompleteServerCache);
    }
    else {
        var events = [];
        try {
            for (var _b = __values(syncPoint.views.values()), _c = _b.next(); !_c.done; _c = _b.next()) {
                var view = _c.value;
                events = events.concat(viewApplyOperation(view, operation, writesCache, optCompleteServerCache));
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return events;
    }
}
/**
 * Get a view for the specified query.
 *
 * @param query - The query to return a view for
 * @param writesCache
 * @param serverCache
 * @param serverCacheComplete
 * @returns Events to raise.
 */
function syncPointGetView(syncPoint, query, writesCache, serverCache, serverCacheComplete) {
    var queryId = query._queryIdentifier;
    var view = syncPoint.views.get(queryId);
    if (!view) {
        // TODO: make writesCache take flag for complete server node
        var eventCache = writeTreeRefCalcCompleteEventCache(writesCache, serverCacheComplete ? serverCache : null);
        var eventCacheComplete = false;
        if (eventCache) {
            eventCacheComplete = true;
        }
        else if (serverCache instanceof ChildrenNode) {
            eventCache = writeTreeRefCalcCompleteEventChildren(writesCache, serverCache);
            eventCacheComplete = false;
        }
        else {
            eventCache = ChildrenNode.EMPTY_NODE;
            eventCacheComplete = false;
        }
        var viewCache = newViewCache(new CacheNode(eventCache, eventCacheComplete, false), new CacheNode(serverCache, serverCacheComplete, false));
        return new View(query, viewCache);
    }
    return view;
}
/**
 * Add an event callback for the specified query.
 *
 * @param query
 * @param eventRegistration
 * @param writesCache
 * @param serverCache - Complete server cache, if we have it.
 * @param serverCacheComplete
 * @returns Events to raise.
 */
function syncPointAddEventRegistration(syncPoint, query, eventRegistration, writesCache, serverCache, serverCacheComplete) {
    var view = syncPointGetView(syncPoint, query, writesCache, serverCache, serverCacheComplete);
    if (!syncPoint.views.has(query._queryIdentifier)) {
        syncPoint.views.set(query._queryIdentifier, view);
    }
    // This is guaranteed to exist now, we just created anything that was missing
    viewAddEventRegistration(view, eventRegistration);
    return viewGetInitialEvents(view, eventRegistration);
}
/**
 * Remove event callback(s).  Return cancelEvents if a cancelError is specified.
 *
 * If query is the default query, we'll check all views for the specified eventRegistration.
 * If eventRegistration is null, we'll remove all callbacks for the specified view(s).
 *
 * @param eventRegistration - If null, remove all callbacks.
 * @param cancelError - If a cancelError is provided, appropriate cancel events will be returned.
 * @returns removed queries and any cancel events
 */
function syncPointRemoveEventRegistration(syncPoint, query, eventRegistration, cancelError) {
    var e_2, _a;
    var queryId = query._queryIdentifier;
    var removed = [];
    var cancelEvents = [];
    var hadCompleteView = syncPointHasCompleteView(syncPoint);
    if (queryId === 'default') {
        try {
            // When you do ref.off(...), we search all views for the registration to remove.
            for (var _b = __values(syncPoint.views.entries()), _c = _b.next(); !_c.done; _c = _b.next()) {
                var _d = __read(_c.value, 2), viewQueryId = _d[0], view = _d[1];
                cancelEvents = cancelEvents.concat(viewRemoveEventRegistration(view, eventRegistration, cancelError));
                if (viewIsEmpty(view)) {
                    syncPoint.views.delete(viewQueryId);
                    // We'll deal with complete views later.
                    if (!view.query._queryParams.loadsAllData()) {
                        removed.push(view.query);
                    }
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_2) throw e_2.error; }
        }
    }
    else {
        // remove the callback from the specific view.
        var view = syncPoint.views.get(queryId);
        if (view) {
            cancelEvents = cancelEvents.concat(viewRemoveEventRegistration(view, eventRegistration, cancelError));
            if (viewIsEmpty(view)) {
                syncPoint.views.delete(queryId);
                // We'll deal with complete views later.
                if (!view.query._queryParams.loadsAllData()) {
                    removed.push(view.query);
                }
            }
        }
    }
    if (hadCompleteView && !syncPointHasCompleteView(syncPoint)) {
        // We removed our last complete view.
        removed.push(new (syncPointGetReferenceConstructor())(query._repo, query._path));
    }
    return { removed: removed, events: cancelEvents };
}
function syncPointGetQueryViews(syncPoint) {
    var e_3, _a;
    var result = [];
    try {
        for (var _b = __values(syncPoint.views.values()), _c = _b.next(); !_c.done; _c = _b.next()) {
            var view = _c.value;
            if (!view.query._queryParams.loadsAllData()) {
                result.push(view);
            }
        }
    }
    catch (e_3_1) { e_3 = { error: e_3_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_3) throw e_3.error; }
    }
    return result;
}
/**
 * @param path - The path to the desired complete snapshot
 * @returns A complete cache, if it exists
 */
function syncPointGetCompleteServerCache(syncPoint, path) {
    var e_4, _a;
    var serverCache = null;
    try {
        for (var _b = __values(syncPoint.views.values()), _c = _b.next(); !_c.done; _c = _b.next()) {
            var view = _c.value;
            serverCache = serverCache || viewGetCompleteServerCache(view, path);
        }
    }
    catch (e_4_1) { e_4 = { error: e_4_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_4) throw e_4.error; }
    }
    return serverCache;
}
function syncPointViewForQuery(syncPoint, query) {
    var params = query._queryParams;
    if (params.loadsAllData()) {
        return syncPointGetCompleteView(syncPoint);
    }
    else {
        var queryId = query._queryIdentifier;
        return syncPoint.views.get(queryId);
    }
}
function syncPointViewExistsForQuery(syncPoint, query) {
    return syncPointViewForQuery(syncPoint, query) != null;
}
function syncPointHasCompleteView(syncPoint) {
    return syncPointGetCompleteView(syncPoint) != null;
}
function syncPointGetCompleteView(syncPoint) {
    var e_5, _a;
    try {
        for (var _b = __values(syncPoint.views.values()), _c = _b.next(); !_c.done; _c = _b.next()) {
            var view = _c.value;
            if (view.query._queryParams.loadsAllData()) {
                return view;
            }
        }
    }
    catch (e_5_1) { e_5 = { error: e_5_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_5) throw e_5.error; }
    }
    return null;
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var referenceConstructor;
function syncTreeSetReferenceConstructor(val) {
    assert(!referenceConstructor, '__referenceConstructor has already been defined');
    referenceConstructor = val;
}
function syncTreeGetReferenceConstructor() {
    assert(referenceConstructor, 'Reference.ts has not been loaded');
    return referenceConstructor;
}
/**
 * Static tracker for next query tag.
 */
var syncTreeNextQueryTag_ = 1;
/**
 * SyncTree is the central class for managing event callback registration, data caching, views
 * (query processing), and event generation.  There are typically two SyncTree instances for
 * each Repo, one for the normal Firebase data, and one for the .info data.
 *
 * It has a number of responsibilities, including:
 *  - Tracking all user event callbacks (registered via addEventRegistration() and removeEventRegistration()).
 *  - Applying and caching data changes for user set(), transaction(), and update() calls
 *    (applyUserOverwrite(), applyUserMerge()).
 *  - Applying and caching data changes for server data changes (applyServerOverwrite(),
 *    applyServerMerge()).
 *  - Generating user-facing events for server and user changes (all of the apply* methods
 *    return the set of events that need to be raised as a result).
 *  - Maintaining the appropriate set of server listens to ensure we are always subscribed
 *    to the correct set of paths and queries to satisfy the current set of user event
 *    callbacks (listens are started/stopped using the provided listenProvider).
 *
 * NOTE: Although SyncTree tracks event callbacks and calculates events to raise, the actual
 * events are returned to the caller rather than raised synchronously.
 *
 */
var SyncTree = /** @class */ (function () {
    /**
     * @param listenProvider_ - Used by SyncTree to start / stop listening
     *   to server data.
     */
    function SyncTree(listenProvider_) {
        this.listenProvider_ = listenProvider_;
        /**
         * Tree of SyncPoints.  There's a SyncPoint at any location that has 1 or more views.
         */
        this.syncPointTree_ = new ImmutableTree(null);
        /**
         * A tree of all pending user writes (user-initiated set()'s, transaction()'s, update()'s, etc.).
         */
        this.pendingWriteTree_ = newWriteTree();
        this.tagToQueryMap = new Map();
        this.queryToTagMap = new Map();
    }
    return SyncTree;
}());
/**
 * Apply the data changes for a user-generated set() or transaction() call.
 *
 * @returns Events to raise.
 */
function syncTreeApplyUserOverwrite(syncTree, path, newData, writeId, visible) {
    // Record pending write.
    writeTreeAddOverwrite(syncTree.pendingWriteTree_, path, newData, writeId, visible);
    if (!visible) {
        return [];
    }
    else {
        return syncTreeApplyOperationToSyncPoints_(syncTree, new Overwrite(newOperationSourceUser(), path, newData));
    }
}
/**
 * Apply the data from a user-generated update() call
 *
 * @returns Events to raise.
 */
function syncTreeApplyUserMerge(syncTree, path, changedChildren, writeId) {
    // Record pending merge.
    writeTreeAddMerge(syncTree.pendingWriteTree_, path, changedChildren, writeId);
    var changeTree = ImmutableTree.fromObject(changedChildren);
    return syncTreeApplyOperationToSyncPoints_(syncTree, new Merge(newOperationSourceUser(), path, changeTree));
}
/**
 * Acknowledge a pending user write that was previously registered with applyUserOverwrite() or applyUserMerge().
 *
 * @param revert - True if the given write failed and needs to be reverted
 * @returns Events to raise.
 */
function syncTreeAckUserWrite(syncTree, writeId, revert) {
    if (revert === void 0) { revert = false; }
    var write = writeTreeGetWrite(syncTree.pendingWriteTree_, writeId);
    var needToReevaluate = writeTreeRemoveWrite(syncTree.pendingWriteTree_, writeId);
    if (!needToReevaluate) {
        return [];
    }
    else {
        var affectedTree_1 = new ImmutableTree(null);
        if (write.snap != null) {
            // overwrite
            affectedTree_1 = affectedTree_1.set(newEmptyPath(), true);
        }
        else {
            each(write.children, function (pathString) {
                affectedTree_1 = affectedTree_1.set(new Path(pathString), true);
            });
        }
        return syncTreeApplyOperationToSyncPoints_(syncTree, new AckUserWrite(write.path, affectedTree_1, revert));
    }
}
/**
 * Apply new server data for the specified path..
 *
 * @returns Events to raise.
 */
function syncTreeApplyServerOverwrite(syncTree, path, newData) {
    return syncTreeApplyOperationToSyncPoints_(syncTree, new Overwrite(newOperationSourceServer(), path, newData));
}
/**
 * Apply new server data to be merged in at the specified path.
 *
 * @returns Events to raise.
 */
function syncTreeApplyServerMerge(syncTree, path, changedChildren) {
    var changeTree = ImmutableTree.fromObject(changedChildren);
    return syncTreeApplyOperationToSyncPoints_(syncTree, new Merge(newOperationSourceServer(), path, changeTree));
}
/**
 * Apply a listen complete for a query
 *
 * @returns Events to raise.
 */
function syncTreeApplyListenComplete(syncTree, path) {
    return syncTreeApplyOperationToSyncPoints_(syncTree, new ListenComplete(newOperationSourceServer(), path));
}
/**
 * Apply a listen complete for a tagged query
 *
 * @returns Events to raise.
 */
function syncTreeApplyTaggedListenComplete(syncTree, path, tag) {
    var queryKey = syncTreeQueryKeyForTag_(syncTree, tag);
    if (queryKey) {
        var r = syncTreeParseQueryKey_(queryKey);
        var queryPath = r.path, queryId = r.queryId;
        var relativePath = newRelativePath(queryPath, path);
        var op = new ListenComplete(newOperationSourceServerTaggedQuery(queryId), relativePath);
        return syncTreeApplyTaggedOperation_(syncTree, queryPath, op);
    }
    else {
        // We've already removed the query. No big deal, ignore the update
        return [];
    }
}
/**
 * Remove event callback(s).
 *
 * If query is the default query, we'll check all queries for the specified eventRegistration.
 * If eventRegistration is null, we'll remove all callbacks for the specified query/queries.
 *
 * @param eventRegistration - If null, all callbacks are removed.
 * @param cancelError - If a cancelError is provided, appropriate cancel events will be returned.
 * @param skipListenerDedup - When performing a `get()`, we don't add any new listeners, so no
 *  deduping needs to take place. This flag allows toggling of that behavior
 * @returns Cancel events, if cancelError was provided.
 */
function syncTreeRemoveEventRegistration(syncTree, query, eventRegistration, cancelError, skipListenerDedup) {
    if (skipListenerDedup === void 0) { skipListenerDedup = false; }
    // Find the syncPoint first. Then deal with whether or not it has matching listeners
    var path = query._path;
    var maybeSyncPoint = syncTree.syncPointTree_.get(path);
    var cancelEvents = [];
    // A removal on a default query affects all queries at that location. A removal on an indexed query, even one without
    // other query constraints, does *not* affect all queries at that location. So this check must be for 'default', and
    // not loadsAllData().
    if (maybeSyncPoint &&
        (query._queryIdentifier === 'default' ||
            syncPointViewExistsForQuery(maybeSyncPoint, query))) {
        var removedAndEvents = syncPointRemoveEventRegistration(maybeSyncPoint, query, eventRegistration, cancelError);
        if (syncPointIsEmpty(maybeSyncPoint)) {
            syncTree.syncPointTree_ = syncTree.syncPointTree_.remove(path);
        }
        var removed = removedAndEvents.removed;
        cancelEvents = removedAndEvents.events;
        if (!skipListenerDedup) {
            /**
             * We may have just removed one of many listeners and can short-circuit this whole process
             * We may also not have removed a default listener, in which case all of the descendant listeners should already be
             * properly set up.
             */
            // Since indexed queries can shadow if they don't have other query constraints, check for loadsAllData(), instead of
            // queryId === 'default'
            var removingDefault = -1 !==
                removed.findIndex(function (query) {
                    return query._queryParams.loadsAllData();
                });
            var covered = syncTree.syncPointTree_.findOnPath(path, function (relativePath, parentSyncPoint) {
                return syncPointHasCompleteView(parentSyncPoint);
            });
            if (removingDefault && !covered) {
                var subtree = syncTree.syncPointTree_.subtree(path);
                // There are potentially child listeners. Determine what if any listens we need to send before executing the
                // removal
                if (!subtree.isEmpty()) {
                    // We need to fold over our subtree and collect the listeners to send
                    var newViews = syncTreeCollectDistinctViewsForSubTree_(subtree);
                    // Ok, we've collected all the listens we need. Set them up.
                    for (var i = 0; i < newViews.length; ++i) {
                        var view = newViews[i], newQuery = view.query;
                        var listener = syncTreeCreateListenerForView_(syncTree, view);
                        syncTree.listenProvider_.startListening(syncTreeQueryForListening_(newQuery), syncTreeTagForQuery(syncTree, newQuery), listener.hashFn, listener.onComplete);
                    }
                }
                // Otherwise there's nothing below us, so nothing we need to start listening on
            }
            // If we removed anything and we're not covered by a higher up listen, we need to stop listening on this query
            // The above block has us covered in terms of making sure we're set up on listens lower in the tree.
            // Also, note that if we have a cancelError, it's already been removed at the provider level.
            if (!covered && removed.length > 0 && !cancelError) {
                // If we removed a default, then we weren't listening on any of the other queries here. Just cancel the one
                // default. Otherwise, we need to iterate through and cancel each individual query
                if (removingDefault) {
                    // We don't tag default listeners
                    var defaultTag = null;
                    syncTree.listenProvider_.stopListening(syncTreeQueryForListening_(query), defaultTag);
                }
                else {
                    removed.forEach(function (queryToRemove) {
                        var tagToRemove = syncTree.queryToTagMap.get(syncTreeMakeQueryKey_(queryToRemove));
                        syncTree.listenProvider_.stopListening(syncTreeQueryForListening_(queryToRemove), tagToRemove);
                    });
                }
            }
        }
        // Now, clear all of the tags we're tracking for the removed listens
        syncTreeRemoveTags_(syncTree, removed);
    }
    return cancelEvents;
}
/**
 * Apply new server data for the specified tagged query.
 *
 * @returns Events to raise.
 */
function syncTreeApplyTaggedQueryOverwrite(syncTree, path, snap, tag) {
    var queryKey = syncTreeQueryKeyForTag_(syncTree, tag);
    if (queryKey != null) {
        var r = syncTreeParseQueryKey_(queryKey);
        var queryPath = r.path, queryId = r.queryId;
        var relativePath = newRelativePath(queryPath, path);
        var op = new Overwrite(newOperationSourceServerTaggedQuery(queryId), relativePath, snap);
        return syncTreeApplyTaggedOperation_(syncTree, queryPath, op);
    }
    else {
        // Query must have been removed already
        return [];
    }
}
/**
 * Apply server data to be merged in for the specified tagged query.
 *
 * @returns Events to raise.
 */
function syncTreeApplyTaggedQueryMerge(syncTree, path, changedChildren, tag) {
    var queryKey = syncTreeQueryKeyForTag_(syncTree, tag);
    if (queryKey) {
        var r = syncTreeParseQueryKey_(queryKey);
        var queryPath = r.path, queryId = r.queryId;
        var relativePath = newRelativePath(queryPath, path);
        var changeTree = ImmutableTree.fromObject(changedChildren);
        var op = new Merge(newOperationSourceServerTaggedQuery(queryId), relativePath, changeTree);
        return syncTreeApplyTaggedOperation_(syncTree, queryPath, op);
    }
    else {
        // We've already removed the query. No big deal, ignore the update
        return [];
    }
}
/**
 * Add an event callback for the specified query.
 *
 * @returns Events to raise.
 */
function syncTreeAddEventRegistration(syncTree, query, eventRegistration, skipSetupListener) {
    if (skipSetupListener === void 0) { skipSetupListener = false; }
    var path = query._path;
    var serverCache = null;
    var foundAncestorDefaultView = false;
    // Any covering writes will necessarily be at the root, so really all we need to find is the server cache.
    // Consider optimizing this once there's a better understanding of what actual behavior will be.
    syncTree.syncPointTree_.foreachOnPath(path, function (pathToSyncPoint, sp) {
        var relativePath = newRelativePath(pathToSyncPoint, path);
        serverCache =
            serverCache || syncPointGetCompleteServerCache(sp, relativePath);
        foundAncestorDefaultView =
            foundAncestorDefaultView || syncPointHasCompleteView(sp);
    });
    var syncPoint = syncTree.syncPointTree_.get(path);
    if (!syncPoint) {
        syncPoint = new SyncPoint();
        syncTree.syncPointTree_ = syncTree.syncPointTree_.set(path, syncPoint);
    }
    else {
        foundAncestorDefaultView =
            foundAncestorDefaultView || syncPointHasCompleteView(syncPoint);
        serverCache =
            serverCache || syncPointGetCompleteServerCache(syncPoint, newEmptyPath());
    }
    var serverCacheComplete;
    if (serverCache != null) {
        serverCacheComplete = true;
    }
    else {
        serverCacheComplete = false;
        serverCache = ChildrenNode.EMPTY_NODE;
        var subtree = syncTree.syncPointTree_.subtree(path);
        subtree.foreachChild(function (childName, childSyncPoint) {
            var completeCache = syncPointGetCompleteServerCache(childSyncPoint, newEmptyPath());
            if (completeCache) {
                serverCache = serverCache.updateImmediateChild(childName, completeCache);
            }
        });
    }
    var viewAlreadyExists = syncPointViewExistsForQuery(syncPoint, query);
    if (!viewAlreadyExists && !query._queryParams.loadsAllData()) {
        // We need to track a tag for this query
        var queryKey = syncTreeMakeQueryKey_(query);
        assert(!syncTree.queryToTagMap.has(queryKey), 'View does not exist, but we have a tag');
        var tag = syncTreeGetNextQueryTag_();
        syncTree.queryToTagMap.set(queryKey, tag);
        syncTree.tagToQueryMap.set(tag, queryKey);
    }
    var writesCache = writeTreeChildWrites(syncTree.pendingWriteTree_, path);
    var events = syncPointAddEventRegistration(syncPoint, query, eventRegistration, writesCache, serverCache, serverCacheComplete);
    if (!viewAlreadyExists && !foundAncestorDefaultView && !skipSetupListener) {
        var view = syncPointViewForQuery(syncPoint, query);
        events = events.concat(syncTreeSetupListener_(syncTree, query, view));
    }
    return events;
}
/**
 * Returns a complete cache, if we have one, of the data at a particular path. If the location does not have a
 * listener above it, we will get a false "null". This shouldn't be a problem because transactions will always
 * have a listener above, and atomic operations would correctly show a jitter of <increment value> ->
 *     <incremented total> as the write is applied locally and then acknowledged at the server.
 *
 * Note: this method will *include* hidden writes from transaction with applyLocally set to false.
 *
 * @param path - The path to the data we want
 * @param writeIdsToExclude - A specific set to be excluded
 */
function syncTreeCalcCompleteEventCache(syncTree, path, writeIdsToExclude) {
    var includeHiddenSets = true;
    var writeTree = syncTree.pendingWriteTree_;
    var serverCache = syncTree.syncPointTree_.findOnPath(path, function (pathSoFar, syncPoint) {
        var relativePath = newRelativePath(pathSoFar, path);
        var serverCache = syncPointGetCompleteServerCache(syncPoint, relativePath);
        if (serverCache) {
            return serverCache;
        }
    });
    return writeTreeCalcCompleteEventCache(writeTree, path, serverCache, writeIdsToExclude, includeHiddenSets);
}
function syncTreeGetServerValue(syncTree, query) {
    var path = query._path;
    var serverCache = null;
    // Any covering writes will necessarily be at the root, so really all we need to find is the server cache.
    // Consider optimizing this once there's a better understanding of what actual behavior will be.
    syncTree.syncPointTree_.foreachOnPath(path, function (pathToSyncPoint, sp) {
        var relativePath = newRelativePath(pathToSyncPoint, path);
        serverCache =
            serverCache || syncPointGetCompleteServerCache(sp, relativePath);
    });
    var syncPoint = syncTree.syncPointTree_.get(path);
    if (!syncPoint) {
        syncPoint = new SyncPoint();
        syncTree.syncPointTree_ = syncTree.syncPointTree_.set(path, syncPoint);
    }
    else {
        serverCache =
            serverCache || syncPointGetCompleteServerCache(syncPoint, newEmptyPath());
    }
    var serverCacheComplete = serverCache != null;
    var serverCacheNode = serverCacheComplete
        ? new CacheNode(serverCache, true, false)
        : null;
    var writesCache = writeTreeChildWrites(syncTree.pendingWriteTree_, query._path);
    var view = syncPointGetView(syncPoint, query, writesCache, serverCacheComplete ? serverCacheNode.getNode() : ChildrenNode.EMPTY_NODE, serverCacheComplete);
    return viewGetCompleteNode(view);
}
/**
 * A helper method that visits all descendant and ancestor SyncPoints, applying the operation.
 *
 * NOTES:
 * - Descendant SyncPoints will be visited first (since we raise events depth-first).
 *
 * - We call applyOperation() on each SyncPoint passing three things:
 *   1. A version of the Operation that has been made relative to the SyncPoint location.
 *   2. A WriteTreeRef of any writes we have cached at the SyncPoint location.
 *   3. A snapshot Node with cached server data, if we have it.
 *
 * - We concatenate all of the events returned by each SyncPoint and return the result.
 */
function syncTreeApplyOperationToSyncPoints_(syncTree, operation) {
    return syncTreeApplyOperationHelper_(operation, syncTree.syncPointTree_, 
    /*serverCache=*/ null, writeTreeChildWrites(syncTree.pendingWriteTree_, newEmptyPath()));
}
/**
 * Recursive helper for applyOperationToSyncPoints_
 */
function syncTreeApplyOperationHelper_(operation, syncPointTree, serverCache, writesCache) {
    if (pathIsEmpty(operation.path)) {
        return syncTreeApplyOperationDescendantsHelper_(operation, syncPointTree, serverCache, writesCache);
    }
    else {
        var syncPoint = syncPointTree.get(newEmptyPath());
        // If we don't have cached server data, see if we can get it from this SyncPoint.
        if (serverCache == null && syncPoint != null) {
            serverCache = syncPointGetCompleteServerCache(syncPoint, newEmptyPath());
        }
        var events = [];
        var childName = pathGetFront(operation.path);
        var childOperation = operation.operationForChild(childName);
        var childTree = syncPointTree.children.get(childName);
        if (childTree && childOperation) {
            var childServerCache = serverCache
                ? serverCache.getImmediateChild(childName)
                : null;
            var childWritesCache = writeTreeRefChild(writesCache, childName);
            events = events.concat(syncTreeApplyOperationHelper_(childOperation, childTree, childServerCache, childWritesCache));
        }
        if (syncPoint) {
            events = events.concat(syncPointApplyOperation(syncPoint, operation, writesCache, serverCache));
        }
        return events;
    }
}
/**
 * Recursive helper for applyOperationToSyncPoints_
 */
function syncTreeApplyOperationDescendantsHelper_(operation, syncPointTree, serverCache, writesCache) {
    var syncPoint = syncPointTree.get(newEmptyPath());
    // If we don't have cached server data, see if we can get it from this SyncPoint.
    if (serverCache == null && syncPoint != null) {
        serverCache = syncPointGetCompleteServerCache(syncPoint, newEmptyPath());
    }
    var events = [];
    syncPointTree.children.inorderTraversal(function (childName, childTree) {
        var childServerCache = serverCache
            ? serverCache.getImmediateChild(childName)
            : null;
        var childWritesCache = writeTreeRefChild(writesCache, childName);
        var childOperation = operation.operationForChild(childName);
        if (childOperation) {
            events = events.concat(syncTreeApplyOperationDescendantsHelper_(childOperation, childTree, childServerCache, childWritesCache));
        }
    });
    if (syncPoint) {
        events = events.concat(syncPointApplyOperation(syncPoint, operation, writesCache, serverCache));
    }
    return events;
}
function syncTreeCreateListenerForView_(syncTree, view) {
    var query = view.query;
    var tag = syncTreeTagForQuery(syncTree, query);
    return {
        hashFn: function () {
            var cache = viewGetServerCache(view) || ChildrenNode.EMPTY_NODE;
            return cache.hash();
        },
        onComplete: function (status) {
            if (status === 'ok') {
                if (tag) {
                    return syncTreeApplyTaggedListenComplete(syncTree, query._path, tag);
                }
                else {
                    return syncTreeApplyListenComplete(syncTree, query._path);
                }
            }
            else {
                // If a listen failed, kill all of the listeners here, not just the one that triggered the error.
                // Note that this may need to be scoped to just this listener if we change permissions on filtered children
                var error = errorForServerCode(status, query);
                return syncTreeRemoveEventRegistration(syncTree, query, 
                /*eventRegistration*/ null, error);
            }
        }
    };
}
/**
 * Return the tag associated with the given query.
 */
function syncTreeTagForQuery(syncTree, query) {
    var queryKey = syncTreeMakeQueryKey_(query);
    return syncTree.queryToTagMap.get(queryKey);
}
/**
 * Given a query, computes a "queryKey" suitable for use in our queryToTagMap_.
 */
function syncTreeMakeQueryKey_(query) {
    return query._path.toString() + '$' + query._queryIdentifier;
}
/**
 * Return the query associated with the given tag, if we have one
 */
function syncTreeQueryKeyForTag_(syncTree, tag) {
    return syncTree.tagToQueryMap.get(tag);
}
/**
 * Given a queryKey (created by makeQueryKey), parse it back into a path and queryId.
 */
function syncTreeParseQueryKey_(queryKey) {
    var splitIndex = queryKey.indexOf('$');
    assert(splitIndex !== -1 && splitIndex < queryKey.length - 1, 'Bad queryKey.');
    return {
        queryId: queryKey.substr(splitIndex + 1),
        path: new Path(queryKey.substr(0, splitIndex))
    };
}
/**
 * A helper method to apply tagged operations
 */
function syncTreeApplyTaggedOperation_(syncTree, queryPath, operation) {
    var syncPoint = syncTree.syncPointTree_.get(queryPath);
    assert(syncPoint, "Missing sync point for query tag that we're tracking");
    var writesCache = writeTreeChildWrites(syncTree.pendingWriteTree_, queryPath);
    return syncPointApplyOperation(syncPoint, operation, writesCache, null);
}
/**
 * This collapses multiple unfiltered views into a single view, since we only need a single
 * listener for them.
 */
function syncTreeCollectDistinctViewsForSubTree_(subtree) {
    return subtree.fold(function (relativePath, maybeChildSyncPoint, childMap) {
        if (maybeChildSyncPoint && syncPointHasCompleteView(maybeChildSyncPoint)) {
            var completeView = syncPointGetCompleteView(maybeChildSyncPoint);
            return [completeView];
        }
        else {
            // No complete view here, flatten any deeper listens into an array
            var views_1 = [];
            if (maybeChildSyncPoint) {
                views_1 = syncPointGetQueryViews(maybeChildSyncPoint);
            }
            each(childMap, function (_key, childViews) {
                views_1 = views_1.concat(childViews);
            });
            return views_1;
        }
    });
}
/**
 * Normalizes a query to a query we send the server for listening
 *
 * @returns The normalized query
 */
function syncTreeQueryForListening_(query) {
    if (query._queryParams.loadsAllData() && !query._queryParams.isDefault()) {
        // We treat queries that load all data as default queries
        // Cast is necessary because ref() technically returns Firebase which is actually fb.api.Firebase which inherits
        // from Query
        return new (syncTreeGetReferenceConstructor())(query._repo, query._path);
    }
    else {
        return query;
    }
}
function syncTreeRemoveTags_(syncTree, queries) {
    for (var j = 0; j < queries.length; ++j) {
        var removedQuery = queries[j];
        if (!removedQuery._queryParams.loadsAllData()) {
            // We should have a tag for this
            var removedQueryKey = syncTreeMakeQueryKey_(removedQuery);
            var removedQueryTag = syncTree.queryToTagMap.get(removedQueryKey);
            syncTree.queryToTagMap.delete(removedQueryKey);
            syncTree.tagToQueryMap.delete(removedQueryTag);
        }
    }
}
/**
 * Static accessor for query tags.
 */
function syncTreeGetNextQueryTag_() {
    return syncTreeNextQueryTag_++;
}
/**
 * For a given new listen, manage the de-duplication of outstanding subscriptions.
 *
 * @returns This method can return events to support synchronous data sources
 */
function syncTreeSetupListener_(syncTree, query, view) {
    var path = query._path;
    var tag = syncTreeTagForQuery(syncTree, query);
    var listener = syncTreeCreateListenerForView_(syncTree, view);
    var events = syncTree.listenProvider_.startListening(syncTreeQueryForListening_(query), tag, listener.hashFn, listener.onComplete);
    var subtree = syncTree.syncPointTree_.subtree(path);
    // The root of this subtree has our query. We're here because we definitely need to send a listen for that, but we
    // may need to shadow other listens as well.
    if (tag) {
        assert(!syncPointHasCompleteView(subtree.value), "If we're adding a query, it shouldn't be shadowed");
    }
    else {
        // Shadow everything at or below this location, this is a default listener.
        var queriesToStop = subtree.fold(function (relativePath, maybeChildSyncPoint, childMap) {
            if (!pathIsEmpty(relativePath) &&
                maybeChildSyncPoint &&
                syncPointHasCompleteView(maybeChildSyncPoint)) {
                return [syncPointGetCompleteView(maybeChildSyncPoint).query];
            }
            else {
                // No default listener here, flatten any deeper queries into an array
                var queries_1 = [];
                if (maybeChildSyncPoint) {
                    queries_1 = queries_1.concat(syncPointGetQueryViews(maybeChildSyncPoint).map(function (view) { return view.query; }));
                }
                each(childMap, function (_key, childQueries) {
                    queries_1 = queries_1.concat(childQueries);
                });
                return queries_1;
            }
        });
        for (var i = 0; i < queriesToStop.length; ++i) {
            var queryToStop = queriesToStop[i];
            syncTree.listenProvider_.stopListening(syncTreeQueryForListening_(queryToStop), syncTreeTagForQuery(syncTree, queryToStop));
        }
    }
    return events;
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var ExistingValueProvider = /** @class */ (function () {
    function ExistingValueProvider(node_) {
        this.node_ = node_;
    }
    ExistingValueProvider.prototype.getImmediateChild = function (childName) {
        var child = this.node_.getImmediateChild(childName);
        return new ExistingValueProvider(child);
    };
    ExistingValueProvider.prototype.node = function () {
        return this.node_;
    };
    return ExistingValueProvider;
}());
var DeferredValueProvider = /** @class */ (function () {
    function DeferredValueProvider(syncTree, path) {
        this.syncTree_ = syncTree;
        this.path_ = path;
    }
    DeferredValueProvider.prototype.getImmediateChild = function (childName) {
        var childPath = pathChild(this.path_, childName);
        return new DeferredValueProvider(this.syncTree_, childPath);
    };
    DeferredValueProvider.prototype.node = function () {
        return syncTreeCalcCompleteEventCache(this.syncTree_, this.path_);
    };
    return DeferredValueProvider;
}());
/**
 * Generate placeholders for deferred values.
 */
var generateWithValues = function (values) {
    values = values || {};
    values['timestamp'] = values['timestamp'] || new Date().getTime();
    return values;
};
/**
 * Value to use when firing local events. When writing server values, fire
 * local events with an approximate value, otherwise return value as-is.
 */
var resolveDeferredLeafValue = function (value, existingVal, serverValues) {
    if (!value || typeof value !== 'object') {
        return value;
    }
    assert('.sv' in value, 'Unexpected leaf node or priority contents');
    if (typeof value['.sv'] === 'string') {
        return resolveScalarDeferredValue(value['.sv'], existingVal, serverValues);
    }
    else if (typeof value['.sv'] === 'object') {
        return resolveComplexDeferredValue(value['.sv'], existingVal);
    }
    else {
        assert(false, 'Unexpected server value: ' + JSON.stringify(value, null, 2));
    }
};
var resolveScalarDeferredValue = function (op, existing, serverValues) {
    switch (op) {
        case 'timestamp':
            return serverValues['timestamp'];
        default:
            assert(false, 'Unexpected server value: ' + op);
    }
};
var resolveComplexDeferredValue = function (op, existing, unused) {
    if (!op.hasOwnProperty('increment')) {
        assert(false, 'Unexpected server value: ' + JSON.stringify(op, null, 2));
    }
    var delta = op['increment'];
    if (typeof delta !== 'number') {
        assert(false, 'Unexpected increment value: ' + delta);
    }
    var existingNode = existing.node();
    assert(existingNode !== null && typeof existingNode !== 'undefined', 'Expected ChildrenNode.EMPTY_NODE for nulls');
    // Incrementing a non-number sets the value to the incremented amount
    if (!existingNode.isLeafNode()) {
        return delta;
    }
    var leaf = existingNode;
    var existingVal = leaf.getValue();
    if (typeof existingVal !== 'number') {
        return delta;
    }
    // No need to do over/underflow arithmetic here because JS only handles floats under the covers
    return existingVal + delta;
};
/**
 * Recursively replace all deferred values and priorities in the tree with the
 * specified generated replacement values.
 * @param path - path to which write is relative
 * @param node - new data written at path
 * @param syncTree - current data
 */
var resolveDeferredValueTree = function (path, node, syncTree, serverValues) {
    return resolveDeferredValue(node, new DeferredValueProvider(syncTree, path), serverValues);
};
/**
 * Recursively replace all deferred values and priorities in the node with the
 * specified generated replacement values.  If there are no server values in the node,
 * it'll be returned as-is.
 */
var resolveDeferredValueSnapshot = function (node, existing, serverValues) {
    return resolveDeferredValue(node, new ExistingValueProvider(existing), serverValues);
};
function resolveDeferredValue(node, existingVal, serverValues) {
    var rawPri = node.getPriority().val();
    var priority = resolveDeferredLeafValue(rawPri, existingVal.getImmediateChild('.priority'), serverValues);
    var newNode;
    if (node.isLeafNode()) {
        var leafNode = node;
        var value = resolveDeferredLeafValue(leafNode.getValue(), existingVal, serverValues);
        if (value !== leafNode.getValue() ||
            priority !== leafNode.getPriority().val()) {
            return new LeafNode(value, nodeFromJSON(priority));
        }
        else {
            return node;
        }
    }
    else {
        var childrenNode = node;
        newNode = childrenNode;
        if (priority !== childrenNode.getPriority().val()) {
            newNode = newNode.updatePriority(new LeafNode(priority));
        }
        childrenNode.forEachChild(PRIORITY_INDEX, function (childName, childNode) {
            var newChildNode = resolveDeferredValue(childNode, existingVal.getImmediateChild(childName), serverValues);
            if (newChildNode !== childNode) {
                newNode = newNode.updateImmediateChild(childName, newChildNode);
            }
        });
        return newNode;
    }
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * A light-weight tree, traversable by path.  Nodes can have both values and children.
 * Nodes are not enumerated (by forEachChild) unless they have a value or non-empty
 * children.
 */
var Tree = /** @class */ (function () {
    /**
     * @param name - Optional name of the node.
     * @param parent - Optional parent node.
     * @param node - Optional node to wrap.
     */
    function Tree(name, parent, node) {
        if (name === void 0) { name = ''; }
        if (parent === void 0) { parent = null; }
        if (node === void 0) { node = { children: {}, childCount: 0 }; }
        this.name = name;
        this.parent = parent;
        this.node = node;
    }
    return Tree;
}());
/**
 * Returns a sub-Tree for the given path.
 *
 * @param pathObj - Path to look up.
 * @returns Tree for path.
 */
function treeSubTree(tree, pathObj) {
    // TODO: Require pathObj to be Path?
    var path = pathObj instanceof Path ? pathObj : new Path(pathObj);
    var child = tree, next = pathGetFront(path);
    while (next !== null) {
        var childNode = safeGet(child.node.children, next) || {
            children: {},
            childCount: 0
        };
        child = new Tree(next, child, childNode);
        path = pathPopFront(path);
        next = pathGetFront(path);
    }
    return child;
}
/**
 * Returns the data associated with this tree node.
 *
 * @returns The data or null if no data exists.
 */
function treeGetValue(tree) {
    return tree.node.value;
}
/**
 * Sets data to this tree node.
 *
 * @param value - Value to set.
 */
function treeSetValue(tree, value) {
    tree.node.value = value;
    treeUpdateParents(tree);
}
/**
 * @returns Whether the tree has any children.
 */
function treeHasChildren(tree) {
    return tree.node.childCount > 0;
}
/**
 * @returns Whethe rthe tree is empty (no value or children).
 */
function treeIsEmpty(tree) {
    return treeGetValue(tree) === undefined && !treeHasChildren(tree);
}
/**
 * Calls action for each child of this tree node.
 *
 * @param action - Action to be called for each child.
 */
function treeForEachChild(tree, action) {
    each(tree.node.children, function (child, childTree) {
        action(new Tree(child, tree, childTree));
    });
}
/**
 * Does a depth-first traversal of this node's descendants, calling action for each one.
 *
 * @param action - Action to be called for each child.
 * @param includeSelf - Whether to call action on this node as well. Defaults to
 *   false.
 * @param childrenFirst - Whether to call action on children before calling it on
 *   parent.
 */
function treeForEachDescendant(tree, action, includeSelf, childrenFirst) {
    if (includeSelf && !childrenFirst) {
        action(tree);
    }
    treeForEachChild(tree, function (child) {
        treeForEachDescendant(child, action, true, childrenFirst);
    });
    if (includeSelf && childrenFirst) {
        action(tree);
    }
}
/**
 * Calls action on each ancestor node.
 *
 * @param action - Action to be called on each parent; return
 *   true to abort.
 * @param includeSelf - Whether to call action on this node as well.
 * @returns true if the action callback returned true.
 */
function treeForEachAncestor(tree, action, includeSelf) {
    var node = includeSelf ? tree : tree.parent;
    while (node !== null) {
        if (action(node)) {
            return true;
        }
        node = node.parent;
    }
    return false;
}
/**
 * @returns The path of this tree node, as a Path.
 */
function treeGetPath(tree) {
    return new Path(tree.parent === null
        ? tree.name
        : treeGetPath(tree.parent) + '/' + tree.name);
}
/**
 * Adds or removes this child from its parent based on whether it's empty or not.
 */
function treeUpdateParents(tree) {
    if (tree.parent !== null) {
        treeUpdateChild(tree.parent, tree.name, tree);
    }
}
/**
 * Adds or removes the passed child to this tree node, depending on whether it's empty.
 *
 * @param childName - The name of the child to update.
 * @param child - The child to update.
 */
function treeUpdateChild(tree, childName, child) {
    var childEmpty = treeIsEmpty(child);
    var childExists = contains(tree.node.children, childName);
    if (childEmpty && childExists) {
        delete tree.node.children[childName];
        tree.node.childCount--;
        treeUpdateParents(tree);
    }
    else if (!childEmpty && !childExists) {
        tree.node.children[childName] = child.node;
        tree.node.childCount++;
        treeUpdateParents(tree);
    }
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * True for invalid Firebase keys
 */
var INVALID_KEY_REGEX_ = /[\[\].#$\/\u0000-\u001F\u007F]/;
/**
 * True for invalid Firebase paths.
 * Allows '/' in paths.
 */
var INVALID_PATH_REGEX_ = /[\[\].#$\u0000-\u001F\u007F]/;
/**
 * Maximum number of characters to allow in leaf value
 */
var MAX_LEAF_SIZE_ = 10 * 1024 * 1024;
var isValidKey = function (key) {
    return (typeof key === 'string' && key.length !== 0 && !INVALID_KEY_REGEX_.test(key));
};
var isValidPathString = function (pathString) {
    return (typeof pathString === 'string' &&
        pathString.length !== 0 &&
        !INVALID_PATH_REGEX_.test(pathString));
};
var isValidRootPathString = function (pathString) {
    if (pathString) {
        // Allow '/.info/' at the beginning.
        pathString = pathString.replace(/^\/*\.info(\/|$)/, '/');
    }
    return isValidPathString(pathString);
};
var isValidPriority = function (priority) {
    return (priority === null ||
        typeof priority === 'string' ||
        (typeof priority === 'number' && !isInvalidJSONNumber(priority)) ||
        (priority &&
            typeof priority === 'object' &&
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            contains(priority, '.sv')));
};
/**
 * Pre-validate a datum passed as an argument to Firebase function.
 */
var validateFirebaseDataArg = function (fnName, value, path, optional) {
    if (optional && value === undefined) {
        return;
    }
    validateFirebaseData(errorPrefix(fnName, 'value'), value, path);
};
/**
 * Validate a data object client-side before sending to server.
 */
var validateFirebaseData = function (errorPrefix, data, path_) {
    var path = path_ instanceof Path ? new ValidationPath(path_, errorPrefix) : path_;
    if (data === undefined) {
        throw new Error(errorPrefix + 'contains undefined ' + validationPathToErrorString(path));
    }
    if (typeof data === 'function') {
        throw new Error(errorPrefix +
            'contains a function ' +
            validationPathToErrorString(path) +
            ' with contents = ' +
            data.toString());
    }
    if (isInvalidJSONNumber(data)) {
        throw new Error(errorPrefix +
            'contains ' +
            data.toString() +
            ' ' +
            validationPathToErrorString(path));
    }
    // Check max leaf size, but try to avoid the utf8 conversion if we can.
    if (typeof data === 'string' &&
        data.length > MAX_LEAF_SIZE_ / 3 &&
        stringLength(data) > MAX_LEAF_SIZE_) {
        throw new Error(errorPrefix +
            'contains a string greater than ' +
            MAX_LEAF_SIZE_ +
            ' utf8 bytes ' +
            validationPathToErrorString(path) +
            " ('" +
            data.substring(0, 50) +
            "...')");
    }
    // TODO = Perf = Consider combining the recursive validation of keys into NodeFromJSON
    // to save extra walking of large objects.
    if (data && typeof data === 'object') {
        var hasDotValue_1 = false;
        var hasActualChild_1 = false;
        each(data, function (key, value) {
            if (key === '.value') {
                hasDotValue_1 = true;
            }
            else if (key !== '.priority' && key !== '.sv') {
                hasActualChild_1 = true;
                if (!isValidKey(key)) {
                    throw new Error(errorPrefix +
                        ' contains an invalid key (' +
                        key +
                        ') ' +
                        validationPathToErrorString(path) +
                        '.  Keys must be non-empty strings ' +
                        'and can\'t contain ".", "#", "$", "/", "[", or "]"');
                }
            }
            validationPathPush(path, key);
            validateFirebaseData(errorPrefix, value, path);
            validationPathPop(path);
        });
        if (hasDotValue_1 && hasActualChild_1) {
            throw new Error(errorPrefix +
                ' contains ".value" child ' +
                validationPathToErrorString(path) +
                ' in addition to actual children.');
        }
    }
};
/**
 * Pre-validate paths passed in the firebase function.
 */
var validateFirebaseMergePaths = function (errorPrefix, mergePaths) {
    var i, curPath;
    for (i = 0; i < mergePaths.length; i++) {
        curPath = mergePaths[i];
        var keys = pathSlice(curPath);
        for (var j = 0; j < keys.length; j++) {
            if (keys[j] === '.priority' && j === keys.length - 1) ;
            else if (!isValidKey(keys[j])) {
                throw new Error(errorPrefix +
                    'contains an invalid key (' +
                    keys[j] +
                    ') in path ' +
                    curPath.toString() +
                    '. Keys must be non-empty strings ' +
                    'and can\'t contain ".", "#", "$", "/", "[", or "]"');
            }
        }
    }
    // Check that update keys are not descendants of each other.
    // We rely on the property that sorting guarantees that ancestors come
    // right before descendants.
    mergePaths.sort(pathCompare);
    var prevPath = null;
    for (i = 0; i < mergePaths.length; i++) {
        curPath = mergePaths[i];
        if (prevPath !== null && pathContains(prevPath, curPath)) {
            throw new Error(errorPrefix +
                'contains a path ' +
                prevPath.toString() +
                ' that is ancestor of another path ' +
                curPath.toString());
        }
        prevPath = curPath;
    }
};
/**
 * pre-validate an object passed as an argument to firebase function (
 * must be an object - e.g. for firebase.update()).
 */
var validateFirebaseMergeDataArg = function (fnName, data, path, optional) {
    if (optional && data === undefined) {
        return;
    }
    var errorPrefix$1 = errorPrefix(fnName, 'values');
    if (!(data && typeof data === 'object') || Array.isArray(data)) {
        throw new Error(errorPrefix$1 + ' must be an object containing the children to replace.');
    }
    var mergePaths = [];
    each(data, function (key, value) {
        var curPath = new Path(key);
        validateFirebaseData(errorPrefix$1, value, pathChild(path, curPath));
        if (pathGetBack(curPath) === '.priority') {
            if (!isValidPriority(value)) {
                throw new Error(errorPrefix$1 +
                    "contains an invalid value for '" +
                    curPath.toString() +
                    "', which must be a valid " +
                    'Firebase priority (a string, finite number, server value, or null).');
            }
        }
        mergePaths.push(curPath);
    });
    validateFirebaseMergePaths(errorPrefix$1, mergePaths);
};
var validatePriority = function (fnName, priority, optional) {
    if (optional && priority === undefined) {
        return;
    }
    if (isInvalidJSONNumber(priority)) {
        throw new Error(errorPrefix(fnName, 'priority') +
            'is ' +
            priority.toString() +
            ', but must be a valid Firebase priority (a string, finite number, ' +
            'server value, or null).');
    }
    // Special case to allow importing data with a .sv.
    if (!isValidPriority(priority)) {
        throw new Error(errorPrefix(fnName, 'priority') +
            'must be a valid Firebase priority ' +
            '(a string, finite number, server value, or null).');
    }
};
var validateKey = function (fnName, argumentName, key, optional) {
    if (optional && key === undefined) {
        return;
    }
    if (!isValidKey(key)) {
        throw new Error(errorPrefix(fnName, argumentName) +
            'was an invalid key = "' +
            key +
            '".  Firebase keys must be non-empty strings and ' +
            'can\'t contain ".", "#", "$", "/", "[", or "]").');
    }
};
/**
 * @internal
 */
var validatePathString = function (fnName, argumentName, pathString, optional) {
    if (optional && pathString === undefined) {
        return;
    }
    if (!isValidPathString(pathString)) {
        throw new Error(errorPrefix(fnName, argumentName) +
            'was an invalid path = "' +
            pathString +
            '". Paths must be non-empty strings and ' +
            'can\'t contain ".", "#", "$", "[", or "]"');
    }
};
var validateRootPathString = function (fnName, argumentName, pathString, optional) {
    if (pathString) {
        // Allow '/.info/' at the beginning.
        pathString = pathString.replace(/^\/*\.info(\/|$)/, '/');
    }
    validatePathString(fnName, argumentName, pathString, optional);
};
/**
 * @internal
 */
var validateWritablePath = function (fnName, path) {
    if (pathGetFront(path) === '.info') {
        throw new Error(fnName + " failed = Can't modify data under /.info/");
    }
};
var validateUrl = function (fnName, parsedUrl) {
    // TODO = Validate server better.
    var pathString = parsedUrl.path.toString();
    if (!(typeof parsedUrl.repoInfo.host === 'string') ||
        parsedUrl.repoInfo.host.length === 0 ||
        (!isValidKey(parsedUrl.repoInfo.namespace) &&
            parsedUrl.repoInfo.host.split(':')[0] !== 'localhost') ||
        (pathString.length !== 0 && !isValidRootPathString(pathString))) {
        throw new Error(errorPrefix(fnName, 'url') +
            'must be a valid firebase URL and ' +
            'the path can\'t contain ".", "#", "$", "[", or "]".');
    }
};

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * The event queue serves a few purposes:
 * 1. It ensures we maintain event order in the face of event callbacks doing operations that result in more
 *    events being queued.
 * 2. raiseQueuedEvents() handles being called reentrantly nicely.  That is, if in the course of raising events,
 *    raiseQueuedEvents() is called again, the "inner" call will pick up raising events where the "outer" call
 *    left off, ensuring that the events are still raised synchronously and in order.
 * 3. You can use raiseEventsAtPath and raiseEventsForChangedPath to ensure only relevant previously-queued
 *    events are raised synchronously.
 *
 * NOTE: This can all go away if/when we move to async events.
 *
 */
var EventQueue = /** @class */ (function () {
    function EventQueue() {
        this.eventLists_ = [];
        /**
         * Tracks recursion depth of raiseQueuedEvents_, for debugging purposes.
         */
        this.recursionDepth_ = 0;
    }
    return EventQueue;
}());
/**
 * @param eventDataList - The new events to queue.
 */
function eventQueueQueueEvents(eventQueue, eventDataList) {
    // We group events by path, storing them in a single EventList, to make it easier to skip over them quickly.
    var currList = null;
    for (var i = 0; i < eventDataList.length; i++) {
        var data = eventDataList[i];
        var path = data.getPath();
        if (currList !== null && !pathEquals(path, currList.path)) {
            eventQueue.eventLists_.push(currList);
            currList = null;
        }
        if (currList === null) {
            currList = { events: [], path: path };
        }
        currList.events.push(data);
    }
    if (currList) {
        eventQueue.eventLists_.push(currList);
    }
}
/**
 * Queues the specified events and synchronously raises all events (including previously queued ones)
 * for the specified path.
 *
 * It is assumed that the new events are all for the specified path.
 *
 * @param path - The path to raise events for.
 * @param eventDataList - The new events to raise.
 */
function eventQueueRaiseEventsAtPath(eventQueue, path, eventDataList) {
    eventQueueQueueEvents(eventQueue, eventDataList);
    eventQueueRaiseQueuedEventsMatchingPredicate(eventQueue, function (eventPath) {
        return pathEquals(eventPath, path);
    });
}
/**
 * Queues the specified events and synchronously raises all events (including previously queued ones) for
 * locations related to the specified change path (i.e. all ancestors and descendants).
 *
 * It is assumed that the new events are all related (ancestor or descendant) to the specified path.
 *
 * @param changedPath - The path to raise events for.
 * @param eventDataList - The events to raise
 */
function eventQueueRaiseEventsForChangedPath(eventQueue, changedPath, eventDataList) {
    eventQueueQueueEvents(eventQueue, eventDataList);
    eventQueueRaiseQueuedEventsMatchingPredicate(eventQueue, function (eventPath) {
        return pathContains(eventPath, changedPath) ||
            pathContains(changedPath, eventPath);
    });
}
function eventQueueRaiseQueuedEventsMatchingPredicate(eventQueue, predicate) {
    eventQueue.recursionDepth_++;
    var sentAll = true;
    for (var i = 0; i < eventQueue.eventLists_.length; i++) {
        var eventList = eventQueue.eventLists_[i];
        if (eventList) {
            var eventPath = eventList.path;
            if (predicate(eventPath)) {
                eventListRaise(eventQueue.eventLists_[i]);
                eventQueue.eventLists_[i] = null;
            }
            else {
                sentAll = false;
            }
        }
    }
    if (sentAll) {
        eventQueue.eventLists_ = [];
    }
    eventQueue.recursionDepth_--;
}
/**
 * Iterates through the list and raises each event
 */
function eventListRaise(eventList) {
    for (var i = 0; i < eventList.events.length; i++) {
        var eventData = eventList.events[i];
        if (eventData !== null) {
            eventList.events[i] = null;
            var eventFn = eventData.getEventRunner();
            if (logger) {
                log('event: ' + eventData.toString());
            }
            exceptionGuard(eventFn);
        }
    }
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var INTERRUPT_REASON = 'repo_interrupt';
/**
 * If a transaction does not succeed after 25 retries, we abort it. Among other
 * things this ensure that if there's ever a bug causing a mismatch between
 * client / server hashes for some data, we won't retry indefinitely.
 */
var MAX_TRANSACTION_RETRIES = 25;
/**
 * A connection to a single data repository.
 */
var Repo = /** @class */ (function () {
    function Repo(repoInfo_, forceRestClient_, authTokenProvider_, appCheckProvider_) {
        this.repoInfo_ = repoInfo_;
        this.forceRestClient_ = forceRestClient_;
        this.authTokenProvider_ = authTokenProvider_;
        this.appCheckProvider_ = appCheckProvider_;
        this.dataUpdateCount = 0;
        this.statsListener_ = null;
        this.eventQueue_ = new EventQueue();
        this.nextWriteId_ = 1;
        this.interceptServerDataCallback_ = null;
        /** A list of data pieces and paths to be set when this client disconnects. */
        this.onDisconnect_ = newSparseSnapshotTree();
        /** Stores queues of outstanding transactions for Firebase locations. */
        this.transactionQueueTree_ = new Tree();
        // TODO: This should be @private but it's used by test_access.js and internal.js
        this.persistentConnection_ = null;
        // This key is intentionally not updated if RepoInfo is later changed or replaced
        this.key = this.repoInfo_.toURLString();
    }
    /**
     * @returns The URL corresponding to the root of this Firebase.
     */
    Repo.prototype.toString = function () {
        return ((this.repoInfo_.secure ? 'https://' : 'http://') + this.repoInfo_.host);
    };
    return Repo;
}());
function repoStart(repo, appId, authOverride) {
    repo.stats_ = statsManagerGetCollection(repo.repoInfo_);
    if (repo.forceRestClient_ || beingCrawled()) {
        repo.server_ = new ReadonlyRestClient(repo.repoInfo_, function (pathString, data, isMerge, tag) {
            repoOnDataUpdate(repo, pathString, data, isMerge, tag);
        }, repo.authTokenProvider_, repo.appCheckProvider_);
        // Minor hack: Fire onConnect immediately, since there's no actual connection.
        setTimeout(function () { return repoOnConnectStatus(repo, /* connectStatus= */ true); }, 0);
    }
    else {
        // Validate authOverride
        if (typeof authOverride !== 'undefined' && authOverride !== null) {
            if (typeof authOverride !== 'object') {
                throw new Error('Only objects are supported for option databaseAuthVariableOverride');
            }
            try {
                stringify(authOverride);
            }
            catch (e) {
                throw new Error('Invalid authOverride provided: ' + e);
            }
        }
        repo.persistentConnection_ = new PersistentConnection(repo.repoInfo_, appId, function (pathString, data, isMerge, tag) {
            repoOnDataUpdate(repo, pathString, data, isMerge, tag);
        }, function (connectStatus) {
            repoOnConnectStatus(repo, connectStatus);
        }, function (updates) {
            repoOnServerInfoUpdate(repo, updates);
        }, repo.authTokenProvider_, repo.appCheckProvider_, authOverride);
        repo.server_ = repo.persistentConnection_;
    }
    repo.authTokenProvider_.addTokenChangeListener(function (token) {
        repo.server_.refreshAuthToken(token);
    });
    repo.appCheckProvider_.addTokenChangeListener(function (result) {
        repo.server_.refreshAppCheckToken(result.token);
    });
    // In the case of multiple Repos for the same repoInfo (i.e. there are multiple Firebase.Contexts being used),
    // we only want to create one StatsReporter.  As such, we'll report stats over the first Repo created.
    repo.statsReporter_ = statsManagerGetOrCreateReporter(repo.repoInfo_, function () { return new StatsReporter(repo.stats_, repo.server_); });
    // Used for .info.
    repo.infoData_ = new SnapshotHolder();
    repo.infoSyncTree_ = new SyncTree({
        startListening: function (query, tag, currentHashFn, onComplete) {
            var infoEvents = [];
            var node = repo.infoData_.getNode(query._path);
            // This is possibly a hack, but we have different semantics for .info endpoints. We don't raise null events
            // on initial data...
            if (!node.isEmpty()) {
                infoEvents = syncTreeApplyServerOverwrite(repo.infoSyncTree_, query._path, node);
                setTimeout(function () {
                    onComplete('ok');
                }, 0);
            }
            return infoEvents;
        },
        stopListening: function () { }
    });
    repoUpdateInfo(repo, 'connected', false);
    repo.serverSyncTree_ = new SyncTree({
        startListening: function (query, tag, currentHashFn, onComplete) {
            repo.server_.listen(query, currentHashFn, tag, function (status, data) {
                var events = onComplete(status, data);
                eventQueueRaiseEventsForChangedPath(repo.eventQueue_, query._path, events);
            });
            // No synchronous events for network-backed sync trees
            return [];
        },
        stopListening: function (query, tag) {
            repo.server_.unlisten(query, tag);
        }
    });
}
/**
 * @returns The time in milliseconds, taking the server offset into account if we have one.
 */
function repoServerTime(repo) {
    var offsetNode = repo.infoData_.getNode(new Path('.info/serverTimeOffset'));
    var offset = offsetNode.val() || 0;
    return new Date().getTime() + offset;
}
/**
 * Generate ServerValues using some variables from the repo object.
 */
function repoGenerateServerValues(repo) {
    return generateWithValues({
        timestamp: repoServerTime(repo)
    });
}
/**
 * Called by realtime when we get new messages from the server.
 */
function repoOnDataUpdate(repo, pathString, data, isMerge, tag) {
    // For testing.
    repo.dataUpdateCount++;
    var path = new Path(pathString);
    data = repo.interceptServerDataCallback_
        ? repo.interceptServerDataCallback_(pathString, data)
        : data;
    var events = [];
    if (tag) {
        if (isMerge) {
            var taggedChildren = map(data, function (raw) { return nodeFromJSON(raw); });
            events = syncTreeApplyTaggedQueryMerge(repo.serverSyncTree_, path, taggedChildren, tag);
        }
        else {
            var taggedSnap = nodeFromJSON(data);
            events = syncTreeApplyTaggedQueryOverwrite(repo.serverSyncTree_, path, taggedSnap, tag);
        }
    }
    else if (isMerge) {
        var changedChildren = map(data, function (raw) { return nodeFromJSON(raw); });
        events = syncTreeApplyServerMerge(repo.serverSyncTree_, path, changedChildren);
    }
    else {
        var snap = nodeFromJSON(data);
        events = syncTreeApplyServerOverwrite(repo.serverSyncTree_, path, snap);
    }
    var affectedPath = path;
    if (events.length > 0) {
        // Since we have a listener outstanding for each transaction, receiving any events
        // is a proxy for some change having occurred.
        affectedPath = repoRerunTransactions(repo, path);
    }
    eventQueueRaiseEventsForChangedPath(repo.eventQueue_, affectedPath, events);
}
function repoOnConnectStatus(repo, connectStatus) {
    repoUpdateInfo(repo, 'connected', connectStatus);
    if (connectStatus === false) {
        repoRunOnDisconnectEvents(repo);
    }
}
function repoOnServerInfoUpdate(repo, updates) {
    each(updates, function (key, value) {
        repoUpdateInfo(repo, key, value);
    });
}
function repoUpdateInfo(repo, pathString, value) {
    var path = new Path('/.info/' + pathString);
    var newNode = nodeFromJSON(value);
    repo.infoData_.updateSnapshot(path, newNode);
    var events = syncTreeApplyServerOverwrite(repo.infoSyncTree_, path, newNode);
    eventQueueRaiseEventsForChangedPath(repo.eventQueue_, path, events);
}
function repoGetNextWriteId(repo) {
    return repo.nextWriteId_++;
}
/**
 * The purpose of `getValue` is to return the latest known value
 * satisfying `query`.
 *
 * This method will first check for in-memory cached values
 * belonging to active listeners. If they are found, such values
 * are considered to be the most up-to-date.
 *
 * If the client is not connected, this method will wait until the
 *  repo has established a connection and then request the value for `query`.
 * If the client is not able to retrieve the query result for another reason,
 * it reports an error.
 *
 * @param query - The query to surface a value for.
 */
function repoGetValue(repo, query, eventRegistration) {
    // Only active queries are cached. There is no persisted cache.
    var cached = syncTreeGetServerValue(repo.serverSyncTree_, query);
    if (cached != null) {
        return Promise.resolve(cached);
    }
    return repo.server_.get(query).then(function (payload) {
        var node = nodeFromJSON(payload).withIndex(query._queryParams.getIndex());
        /**
         * Below we simulate the actions of an `onlyOnce` `onValue()` event where:
         * Add an event registration,
         * Update data at the path,
         * Raise any events,
         * Cleanup the SyncTree
         */
        syncTreeAddEventRegistration(repo.serverSyncTree_, query, eventRegistration, true);
        var events;
        if (query._queryParams.loadsAllData()) {
            events = syncTreeApplyServerOverwrite(repo.serverSyncTree_, query._path, node);
        }
        else {
            var tag = syncTreeTagForQuery(repo.serverSyncTree_, query);
            events = syncTreeApplyTaggedQueryOverwrite(repo.serverSyncTree_, query._path, node, tag);
        }
        /*
         * We need to raise events in the scenario where `get()` is called at a parent path, and
         * while the `get()` is pending, `onValue` is called at a child location. While get() is waiting
         * for the data, `onValue` will register a new event. Then, get() will come back, and update the syncTree
         * and its corresponding serverCache, including the child location where `onValue` is called. Then,
         * `onValue` will receive the event from the server, but look at the syncTree and see that the data received
         * from the server is already at the SyncPoint, and so the `onValue` callback will never get fired.
         * Calling `eventQueueRaiseEventsForChangedPath()` is the correct way to propagate the events and
         * ensure the corresponding child events will get fired.
         */
        eventQueueRaiseEventsForChangedPath(repo.eventQueue_, query._path, events);
        syncTreeRemoveEventRegistration(repo.serverSyncTree_, query, eventRegistration, null, true);
        return node;
    }, function (err) {
        repoLog(repo, 'get for query ' + stringify(query) + ' failed: ' + err);
        return Promise.reject(new Error(err));
    });
}
function repoSetWithPriority(repo, path, newVal, newPriority, onComplete) {
    repoLog(repo, 'set', {
        path: path.toString(),
        value: newVal,
        priority: newPriority
    });
    // TODO: Optimize this behavior to either (a) store flag to skip resolving where possible and / or
    // (b) store unresolved paths on JSON parse
    var serverValues = repoGenerateServerValues(repo);
    var newNodeUnresolved = nodeFromJSON(newVal, newPriority);
    var existing = syncTreeCalcCompleteEventCache(repo.serverSyncTree_, path);
    var newNode = resolveDeferredValueSnapshot(newNodeUnresolved, existing, serverValues);
    var writeId = repoGetNextWriteId(repo);
    var events = syncTreeApplyUserOverwrite(repo.serverSyncTree_, path, newNode, writeId, true);
    eventQueueQueueEvents(repo.eventQueue_, events);
    repo.server_.put(path.toString(), newNodeUnresolved.val(/*export=*/ true), function (status, errorReason) {
        var success = status === 'ok';
        if (!success) {
            warn('set at ' + path + ' failed: ' + status);
        }
        var clearEvents = syncTreeAckUserWrite(repo.serverSyncTree_, writeId, !success);
        eventQueueRaiseEventsForChangedPath(repo.eventQueue_, path, clearEvents);
        repoCallOnCompleteCallback(repo, onComplete, status, errorReason);
    });
    var affectedPath = repoAbortTransactions(repo, path);
    repoRerunTransactions(repo, affectedPath);
    // We queued the events above, so just flush the queue here
    eventQueueRaiseEventsForChangedPath(repo.eventQueue_, affectedPath, []);
}
function repoUpdate(repo, path, childrenToMerge, onComplete) {
    repoLog(repo, 'update', { path: path.toString(), value: childrenToMerge });
    // Start with our existing data and merge each child into it.
    var empty = true;
    var serverValues = repoGenerateServerValues(repo);
    var changedChildren = {};
    each(childrenToMerge, function (changedKey, changedValue) {
        empty = false;
        changedChildren[changedKey] = resolveDeferredValueTree(pathChild(path, changedKey), nodeFromJSON(changedValue), repo.serverSyncTree_, serverValues);
    });
    if (!empty) {
        var writeId_1 = repoGetNextWriteId(repo);
        var events = syncTreeApplyUserMerge(repo.serverSyncTree_, path, changedChildren, writeId_1);
        eventQueueQueueEvents(repo.eventQueue_, events);
        repo.server_.merge(path.toString(), childrenToMerge, function (status, errorReason) {
            var success = status === 'ok';
            if (!success) {
                warn('update at ' + path + ' failed: ' + status);
            }
            var clearEvents = syncTreeAckUserWrite(repo.serverSyncTree_, writeId_1, !success);
            var affectedPath = clearEvents.length > 0 ? repoRerunTransactions(repo, path) : path;
            eventQueueRaiseEventsForChangedPath(repo.eventQueue_, affectedPath, clearEvents);
            repoCallOnCompleteCallback(repo, onComplete, status, errorReason);
        });
        each(childrenToMerge, function (changedPath) {
            var affectedPath = repoAbortTransactions(repo, pathChild(path, changedPath));
            repoRerunTransactions(repo, affectedPath);
        });
        // We queued the events above, so just flush the queue here
        eventQueueRaiseEventsForChangedPath(repo.eventQueue_, path, []);
    }
    else {
        log("update() called with empty data.  Don't do anything.");
        repoCallOnCompleteCallback(repo, onComplete, 'ok', undefined);
    }
}
/**
 * Applies all of the changes stored up in the onDisconnect_ tree.
 */
function repoRunOnDisconnectEvents(repo) {
    repoLog(repo, 'onDisconnectEvents');
    var serverValues = repoGenerateServerValues(repo);
    var resolvedOnDisconnectTree = newSparseSnapshotTree();
    sparseSnapshotTreeForEachTree(repo.onDisconnect_, newEmptyPath(), function (path, node) {
        var resolved = resolveDeferredValueTree(path, node, repo.serverSyncTree_, serverValues);
        sparseSnapshotTreeRemember(resolvedOnDisconnectTree, path, resolved);
    });
    var events = [];
    sparseSnapshotTreeForEachTree(resolvedOnDisconnectTree, newEmptyPath(), function (path, snap) {
        events = events.concat(syncTreeApplyServerOverwrite(repo.serverSyncTree_, path, snap));
        var affectedPath = repoAbortTransactions(repo, path);
        repoRerunTransactions(repo, affectedPath);
    });
    repo.onDisconnect_ = newSparseSnapshotTree();
    eventQueueRaiseEventsForChangedPath(repo.eventQueue_, newEmptyPath(), events);
}
function repoOnDisconnectCancel(repo, path, onComplete) {
    repo.server_.onDisconnectCancel(path.toString(), function (status, errorReason) {
        if (status === 'ok') {
            sparseSnapshotTreeForget(repo.onDisconnect_, path);
        }
        repoCallOnCompleteCallback(repo, onComplete, status, errorReason);
    });
}
function repoOnDisconnectSet(repo, path, value, onComplete) {
    var newNode = nodeFromJSON(value);
    repo.server_.onDisconnectPut(path.toString(), newNode.val(/*export=*/ true), function (status, errorReason) {
        if (status === 'ok') {
            sparseSnapshotTreeRemember(repo.onDisconnect_, path, newNode);
        }
        repoCallOnCompleteCallback(repo, onComplete, status, errorReason);
    });
}
function repoOnDisconnectSetWithPriority(repo, path, value, priority, onComplete) {
    var newNode = nodeFromJSON(value, priority);
    repo.server_.onDisconnectPut(path.toString(), newNode.val(/*export=*/ true), function (status, errorReason) {
        if (status === 'ok') {
            sparseSnapshotTreeRemember(repo.onDisconnect_, path, newNode);
        }
        repoCallOnCompleteCallback(repo, onComplete, status, errorReason);
    });
}
function repoOnDisconnectUpdate(repo, path, childrenToMerge, onComplete) {
    if (isEmpty(childrenToMerge)) {
        log("onDisconnect().update() called with empty data.  Don't do anything.");
        repoCallOnCompleteCallback(repo, onComplete, 'ok', undefined);
        return;
    }
    repo.server_.onDisconnectMerge(path.toString(), childrenToMerge, function (status, errorReason) {
        if (status === 'ok') {
            each(childrenToMerge, function (childName, childNode) {
                var newChildNode = nodeFromJSON(childNode);
                sparseSnapshotTreeRemember(repo.onDisconnect_, pathChild(path, childName), newChildNode);
            });
        }
        repoCallOnCompleteCallback(repo, onComplete, status, errorReason);
    });
}
function repoAddEventCallbackForQuery(repo, query, eventRegistration) {
    var events;
    if (pathGetFront(query._path) === '.info') {
        events = syncTreeAddEventRegistration(repo.infoSyncTree_, query, eventRegistration);
    }
    else {
        events = syncTreeAddEventRegistration(repo.serverSyncTree_, query, eventRegistration);
    }
    eventQueueRaiseEventsAtPath(repo.eventQueue_, query._path, events);
}
function repoRemoveEventCallbackForQuery(repo, query, eventRegistration) {
    // These are guaranteed not to raise events, since we're not passing in a cancelError. However, we can future-proof
    // a little bit by handling the return values anyways.
    var events;
    if (pathGetFront(query._path) === '.info') {
        events = syncTreeRemoveEventRegistration(repo.infoSyncTree_, query, eventRegistration);
    }
    else {
        events = syncTreeRemoveEventRegistration(repo.serverSyncTree_, query, eventRegistration);
    }
    eventQueueRaiseEventsAtPath(repo.eventQueue_, query._path, events);
}
function repoInterrupt(repo) {
    if (repo.persistentConnection_) {
        repo.persistentConnection_.interrupt(INTERRUPT_REASON);
    }
}
function repoResume(repo) {
    if (repo.persistentConnection_) {
        repo.persistentConnection_.resume(INTERRUPT_REASON);
    }
}
function repoLog(repo) {
    var varArgs = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        varArgs[_i - 1] = arguments[_i];
    }
    var prefix = '';
    if (repo.persistentConnection_) {
        prefix = repo.persistentConnection_.id + ':';
    }
    log.apply(void 0, __spreadArray([prefix], __read(varArgs), false));
}
function repoCallOnCompleteCallback(repo, callback, status, errorReason) {
    if (callback) {
        exceptionGuard(function () {
            if (status === 'ok') {
                callback(null);
            }
            else {
                var code = (status || 'error').toUpperCase();
                var message = code;
                if (errorReason) {
                    message += ': ' + errorReason;
                }
                var error = new Error(message);
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                error.code = code;
                callback(error);
            }
        });
    }
}
/**
 * Creates a new transaction, adds it to the transactions we're tracking, and
 * sends it to the server if possible.
 *
 * @param path - Path at which to do transaction.
 * @param transactionUpdate - Update callback.
 * @param onComplete - Completion callback.
 * @param unwatcher - Function that will be called when the transaction no longer
 * need data updates for `path`.
 * @param applyLocally - Whether or not to make intermediate results visible
 */
function repoStartTransaction(repo, path, transactionUpdate, onComplete, unwatcher, applyLocally) {
    repoLog(repo, 'transaction on ' + path);
    // Initialize transaction.
    var transaction = {
        path: path,
        update: transactionUpdate,
        onComplete: onComplete,
        // One of TransactionStatus enums.
        status: null,
        // Used when combining transactions at different locations to figure out
        // which one goes first.
        order: LUIDGenerator(),
        // Whether to raise local events for this transaction.
        applyLocally: applyLocally,
        // Count of how many times we've retried the transaction.
        retryCount: 0,
        // Function to call to clean up our .on() listener.
        unwatcher: unwatcher,
        // Stores why a transaction was aborted.
        abortReason: null,
        currentWriteId: null,
        currentInputSnapshot: null,
        currentOutputSnapshotRaw: null,
        currentOutputSnapshotResolved: null
    };
    // Run transaction initially.
    var currentState = repoGetLatestState(repo, path, undefined);
    transaction.currentInputSnapshot = currentState;
    var newVal = transaction.update(currentState.val());
    if (newVal === undefined) {
        // Abort transaction.
        transaction.unwatcher();
        transaction.currentOutputSnapshotRaw = null;
        transaction.currentOutputSnapshotResolved = null;
        if (transaction.onComplete) {
            transaction.onComplete(null, false, transaction.currentInputSnapshot);
        }
    }
    else {
        validateFirebaseData('transaction failed: Data returned ', newVal, transaction.path);
        // Mark as run and add to our queue.
        transaction.status = 0 /* TransactionStatus.RUN */;
        var queueNode = treeSubTree(repo.transactionQueueTree_, path);
        var nodeQueue = treeGetValue(queueNode) || [];
        nodeQueue.push(transaction);
        treeSetValue(queueNode, nodeQueue);
        // Update visibleData and raise events
        // Note: We intentionally raise events after updating all of our
        // transaction state, since the user could start new transactions from the
        // event callbacks.
        var priorityForNode = void 0;
        if (typeof newVal === 'object' &&
            newVal !== null &&
            contains(newVal, '.priority')) {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            priorityForNode = safeGet(newVal, '.priority');
            assert(isValidPriority(priorityForNode), 'Invalid priority returned by transaction. ' +
                'Priority must be a valid string, finite number, server value, or null.');
        }
        else {
            var currentNode = syncTreeCalcCompleteEventCache(repo.serverSyncTree_, path) ||
                ChildrenNode.EMPTY_NODE;
            priorityForNode = currentNode.getPriority().val();
        }
        var serverValues = repoGenerateServerValues(repo);
        var newNodeUnresolved = nodeFromJSON(newVal, priorityForNode);
        var newNode = resolveDeferredValueSnapshot(newNodeUnresolved, currentState, serverValues);
        transaction.currentOutputSnapshotRaw = newNodeUnresolved;
        transaction.currentOutputSnapshotResolved = newNode;
        transaction.currentWriteId = repoGetNextWriteId(repo);
        var events = syncTreeApplyUserOverwrite(repo.serverSyncTree_, path, newNode, transaction.currentWriteId, transaction.applyLocally);
        eventQueueRaiseEventsForChangedPath(repo.eventQueue_, path, events);
        repoSendReadyTransactions(repo, repo.transactionQueueTree_);
    }
}
/**
 * @param excludeSets - A specific set to exclude
 */
function repoGetLatestState(repo, path, excludeSets) {
    return (syncTreeCalcCompleteEventCache(repo.serverSyncTree_, path, excludeSets) ||
        ChildrenNode.EMPTY_NODE);
}
/**
 * Sends any already-run transactions that aren't waiting for outstanding
 * transactions to complete.
 *
 * Externally it's called with no arguments, but it calls itself recursively
 * with a particular transactionQueueTree node to recurse through the tree.
 *
 * @param node - transactionQueueTree node to start at.
 */
function repoSendReadyTransactions(repo, node) {
    if (node === void 0) { node = repo.transactionQueueTree_; }
    // Before recursing, make sure any completed transactions are removed.
    if (!node) {
        repoPruneCompletedTransactionsBelowNode(repo, node);
    }
    if (treeGetValue(node)) {
        var queue = repoBuildTransactionQueue(repo, node);
        assert(queue.length > 0, 'Sending zero length transaction queue');
        var allRun = queue.every(function (transaction) { return transaction.status === 0 /* TransactionStatus.RUN */; });
        // If they're all run (and not sent), we can send them.  Else, we must wait.
        if (allRun) {
            repoSendTransactionQueue(repo, treeGetPath(node), queue);
        }
    }
    else if (treeHasChildren(node)) {
        treeForEachChild(node, function (childNode) {
            repoSendReadyTransactions(repo, childNode);
        });
    }
}
/**
 * Given a list of run transactions, send them to the server and then handle
 * the result (success or failure).
 *
 * @param path - The location of the queue.
 * @param queue - Queue of transactions under the specified location.
 */
function repoSendTransactionQueue(repo, path, queue) {
    // Mark transactions as sent and increment retry count!
    var setsToIgnore = queue.map(function (txn) {
        return txn.currentWriteId;
    });
    var latestState = repoGetLatestState(repo, path, setsToIgnore);
    var snapToSend = latestState;
    var latestHash = latestState.hash();
    for (var i = 0; i < queue.length; i++) {
        var txn = queue[i];
        assert(txn.status === 0 /* TransactionStatus.RUN */, 'tryToSendTransactionQueue_: items in queue should all be run.');
        txn.status = 1 /* TransactionStatus.SENT */;
        txn.retryCount++;
        var relativePath = newRelativePath(path, txn.path);
        // If we've gotten to this point, the output snapshot must be defined.
        snapToSend = snapToSend.updateChild(relativePath /** @type {!Node} */, txn.currentOutputSnapshotRaw);
    }
    var dataToSend = snapToSend.val(true);
    var pathToSend = path;
    // Send the put.
    repo.server_.put(pathToSend.toString(), dataToSend, function (status) {
        repoLog(repo, 'transaction put response', {
            path: pathToSend.toString(),
            status: status
        });
        var events = [];
        if (status === 'ok') {
            // Queue up the callbacks and fire them after cleaning up all of our
            // transaction state, since the callback could trigger more
            // transactions or sets.
            var callbacks = [];
            var _loop_1 = function (i) {
                queue[i].status = 2 /* TransactionStatus.COMPLETED */;
                events = events.concat(syncTreeAckUserWrite(repo.serverSyncTree_, queue[i].currentWriteId));
                if (queue[i].onComplete) {
                    // We never unset the output snapshot, and given that this
                    // transaction is complete, it should be set
                    callbacks.push(function () {
                        return queue[i].onComplete(null, true, queue[i].currentOutputSnapshotResolved);
                    });
                }
                queue[i].unwatcher();
            };
            for (var i = 0; i < queue.length; i++) {
                _loop_1(i);
            }
            // Now remove the completed transactions.
            repoPruneCompletedTransactionsBelowNode(repo, treeSubTree(repo.transactionQueueTree_, path));
            // There may be pending transactions that we can now send.
            repoSendReadyTransactions(repo, repo.transactionQueueTree_);
            eventQueueRaiseEventsForChangedPath(repo.eventQueue_, path, events);
            // Finally, trigger onComplete callbacks.
            for (var i = 0; i < callbacks.length; i++) {
                exceptionGuard(callbacks[i]);
            }
        }
        else {
            // transactions are no longer sent.  Update their status appropriately.
            if (status === 'datastale') {
                for (var i = 0; i < queue.length; i++) {
                    if (queue[i].status === 3 /* TransactionStatus.SENT_NEEDS_ABORT */) {
                        queue[i].status = 4 /* TransactionStatus.NEEDS_ABORT */;
                    }
                    else {
                        queue[i].status = 0 /* TransactionStatus.RUN */;
                    }
                }
            }
            else {
                warn('transaction at ' + pathToSend.toString() + ' failed: ' + status);
                for (var i = 0; i < queue.length; i++) {
                    queue[i].status = 4 /* TransactionStatus.NEEDS_ABORT */;
                    queue[i].abortReason = status;
                }
            }
            repoRerunTransactions(repo, path);
        }
    }, latestHash);
}
/**
 * Finds all transactions dependent on the data at changedPath and reruns them.
 *
 * Should be called any time cached data changes.
 *
 * Return the highest path that was affected by rerunning transactions. This
 * is the path at which events need to be raised for.
 *
 * @param changedPath - The path in mergedData that changed.
 * @returns The rootmost path that was affected by rerunning transactions.
 */
function repoRerunTransactions(repo, changedPath) {
    var rootMostTransactionNode = repoGetAncestorTransactionNode(repo, changedPath);
    var path = treeGetPath(rootMostTransactionNode);
    var queue = repoBuildTransactionQueue(repo, rootMostTransactionNode);
    repoRerunTransactionQueue(repo, queue, path);
    return path;
}
/**
 * Does all the work of rerunning transactions (as well as cleans up aborted
 * transactions and whatnot).
 *
 * @param queue - The queue of transactions to run.
 * @param path - The path the queue is for.
 */
function repoRerunTransactionQueue(repo, queue, path) {
    if (queue.length === 0) {
        return; // Nothing to do!
    }
    // Queue up the callbacks and fire them after cleaning up all of our
    // transaction state, since the callback could trigger more transactions or
    // sets.
    var callbacks = [];
    var events = [];
    // Ignore all of the sets we're going to re-run.
    var txnsToRerun = queue.filter(function (q) {
        return q.status === 0 /* TransactionStatus.RUN */;
    });
    var setsToIgnore = txnsToRerun.map(function (q) {
        return q.currentWriteId;
    });
    var _loop_2 = function (i) {
        var transaction = queue[i];
        var relativePath = newRelativePath(path, transaction.path);
        var abortTransaction = false, abortReason;
        assert(relativePath !== null, 'rerunTransactionsUnderNode_: relativePath should not be null.');
        if (transaction.status === 4 /* TransactionStatus.NEEDS_ABORT */) {
            abortTransaction = true;
            abortReason = transaction.abortReason;
            events = events.concat(syncTreeAckUserWrite(repo.serverSyncTree_, transaction.currentWriteId, true));
        }
        else if (transaction.status === 0 /* TransactionStatus.RUN */) {
            if (transaction.retryCount >= MAX_TRANSACTION_RETRIES) {
                abortTransaction = true;
                abortReason = 'maxretry';
                events = events.concat(syncTreeAckUserWrite(repo.serverSyncTree_, transaction.currentWriteId, true));
            }
            else {
                // This code reruns a transaction
                var currentNode = repoGetLatestState(repo, transaction.path, setsToIgnore);
                transaction.currentInputSnapshot = currentNode;
                var newData = queue[i].update(currentNode.val());
                if (newData !== undefined) {
                    validateFirebaseData('transaction failed: Data returned ', newData, transaction.path);
                    var newDataNode = nodeFromJSON(newData);
                    var hasExplicitPriority = typeof newData === 'object' &&
                        newData != null &&
                        contains(newData, '.priority');
                    if (!hasExplicitPriority) {
                        // Keep the old priority if there wasn't a priority explicitly specified.
                        newDataNode = newDataNode.updatePriority(currentNode.getPriority());
                    }
                    var oldWriteId = transaction.currentWriteId;
                    var serverValues = repoGenerateServerValues(repo);
                    var newNodeResolved = resolveDeferredValueSnapshot(newDataNode, currentNode, serverValues);
                    transaction.currentOutputSnapshotRaw = newDataNode;
                    transaction.currentOutputSnapshotResolved = newNodeResolved;
                    transaction.currentWriteId = repoGetNextWriteId(repo);
                    // Mutates setsToIgnore in place
                    setsToIgnore.splice(setsToIgnore.indexOf(oldWriteId), 1);
                    events = events.concat(syncTreeApplyUserOverwrite(repo.serverSyncTree_, transaction.path, newNodeResolved, transaction.currentWriteId, transaction.applyLocally));
                    events = events.concat(syncTreeAckUserWrite(repo.serverSyncTree_, oldWriteId, true));
                }
                else {
                    abortTransaction = true;
                    abortReason = 'nodata';
                    events = events.concat(syncTreeAckUserWrite(repo.serverSyncTree_, transaction.currentWriteId, true));
                }
            }
        }
        eventQueueRaiseEventsForChangedPath(repo.eventQueue_, path, events);
        events = [];
        if (abortTransaction) {
            // Abort.
            queue[i].status = 2 /* TransactionStatus.COMPLETED */;
            // Removing a listener can trigger pruning which can muck with
            // mergedData/visibleData (as it prunes data). So defer the unwatcher
            // until we're done.
            (function (unwatcher) {
                setTimeout(unwatcher, Math.floor(0));
            })(queue[i].unwatcher);
            if (queue[i].onComplete) {
                if (abortReason === 'nodata') {
                    callbacks.push(function () {
                        return queue[i].onComplete(null, false, queue[i].currentInputSnapshot);
                    });
                }
                else {
                    callbacks.push(function () {
                        return queue[i].onComplete(new Error(abortReason), false, null);
                    });
                }
            }
        }
    };
    for (var i = 0; i < queue.length; i++) {
        _loop_2(i);
    }
    // Clean up completed transactions.
    repoPruneCompletedTransactionsBelowNode(repo, repo.transactionQueueTree_);
    // Now fire callbacks, now that we're in a good, known state.
    for (var i = 0; i < callbacks.length; i++) {
        exceptionGuard(callbacks[i]);
    }
    // Try to send the transaction result to the server.
    repoSendReadyTransactions(repo, repo.transactionQueueTree_);
}
/**
 * Returns the rootmost ancestor node of the specified path that has a pending
 * transaction on it, or just returns the node for the given path if there are
 * no pending transactions on any ancestor.
 *
 * @param path - The location to start at.
 * @returns The rootmost node with a transaction.
 */
function repoGetAncestorTransactionNode(repo, path) {
    var front;
    // Start at the root and walk deeper into the tree towards path until we
    // find a node with pending transactions.
    var transactionNode = repo.transactionQueueTree_;
    front = pathGetFront(path);
    while (front !== null && treeGetValue(transactionNode) === undefined) {
        transactionNode = treeSubTree(transactionNode, front);
        path = pathPopFront(path);
        front = pathGetFront(path);
    }
    return transactionNode;
}
/**
 * Builds the queue of all transactions at or below the specified
 * transactionNode.
 *
 * @param transactionNode
 * @returns The generated queue.
 */
function repoBuildTransactionQueue(repo, transactionNode) {
    // Walk any child transaction queues and aggregate them into a single queue.
    var transactionQueue = [];
    repoAggregateTransactionQueuesForNode(repo, transactionNode, transactionQueue);
    // Sort them by the order the transactions were created.
    transactionQueue.sort(function (a, b) { return a.order - b.order; });
    return transactionQueue;
}
function repoAggregateTransactionQueuesForNode(repo, node, queue) {
    var nodeQueue = treeGetValue(node);
    if (nodeQueue) {
        for (var i = 0; i < nodeQueue.length; i++) {
            queue.push(nodeQueue[i]);
        }
    }
    treeForEachChild(node, function (child) {
        repoAggregateTransactionQueuesForNode(repo, child, queue);
    });
}
/**
 * Remove COMPLETED transactions at or below this node in the transactionQueueTree_.
 */
function repoPruneCompletedTransactionsBelowNode(repo, node) {
    var queue = treeGetValue(node);
    if (queue) {
        var to = 0;
        for (var from = 0; from < queue.length; from++) {
            if (queue[from].status !== 2 /* TransactionStatus.COMPLETED */) {
                queue[to] = queue[from];
                to++;
            }
        }
        queue.length = to;
        treeSetValue(node, queue.length > 0 ? queue : undefined);
    }
    treeForEachChild(node, function (childNode) {
        repoPruneCompletedTransactionsBelowNode(repo, childNode);
    });
}
/**
 * Aborts all transactions on ancestors or descendants of the specified path.
 * Called when doing a set() or update() since we consider them incompatible
 * with transactions.
 *
 * @param path - Path for which we want to abort related transactions.
 */
function repoAbortTransactions(repo, path) {
    var affectedPath = treeGetPath(repoGetAncestorTransactionNode(repo, path));
    var transactionNode = treeSubTree(repo.transactionQueueTree_, path);
    treeForEachAncestor(transactionNode, function (node) {
        repoAbortTransactionsOnNode(repo, node);
    });
    repoAbortTransactionsOnNode(repo, transactionNode);
    treeForEachDescendant(transactionNode, function (node) {
        repoAbortTransactionsOnNode(repo, node);
    });
    return affectedPath;
}
/**
 * Abort transactions stored in this transaction queue node.
 *
 * @param node - Node to abort transactions for.
 */
function repoAbortTransactionsOnNode(repo, node) {
    var queue = treeGetValue(node);
    if (queue) {
        // Queue up the callbacks and fire them after cleaning up all of our
        // transaction state, since the callback could trigger more transactions
        // or sets.
        var callbacks = [];
        // Go through queue.  Any already-sent transactions must be marked for
        // abort, while the unsent ones can be immediately aborted and removed.
        var events = [];
        var lastSent = -1;
        for (var i = 0; i < queue.length; i++) {
            if (queue[i].status === 3 /* TransactionStatus.SENT_NEEDS_ABORT */) ;
            else if (queue[i].status === 1 /* TransactionStatus.SENT */) {
                assert(lastSent === i - 1, 'All SENT items should be at beginning of queue.');
                lastSent = i;
                // Mark transaction for abort when it comes back.
                queue[i].status = 3 /* TransactionStatus.SENT_NEEDS_ABORT */;
                queue[i].abortReason = 'set';
            }
            else {
                assert(queue[i].status === 0 /* TransactionStatus.RUN */, 'Unexpected transaction status in abort');
                // We can abort it immediately.
                queue[i].unwatcher();
                events = events.concat(syncTreeAckUserWrite(repo.serverSyncTree_, queue[i].currentWriteId, true));
                if (queue[i].onComplete) {
                    callbacks.push(queue[i].onComplete.bind(null, new Error('set'), false, null));
                }
            }
        }
        if (lastSent === -1) {
            // We're not waiting for any sent transactions.  We can clear the queue.
            treeSetValue(node, undefined);
        }
        else {
            // Remove the transactions we aborted.
            queue.length = lastSent + 1;
        }
        // Now fire the callbacks.
        eventQueueRaiseEventsForChangedPath(repo.eventQueue_, treeGetPath(node), events);
        for (var i = 0; i < callbacks.length; i++) {
            exceptionGuard(callbacks[i]);
        }
    }
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function decodePath(pathString) {
    var pathStringDecoded = '';
    var pieces = pathString.split('/');
    for (var i = 0; i < pieces.length; i++) {
        if (pieces[i].length > 0) {
            var piece = pieces[i];
            try {
                piece = decodeURIComponent(piece.replace(/\+/g, ' '));
            }
            catch (e) { }
            pathStringDecoded += '/' + piece;
        }
    }
    return pathStringDecoded;
}
/**
 * @returns key value hash
 */
function decodeQuery(queryString) {
    var e_1, _a;
    var results = {};
    if (queryString.charAt(0) === '?') {
        queryString = queryString.substring(1);
    }
    try {
        for (var _b = __values(queryString.split('&')), _c = _b.next(); !_c.done; _c = _b.next()) {
            var segment = _c.value;
            if (segment.length === 0) {
                continue;
            }
            var kv = segment.split('=');
            if (kv.length === 2) {
                results[decodeURIComponent(kv[0])] = decodeURIComponent(kv[1]);
            }
            else {
                warn("Invalid query segment '".concat(segment, "' in query '").concat(queryString, "'"));
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return results;
}
var parseRepoInfo = function (dataURL, nodeAdmin) {
    var parsedUrl = parseDatabaseURL(dataURL), namespace = parsedUrl.namespace;
    if (parsedUrl.domain === 'firebase.com') {
        fatal(parsedUrl.host +
            ' is no longer supported. ' +
            'Please use <YOUR FIREBASE>.firebaseio.com instead');
    }
    // Catch common error of uninitialized namespace value.
    if ((!namespace || namespace === 'undefined') &&
        parsedUrl.domain !== 'localhost') {
        fatal('Cannot parse Firebase url. Please use https://<YOUR FIREBASE>.firebaseio.com');
    }
    if (!parsedUrl.secure) {
        warnIfPageIsSecure();
    }
    var webSocketOnly = parsedUrl.scheme === 'ws' || parsedUrl.scheme === 'wss';
    return {
        repoInfo: new RepoInfo(parsedUrl.host, parsedUrl.secure, namespace, webSocketOnly, nodeAdmin, 
        /*persistenceKey=*/ '', 
        /*includeNamespaceInQueryParams=*/ namespace !== parsedUrl.subdomain),
        path: new Path(parsedUrl.pathString)
    };
};
var parseDatabaseURL = function (dataURL) {
    // Default to empty strings in the event of a malformed string.
    var host = '', domain = '', subdomain = '', pathString = '', namespace = '';
    // Always default to SSL, unless otherwise specified.
    var secure = true, scheme = 'https', port = 443;
    // Don't do any validation here. The caller is responsible for validating the result of parsing.
    if (typeof dataURL === 'string') {
        // Parse scheme.
        var colonInd = dataURL.indexOf('//');
        if (colonInd >= 0) {
            scheme = dataURL.substring(0, colonInd - 1);
            dataURL = dataURL.substring(colonInd + 2);
        }
        // Parse host, path, and query string.
        var slashInd = dataURL.indexOf('/');
        if (slashInd === -1) {
            slashInd = dataURL.length;
        }
        var questionMarkInd = dataURL.indexOf('?');
        if (questionMarkInd === -1) {
            questionMarkInd = dataURL.length;
        }
        host = dataURL.substring(0, Math.min(slashInd, questionMarkInd));
        if (slashInd < questionMarkInd) {
            // For pathString, questionMarkInd will always come after slashInd
            pathString = decodePath(dataURL.substring(slashInd, questionMarkInd));
        }
        var queryParams = decodeQuery(dataURL.substring(Math.min(dataURL.length, questionMarkInd)));
        // If we have a port, use scheme for determining if it's secure.
        colonInd = host.indexOf(':');
        if (colonInd >= 0) {
            secure = scheme === 'https' || scheme === 'wss';
            port = parseInt(host.substring(colonInd + 1), 10);
        }
        else {
            colonInd = host.length;
        }
        var hostWithoutPort = host.slice(0, colonInd);
        if (hostWithoutPort.toLowerCase() === 'localhost') {
            domain = 'localhost';
        }
        else if (hostWithoutPort.split('.').length <= 2) {
            domain = hostWithoutPort;
        }
        else {
            // Interpret the subdomain of a 3 or more component URL as the namespace name.
            var dotInd = host.indexOf('.');
            subdomain = host.substring(0, dotInd).toLowerCase();
            domain = host.substring(dotInd + 1);
            // Normalize namespaces to lowercase to share storage / connection.
            namespace = subdomain;
        }
        // Always treat the value of the `ns` as the namespace name if it is present.
        if ('ns' in queryParams) {
            namespace = queryParams['ns'];
        }
    }
    return {
        host: host,
        port: port,
        domain: domain,
        subdomain: subdomain,
        secure: secure,
        scheme: scheme,
        pathString: pathString,
        namespace: namespace
    };
};

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Modeled after base64 web-safe chars, but ordered by ASCII.
var PUSH_CHARS = '-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz';
/**
 * Fancy ID generator that creates 20-character string identifiers with the
 * following properties:
 *
 * 1. They're based on timestamp so that they sort *after* any existing ids.
 * 2. They contain 72-bits of random data after the timestamp so that IDs won't
 *    collide with other clients' IDs.
 * 3. They sort *lexicographically* (so the timestamp is converted to characters
 *    that will sort properly).
 * 4. They're monotonically increasing. Even if you generate more than one in
 *    the same timestamp, the latter ones will sort after the former ones. We do
 *    this by using the previous random bits but "incrementing" them by 1 (only
 *    in the case of a timestamp collision).
 */
var nextPushId = (function () {
    // Timestamp of last push, used to prevent local collisions if you push twice
    // in one ms.
    var lastPushTime = 0;
    // We generate 72-bits of randomness which get turned into 12 characters and
    // appended to the timestamp to prevent collisions with other clients. We
    // store the last characters we generated because in the event of a collision,
    // we'll use those same characters except "incremented" by one.
    var lastRandChars = [];
    return function (now) {
        var duplicateTime = now === lastPushTime;
        lastPushTime = now;
        var i;
        var timeStampChars = new Array(8);
        for (i = 7; i >= 0; i--) {
            timeStampChars[i] = PUSH_CHARS.charAt(now % 64);
            // NOTE: Can't use << here because javascript will convert to int and lose
            // the upper bits.
            now = Math.floor(now / 64);
        }
        assert(now === 0, 'Cannot push at time == 0');
        var id = timeStampChars.join('');
        if (!duplicateTime) {
            for (i = 0; i < 12; i++) {
                lastRandChars[i] = Math.floor(Math.random() * 64);
            }
        }
        else {
            // If the timestamp hasn't changed since last push, use the same random
            // number, except incremented by 1.
            for (i = 11; i >= 0 && lastRandChars[i] === 63; i--) {
                lastRandChars[i] = 0;
            }
            lastRandChars[i]++;
        }
        for (i = 0; i < 12; i++) {
            id += PUSH_CHARS.charAt(lastRandChars[i]);
        }
        assert(id.length === 20, 'nextPushId: Length should be 20.');
        return id;
    };
})();

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Encapsulates the data needed to raise an event
 */
var DataEvent = /** @class */ (function () {
    /**
     * @param eventType - One of: value, child_added, child_changed, child_moved, child_removed
     * @param eventRegistration - The function to call to with the event data. User provided
     * @param snapshot - The data backing the event
     * @param prevName - Optional, the name of the previous child for child_* events.
     */
    function DataEvent(eventType, eventRegistration, snapshot, prevName) {
        this.eventType = eventType;
        this.eventRegistration = eventRegistration;
        this.snapshot = snapshot;
        this.prevName = prevName;
    }
    DataEvent.prototype.getPath = function () {
        var ref = this.snapshot.ref;
        if (this.eventType === 'value') {
            return ref._path;
        }
        else {
            return ref.parent._path;
        }
    };
    DataEvent.prototype.getEventType = function () {
        return this.eventType;
    };
    DataEvent.prototype.getEventRunner = function () {
        return this.eventRegistration.getEventRunner(this);
    };
    DataEvent.prototype.toString = function () {
        return (this.getPath().toString() +
            ':' +
            this.eventType +
            ':' +
            stringify(this.snapshot.exportVal()));
    };
    return DataEvent;
}());
var CancelEvent = /** @class */ (function () {
    function CancelEvent(eventRegistration, error, path) {
        this.eventRegistration = eventRegistration;
        this.error = error;
        this.path = path;
    }
    CancelEvent.prototype.getPath = function () {
        return this.path;
    };
    CancelEvent.prototype.getEventType = function () {
        return 'cancel';
    };
    CancelEvent.prototype.getEventRunner = function () {
        return this.eventRegistration.getEventRunner(this);
    };
    CancelEvent.prototype.toString = function () {
        return this.path.toString() + ':cancel';
    };
    return CancelEvent;
}());

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * A wrapper class that converts events from the database@exp SDK to the legacy
 * Database SDK. Events are not converted directly as event registration relies
 * on reference comparison of the original user callback (see `matches()`) and
 * relies on equality of the legacy SDK's `context` object.
 */
var CallbackContext = /** @class */ (function () {
    function CallbackContext(snapshotCallback, cancelCallback) {
        this.snapshotCallback = snapshotCallback;
        this.cancelCallback = cancelCallback;
    }
    CallbackContext.prototype.onValue = function (expDataSnapshot, previousChildName) {
        this.snapshotCallback.call(null, expDataSnapshot, previousChildName);
    };
    CallbackContext.prototype.onCancel = function (error) {
        assert(this.hasCancelCallback, 'Raising a cancel event on a listener with no cancel callback');
        return this.cancelCallback.call(null, error);
    };
    Object.defineProperty(CallbackContext.prototype, "hasCancelCallback", {
        get: function () {
            return !!this.cancelCallback;
        },
        enumerable: false,
        configurable: true
    });
    CallbackContext.prototype.matches = function (other) {
        return (this.snapshotCallback === other.snapshotCallback ||
            (this.snapshotCallback.userCallback !== undefined &&
                this.snapshotCallback.userCallback ===
                    other.snapshotCallback.userCallback &&
                this.snapshotCallback.context === other.snapshotCallback.context));
    };
    return CallbackContext;
}());

/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * The `onDisconnect` class allows you to write or clear data when your client
 * disconnects from the Database server. These updates occur whether your
 * client disconnects cleanly or not, so you can rely on them to clean up data
 * even if a connection is dropped or a client crashes.
 *
 * The `onDisconnect` class is most commonly used to manage presence in
 * applications where it is useful to detect how many clients are connected and
 * when other clients disconnect. See
 * {@link https://firebase.google.com/docs/database/web/offline-capabilities | Enabling Offline Capabilities in JavaScript}
 * for more information.
 *
 * To avoid problems when a connection is dropped before the requests can be
 * transferred to the Database server, these functions should be called before
 * writing any data.
 *
 * Note that `onDisconnect` operations are only triggered once. If you want an
 * operation to occur each time a disconnect occurs, you'll need to re-establish
 * the `onDisconnect` operations each time you reconnect.
 */
var OnDisconnect = /** @class */ (function () {
    /** @hideconstructor */
    function OnDisconnect(_repo, _path) {
        this._repo = _repo;
        this._path = _path;
    }
    /**
     * Cancels all previously queued `onDisconnect()` set or update events for this
     * location and all children.
     *
     * If a write has been queued for this location via a `set()` or `update()` at a
     * parent location, the write at this location will be canceled, though writes
     * to sibling locations will still occur.
     *
     * @returns Resolves when synchronization to the server is complete.
     */
    OnDisconnect.prototype.cancel = function () {
        var deferred = new Deferred();
        repoOnDisconnectCancel(this._repo, this._path, deferred.wrapCallback(function () { }));
        return deferred.promise;
    };
    /**
     * Ensures the data at this location is deleted when the client is disconnected
     * (due to closing the browser, navigating to a new page, or network issues).
     *
     * @returns Resolves when synchronization to the server is complete.
     */
    OnDisconnect.prototype.remove = function () {
        validateWritablePath('OnDisconnect.remove', this._path);
        var deferred = new Deferred();
        repoOnDisconnectSet(this._repo, this._path, null, deferred.wrapCallback(function () { }));
        return deferred.promise;
    };
    /**
     * Ensures the data at this location is set to the specified value when the
     * client is disconnected (due to closing the browser, navigating to a new page,
     * or network issues).
     *
     * `set()` is especially useful for implementing "presence" systems, where a
     * value should be changed or cleared when a user disconnects so that they
     * appear "offline" to other users. See
     * {@link https://firebase.google.com/docs/database/web/offline-capabilities | Enabling Offline Capabilities in JavaScript}
     * for more information.
     *
     * Note that `onDisconnect` operations are only triggered once. If you want an
     * operation to occur each time a disconnect occurs, you'll need to re-establish
     * the `onDisconnect` operations each time.
     *
     * @param value - The value to be written to this location on disconnect (can
     * be an object, array, string, number, boolean, or null).
     * @returns Resolves when synchronization to the Database is complete.
     */
    OnDisconnect.prototype.set = function (value) {
        validateWritablePath('OnDisconnect.set', this._path);
        validateFirebaseDataArg('OnDisconnect.set', value, this._path, false);
        var deferred = new Deferred();
        repoOnDisconnectSet(this._repo, this._path, value, deferred.wrapCallback(function () { }));
        return deferred.promise;
    };
    /**
     * Ensures the data at this location is set to the specified value and priority
     * when the client is disconnected (due to closing the browser, navigating to a
     * new page, or network issues).
     *
     * @param value - The value to be written to this location on disconnect (can
     * be an object, array, string, number, boolean, or null).
     * @param priority - The priority to be written (string, number, or null).
     * @returns Resolves when synchronization to the Database is complete.
     */
    OnDisconnect.prototype.setWithPriority = function (value, priority) {
        validateWritablePath('OnDisconnect.setWithPriority', this._path);
        validateFirebaseDataArg('OnDisconnect.setWithPriority', value, this._path, false);
        validatePriority('OnDisconnect.setWithPriority', priority, false);
        var deferred = new Deferred();
        repoOnDisconnectSetWithPriority(this._repo, this._path, value, priority, deferred.wrapCallback(function () { }));
        return deferred.promise;
    };
    /**
     * Writes multiple values at this location when the client is disconnected (due
     * to closing the browser, navigating to a new page, or network issues).
     *
     * The `values` argument contains multiple property-value pairs that will be
     * written to the Database together. Each child property can either be a simple
     * property (for example, "name") or a relative path (for example, "name/first")
     * from the current location to the data to update.
     *
     * As opposed to the `set()` method, `update()` can be use to selectively update
     * only the referenced properties at the current location (instead of replacing
     * all the child properties at the current location).
     *
     * @param values - Object containing multiple values.
     * @returns Resolves when synchronization to the Database is complete.
     */
    OnDisconnect.prototype.update = function (values) {
        validateWritablePath('OnDisconnect.update', this._path);
        validateFirebaseMergeDataArg('OnDisconnect.update', values, this._path, false);
        var deferred = new Deferred();
        repoOnDisconnectUpdate(this._repo, this._path, values, deferred.wrapCallback(function () { }));
        return deferred.promise;
    };
    return OnDisconnect;
}());

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @internal
 */
var QueryImpl = /** @class */ (function () {
    /**
     * @hideconstructor
     */
    function QueryImpl(_repo, _path, _queryParams, _orderByCalled) {
        this._repo = _repo;
        this._path = _path;
        this._queryParams = _queryParams;
        this._orderByCalled = _orderByCalled;
    }
    Object.defineProperty(QueryImpl.prototype, "key", {
        get: function () {
            if (pathIsEmpty(this._path)) {
                return null;
            }
            else {
                return pathGetBack(this._path);
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(QueryImpl.prototype, "ref", {
        get: function () {
            return new ReferenceImpl(this._repo, this._path);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(QueryImpl.prototype, "_queryIdentifier", {
        get: function () {
            var obj = queryParamsGetQueryObject(this._queryParams);
            var id = ObjectToUniqueKey(obj);
            return id === '{}' ? 'default' : id;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(QueryImpl.prototype, "_queryObject", {
        /**
         * An object representation of the query parameters used by this Query.
         */
        get: function () {
            return queryParamsGetQueryObject(this._queryParams);
        },
        enumerable: false,
        configurable: true
    });
    QueryImpl.prototype.isEqual = function (other) {
        other = getModularInstance(other);
        if (!(other instanceof QueryImpl)) {
            return false;
        }
        var sameRepo = this._repo === other._repo;
        var samePath = pathEquals(this._path, other._path);
        var sameQueryIdentifier = this._queryIdentifier === other._queryIdentifier;
        return sameRepo && samePath && sameQueryIdentifier;
    };
    QueryImpl.prototype.toJSON = function () {
        return this.toString();
    };
    QueryImpl.prototype.toString = function () {
        return this._repo.toString() + pathToUrlEncodedString(this._path);
    };
    return QueryImpl;
}());
/**
 * Validates that no other order by call has been made
 */
function validateNoPreviousOrderByCall(query, fnName) {
    if (query._orderByCalled === true) {
        throw new Error(fnName + ": You can't combine multiple orderBy calls.");
    }
}
/**
 * Validates start/end values for queries.
 */
function validateQueryEndpoints(params) {
    var startNode = null;
    var endNode = null;
    if (params.hasStart()) {
        startNode = params.getIndexStartValue();
    }
    if (params.hasEnd()) {
        endNode = params.getIndexEndValue();
    }
    if (params.getIndex() === KEY_INDEX) {
        var tooManyArgsError = 'Query: When ordering by key, you may only pass one argument to ' +
            'startAt(), endAt(), or equalTo().';
        var wrongArgTypeError = 'Query: When ordering by key, the argument passed to startAt(), startAfter(), ' +
            'endAt(), endBefore(), or equalTo() must be a string.';
        if (params.hasStart()) {
            var startName = params.getIndexStartName();
            if (startName !== MIN_NAME) {
                throw new Error(tooManyArgsError);
            }
            else if (typeof startNode !== 'string') {
                throw new Error(wrongArgTypeError);
            }
        }
        if (params.hasEnd()) {
            var endName = params.getIndexEndName();
            if (endName !== MAX_NAME) {
                throw new Error(tooManyArgsError);
            }
            else if (typeof endNode !== 'string') {
                throw new Error(wrongArgTypeError);
            }
        }
    }
    else if (params.getIndex() === PRIORITY_INDEX) {
        if ((startNode != null && !isValidPriority(startNode)) ||
            (endNode != null && !isValidPriority(endNode))) {
            throw new Error('Query: When ordering by priority, the first argument passed to startAt(), ' +
                'startAfter() endAt(), endBefore(), or equalTo() must be a valid priority value ' +
                '(null, a number, or a string).');
        }
    }
    else {
        assert(params.getIndex() instanceof PathIndex ||
            params.getIndex() === VALUE_INDEX, 'unknown index type.');
        if ((startNode != null && typeof startNode === 'object') ||
            (endNode != null && typeof endNode === 'object')) {
            throw new Error('Query: First argument passed to startAt(), startAfter(), endAt(), endBefore(), or ' +
                'equalTo() cannot be an object.');
        }
    }
}
/**
 * Validates that limit* has been called with the correct combination of parameters
 */
function validateLimit(params) {
    if (params.hasStart() &&
        params.hasEnd() &&
        params.hasLimit() &&
        !params.hasAnchoredLimit()) {
        throw new Error("Query: Can't combine startAt(), startAfter(), endAt(), endBefore(), and limit(). Use " +
            'limitToFirst() or limitToLast() instead.');
    }
}
/**
 * @internal
 */
var ReferenceImpl = /** @class */ (function (_super) {
    __extends(ReferenceImpl, _super);
    /** @hideconstructor */
    function ReferenceImpl(repo, path) {
        return _super.call(this, repo, path, new QueryParams(), false) || this;
    }
    Object.defineProperty(ReferenceImpl.prototype, "parent", {
        get: function () {
            var parentPath = pathParent(this._path);
            return parentPath === null
                ? null
                : new ReferenceImpl(this._repo, parentPath);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ReferenceImpl.prototype, "root", {
        get: function () {
            var ref = this;
            while (ref.parent !== null) {
                ref = ref.parent;
            }
            return ref;
        },
        enumerable: false,
        configurable: true
    });
    return ReferenceImpl;
}(QueryImpl));
/**
 * A `DataSnapshot` contains data from a Database location.
 *
 * Any time you read data from the Database, you receive the data as a
 * `DataSnapshot`. A `DataSnapshot` is passed to the event callbacks you attach
 * with `on()` or `once()`. You can extract the contents of the snapshot as a
 * JavaScript object by calling the `val()` method. Alternatively, you can
 * traverse into the snapshot by calling `child()` to return child snapshots
 * (which you could then call `val()` on).
 *
 * A `DataSnapshot` is an efficiently generated, immutable copy of the data at
 * a Database location. It cannot be modified and will never change (to modify
 * data, you always call the `set()` method on a `Reference` directly).
 */
var DataSnapshot = /** @class */ (function () {
    /**
     * @param _node - A SnapshotNode to wrap.
     * @param ref - The location this snapshot came from.
     * @param _index - The iteration order for this snapshot
     * @hideconstructor
     */
    function DataSnapshot(_node, 
    /**
     * The location of this DataSnapshot.
     */
    ref, _index) {
        this._node = _node;
        this.ref = ref;
        this._index = _index;
    }
    Object.defineProperty(DataSnapshot.prototype, "priority", {
        /**
         * Gets the priority value of the data in this `DataSnapshot`.
         *
         * Applications need not use priority but can order collections by
         * ordinary properties (see
         * {@link https://firebase.google.com/docs/database/web/lists-of-data#sorting_and_filtering_data |Sorting and filtering data}
         * ).
         */
        get: function () {
            // typecast here because we never return deferred values or internal priorities (MAX_PRIORITY)
            return this._node.getPriority().val();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DataSnapshot.prototype, "key", {
        /**
         * The key (last part of the path) of the location of this `DataSnapshot`.
         *
         * The last token in a Database location is considered its key. For example,
         * "ada" is the key for the /users/ada/ node. Accessing the key on any
         * `DataSnapshot` will return the key for the location that generated it.
         * However, accessing the key on the root URL of a Database will return
         * `null`.
         */
        get: function () {
            return this.ref.key;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DataSnapshot.prototype, "size", {
        /** Returns the number of child properties of this `DataSnapshot`. */
        get: function () {
            return this._node.numChildren();
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Gets another `DataSnapshot` for the location at the specified relative path.
     *
     * Passing a relative path to the `child()` method of a DataSnapshot returns
     * another `DataSnapshot` for the location at the specified relative path. The
     * relative path can either be a simple child name (for example, "ada") or a
     * deeper, slash-separated path (for example, "ada/name/first"). If the child
     * location has no data, an empty `DataSnapshot` (that is, a `DataSnapshot`
     * whose value is `null`) is returned.
     *
     * @param path - A relative path to the location of child data.
     */
    DataSnapshot.prototype.child = function (path) {
        var childPath = new Path(path);
        var childRef = child(this.ref, path);
        return new DataSnapshot(this._node.getChild(childPath), childRef, PRIORITY_INDEX);
    };
    /**
     * Returns true if this `DataSnapshot` contains any data. It is slightly more
     * efficient than using `snapshot.val() !== null`.
     */
    DataSnapshot.prototype.exists = function () {
        return !this._node.isEmpty();
    };
    /**
     * Exports the entire contents of the DataSnapshot as a JavaScript object.
     *
     * The `exportVal()` method is similar to `val()`, except priority information
     * is included (if available), making it suitable for backing up your data.
     *
     * @returns The DataSnapshot's contents as a JavaScript value (Object,
     *   Array, string, number, boolean, or `null`).
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    DataSnapshot.prototype.exportVal = function () {
        return this._node.val(true);
    };
    /**
     * Enumerates the top-level children in the `DataSnapshot`.
     *
     * Because of the way JavaScript objects work, the ordering of data in the
     * JavaScript object returned by `val()` is not guaranteed to match the
     * ordering on the server nor the ordering of `onChildAdded()` events. That is
     * where `forEach()` comes in handy. It guarantees the children of a
     * `DataSnapshot` will be iterated in their query order.
     *
     * If no explicit `orderBy*()` method is used, results are returned
     * ordered by key (unless priorities are used, in which case, results are
     * returned by priority).
     *
     * @param action - A function that will be called for each child DataSnapshot.
     * The callback can return true to cancel further enumeration.
     * @returns true if enumeration was canceled due to your callback returning
     * true.
     */
    DataSnapshot.prototype.forEach = function (action) {
        var _this = this;
        if (this._node.isLeafNode()) {
            return false;
        }
        var childrenNode = this._node;
        // Sanitize the return value to a boolean. ChildrenNode.forEachChild has a weird return type...
        return !!childrenNode.forEachChild(this._index, function (key, node) {
            return action(new DataSnapshot(node, child(_this.ref, key), PRIORITY_INDEX));
        });
    };
    /**
     * Returns true if the specified child path has (non-null) data.
     *
     * @param path - A relative path to the location of a potential child.
     * @returns `true` if data exists at the specified child path; else
     *  `false`.
     */
    DataSnapshot.prototype.hasChild = function (path) {
        var childPath = new Path(path);
        return !this._node.getChild(childPath).isEmpty();
    };
    /**
     * Returns whether or not the `DataSnapshot` has any non-`null` child
     * properties.
     *
     * You can use `hasChildren()` to determine if a `DataSnapshot` has any
     * children. If it does, you can enumerate them using `forEach()`. If it
     * doesn't, then either this snapshot contains a primitive value (which can be
     * retrieved with `val()`) or it is empty (in which case, `val()` will return
     * `null`).
     *
     * @returns true if this snapshot has any children; else false.
     */
    DataSnapshot.prototype.hasChildren = function () {
        if (this._node.isLeafNode()) {
            return false;
        }
        else {
            return !this._node.isEmpty();
        }
    };
    /**
     * Returns a JSON-serializable representation of this object.
     */
    DataSnapshot.prototype.toJSON = function () {
        return this.exportVal();
    };
    /**
     * Extracts a JavaScript value from a `DataSnapshot`.
     *
     * Depending on the data in a `DataSnapshot`, the `val()` method may return a
     * scalar type (string, number, or boolean), an array, or an object. It may
     * also return null, indicating that the `DataSnapshot` is empty (contains no
     * data).
     *
     * @returns The DataSnapshot's contents as a JavaScript value (Object,
     *   Array, string, number, boolean, or `null`).
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    DataSnapshot.prototype.val = function () {
        return this._node.val();
    };
    return DataSnapshot;
}());
/**
 *
 * Returns a `Reference` representing the location in the Database
 * corresponding to the provided path. If no path is provided, the `Reference`
 * will point to the root of the Database.
 *
 * @param db - The database instance to obtain a reference for.
 * @param path - Optional path representing the location the returned
 *   `Reference` will point. If not provided, the returned `Reference` will
 *   point to the root of the Database.
 * @returns If a path is provided, a `Reference`
 *   pointing to the provided path. Otherwise, a `Reference` pointing to the
 *   root of the Database.
 */
function ref(db, path) {
    db = getModularInstance(db);
    db._checkNotDeleted('ref');
    return path !== undefined ? child(db._root, path) : db._root;
}
/**
 * Returns a `Reference` representing the location in the Database
 * corresponding to the provided Firebase URL.
 *
 * An exception is thrown if the URL is not a valid Firebase Database URL or it
 * has a different domain than the current `Database` instance.
 *
 * Note that all query parameters (`orderBy`, `limitToLast`, etc.) are ignored
 * and are not applied to the returned `Reference`.
 *
 * @param db - The database instance to obtain a reference for.
 * @param url - The Firebase URL at which the returned `Reference` will
 *   point.
 * @returns A `Reference` pointing to the provided
 *   Firebase URL.
 */
function refFromURL(db, url) {
    db = getModularInstance(db);
    db._checkNotDeleted('refFromURL');
    var parsedURL = parseRepoInfo(url, db._repo.repoInfo_.nodeAdmin);
    validateUrl('refFromURL', parsedURL);
    var repoInfo = parsedURL.repoInfo;
    if (!db._repo.repoInfo_.isCustomHost() &&
        repoInfo.host !== db._repo.repoInfo_.host) {
        fatal('refFromURL' +
            ': Host name does not match the current database: ' +
            '(found ' +
            repoInfo.host +
            ' but expected ' +
            db._repo.repoInfo_.host +
            ')');
    }
    return ref(db, parsedURL.path.toString());
}
/**
 * Gets a `Reference` for the location at the specified relative path.
 *
 * The relative path can either be a simple child name (for example, "ada") or
 * a deeper slash-separated path (for example, "ada/name/first").
 *
 * @param parent - The parent location.
 * @param path - A relative path from this location to the desired child
 *   location.
 * @returns The specified child location.
 */
function child(parent, path) {
    parent = getModularInstance(parent);
    if (pathGetFront(parent._path) === null) {
        validateRootPathString('child', 'path', path, false);
    }
    else {
        validatePathString('child', 'path', path, false);
    }
    return new ReferenceImpl(parent._repo, pathChild(parent._path, path));
}
/**
 * Returns an `OnDisconnect` object - see
 * {@link https://firebase.google.com/docs/database/web/offline-capabilities | Enabling Offline Capabilities in JavaScript}
 * for more information on how to use it.
 *
 * @param ref - The reference to add OnDisconnect triggers for.
 */
function onDisconnect(ref) {
    ref = getModularInstance(ref);
    return new OnDisconnect(ref._repo, ref._path);
}
/**
 * Generates a new child location using a unique key and returns its
 * `Reference`.
 *
 * This is the most common pattern for adding data to a collection of items.
 *
 * If you provide a value to `push()`, the value is written to the
 * generated location. If you don't pass a value, nothing is written to the
 * database and the child remains empty (but you can use the `Reference`
 * elsewhere).
 *
 * The unique keys generated by `push()` are ordered by the current time, so the
 * resulting list of items is chronologically sorted. The keys are also
 * designed to be unguessable (they contain 72 random bits of entropy).
 *
 * See {@link https://firebase.google.com/docs/database/web/lists-of-data#append_to_a_list_of_data | Append to a list of data}.
 * See {@link https://firebase.googleblog.com/2015/02/the-2120-ways-to-ensure-unique_68.html | The 2^120 Ways to Ensure Unique Identifiers}.
 *
 * @param parent - The parent location.
 * @param value - Optional value to be written at the generated location.
 * @returns Combined `Promise` and `Reference`; resolves when write is complete,
 * but can be used immediately as the `Reference` to the child location.
 */
function push(parent, value) {
    parent = getModularInstance(parent);
    validateWritablePath('push', parent._path);
    validateFirebaseDataArg('push', value, parent._path, true);
    var now = repoServerTime(parent._repo);
    var name = nextPushId(now);
    // push() returns a ThennableReference whose promise is fulfilled with a
    // regular Reference. We use child() to create handles to two different
    // references. The first is turned into a ThennableReference below by adding
    // then() and catch() methods and is used as the return value of push(). The
    // second remains a regular Reference and is used as the fulfilled value of
    // the first ThennableReference.
    var thennablePushRef = child(parent, name);
    var pushRef = child(parent, name);
    var promise;
    if (value != null) {
        promise = set(pushRef, value).then(function () { return pushRef; });
    }
    else {
        promise = Promise.resolve(pushRef);
    }
    thennablePushRef.then = promise.then.bind(promise);
    thennablePushRef.catch = promise.then.bind(promise, undefined);
    return thennablePushRef;
}
/**
 * Removes the data at this Database location.
 *
 * Any data at child locations will also be deleted.
 *
 * The effect of the remove will be visible immediately and the corresponding
 * event 'value' will be triggered. Synchronization of the remove to the
 * Firebase servers will also be started, and the returned Promise will resolve
 * when complete. If provided, the onComplete callback will be called
 * asynchronously after synchronization has finished.
 *
 * @param ref - The location to remove.
 * @returns Resolves when remove on server is complete.
 */
function remove(ref) {
    validateWritablePath('remove', ref._path);
    return set(ref, null);
}
/**
 * Writes data to this Database location.
 *
 * This will overwrite any data at this location and all child locations.
 *
 * The effect of the write will be visible immediately, and the corresponding
 * events ("value", "child_added", etc.) will be triggered. Synchronization of
 * the data to the Firebase servers will also be started, and the returned
 * Promise will resolve when complete. If provided, the `onComplete` callback
 * will be called asynchronously after synchronization has finished.
 *
 * Passing `null` for the new value is equivalent to calling `remove()`; namely,
 * all data at this location and all child locations will be deleted.
 *
 * `set()` will remove any priority stored at this location, so if priority is
 * meant to be preserved, you need to use `setWithPriority()` instead.
 *
 * Note that modifying data with `set()` will cancel any pending transactions
 * at that location, so extreme care should be taken if mixing `set()` and
 * `transaction()` to modify the same data.
 *
 * A single `set()` will generate a single "value" event at the location where
 * the `set()` was performed.
 *
 * @param ref - The location to write to.
 * @param value - The value to be written (string, number, boolean, object,
 *   array, or null).
 * @returns Resolves when write to server is complete.
 */
function set(ref, value) {
    ref = getModularInstance(ref);
    validateWritablePath('set', ref._path);
    validateFirebaseDataArg('set', value, ref._path, false);
    var deferred = new Deferred();
    repoSetWithPriority(ref._repo, ref._path, value, 
    /*priority=*/ null, deferred.wrapCallback(function () { }));
    return deferred.promise;
}
/**
 * Sets a priority for the data at this Database location.
 *
 * Applications need not use priority but can order collections by
 * ordinary properties (see
 * {@link https://firebase.google.com/docs/database/web/lists-of-data#sorting_and_filtering_data | Sorting and filtering data}
 * ).
 *
 * @param ref - The location to write to.
 * @param priority - The priority to be written (string, number, or null).
 * @returns Resolves when write to server is complete.
 */
function setPriority(ref, priority) {
    ref = getModularInstance(ref);
    validateWritablePath('setPriority', ref._path);
    validatePriority('setPriority', priority, false);
    var deferred = new Deferred();
    repoSetWithPriority(ref._repo, pathChild(ref._path, '.priority'), priority, null, deferred.wrapCallback(function () { }));
    return deferred.promise;
}
/**
 * Writes data the Database location. Like `set()` but also specifies the
 * priority for that data.
 *
 * Applications need not use priority but can order collections by
 * ordinary properties (see
 * {@link https://firebase.google.com/docs/database/web/lists-of-data#sorting_and_filtering_data | Sorting and filtering data}
 * ).
 *
 * @param ref - The location to write to.
 * @param value - The value to be written (string, number, boolean, object,
 *   array, or null).
 * @param priority - The priority to be written (string, number, or null).
 * @returns Resolves when write to server is complete.
 */
function setWithPriority(ref, value, priority) {
    validateWritablePath('setWithPriority', ref._path);
    validateFirebaseDataArg('setWithPriority', value, ref._path, false);
    validatePriority('setWithPriority', priority, false);
    if (ref.key === '.length' || ref.key === '.keys') {
        throw 'setWithPriority failed: ' + ref.key + ' is a read-only object.';
    }
    var deferred = new Deferred();
    repoSetWithPriority(ref._repo, ref._path, value, priority, deferred.wrapCallback(function () { }));
    return deferred.promise;
}
/**
 * Writes multiple values to the Database at once.
 *
 * The `values` argument contains multiple property-value pairs that will be
 * written to the Database together. Each child property can either be a simple
 * property (for example, "name") or a relative path (for example,
 * "name/first") from the current location to the data to update.
 *
 * As opposed to the `set()` method, `update()` can be use to selectively update
 * only the referenced properties at the current location (instead of replacing
 * all the child properties at the current location).
 *
 * The effect of the write will be visible immediately, and the corresponding
 * events ('value', 'child_added', etc.) will be triggered. Synchronization of
 * the data to the Firebase servers will also be started, and the returned
 * Promise will resolve when complete. If provided, the `onComplete` callback
 * will be called asynchronously after synchronization has finished.
 *
 * A single `update()` will generate a single "value" event at the location
 * where the `update()` was performed, regardless of how many children were
 * modified.
 *
 * Note that modifying data with `update()` will cancel any pending
 * transactions at that location, so extreme care should be taken if mixing
 * `update()` and `transaction()` to modify the same data.
 *
 * Passing `null` to `update()` will remove the data at this location.
 *
 * See
 * {@link https://firebase.googleblog.com/2015/09/introducing-multi-location-updates-and_86.html | Introducing multi-location updates and more}.
 *
 * @param ref - The location to write to.
 * @param values - Object containing multiple values.
 * @returns Resolves when update on server is complete.
 */
function update(ref, values) {
    validateFirebaseMergeDataArg('update', values, ref._path, false);
    var deferred = new Deferred();
    repoUpdate(ref._repo, ref._path, values, deferred.wrapCallback(function () { }));
    return deferred.promise;
}
/**
 * Gets the most up-to-date result for this query.
 *
 * @param query - The query to run.
 * @returns A `Promise` which resolves to the resulting DataSnapshot if a value is
 * available, or rejects if the client is unable to return a value (e.g., if the
 * server is unreachable and there is nothing cached).
 */
function get(query) {
    query = getModularInstance(query);
    var callbackContext = new CallbackContext(function () { });
    var container = new ValueEventRegistration(callbackContext);
    return repoGetValue(query._repo, query, container).then(function (node) {
        return new DataSnapshot(node, new ReferenceImpl(query._repo, query._path), query._queryParams.getIndex());
    });
}
/**
 * Represents registration for 'value' events.
 */
var ValueEventRegistration = /** @class */ (function () {
    function ValueEventRegistration(callbackContext) {
        this.callbackContext = callbackContext;
    }
    ValueEventRegistration.prototype.respondsTo = function (eventType) {
        return eventType === 'value';
    };
    ValueEventRegistration.prototype.createEvent = function (change, query) {
        var index = query._queryParams.getIndex();
        return new DataEvent('value', this, new DataSnapshot(change.snapshotNode, new ReferenceImpl(query._repo, query._path), index));
    };
    ValueEventRegistration.prototype.getEventRunner = function (eventData) {
        var _this = this;
        if (eventData.getEventType() === 'cancel') {
            return function () {
                return _this.callbackContext.onCancel(eventData.error);
            };
        }
        else {
            return function () {
                return _this.callbackContext.onValue(eventData.snapshot, null);
            };
        }
    };
    ValueEventRegistration.prototype.createCancelEvent = function (error, path) {
        if (this.callbackContext.hasCancelCallback) {
            return new CancelEvent(this, error, path);
        }
        else {
            return null;
        }
    };
    ValueEventRegistration.prototype.matches = function (other) {
        if (!(other instanceof ValueEventRegistration)) {
            return false;
        }
        else if (!other.callbackContext || !this.callbackContext) {
            // If no callback specified, we consider it to match any callback.
            return true;
        }
        else {
            return other.callbackContext.matches(this.callbackContext);
        }
    };
    ValueEventRegistration.prototype.hasAnyCallback = function () {
        return this.callbackContext !== null;
    };
    return ValueEventRegistration;
}());
/**
 * Represents the registration of a child_x event.
 */
var ChildEventRegistration = /** @class */ (function () {
    function ChildEventRegistration(eventType, callbackContext) {
        this.eventType = eventType;
        this.callbackContext = callbackContext;
    }
    ChildEventRegistration.prototype.respondsTo = function (eventType) {
        var eventToCheck = eventType === 'children_added' ? 'child_added' : eventType;
        eventToCheck =
            eventToCheck === 'children_removed' ? 'child_removed' : eventToCheck;
        return this.eventType === eventToCheck;
    };
    ChildEventRegistration.prototype.createCancelEvent = function (error, path) {
        if (this.callbackContext.hasCancelCallback) {
            return new CancelEvent(this, error, path);
        }
        else {
            return null;
        }
    };
    ChildEventRegistration.prototype.createEvent = function (change, query) {
        assert(change.childName != null, 'Child events should have a childName.');
        var childRef = child(new ReferenceImpl(query._repo, query._path), change.childName);
        var index = query._queryParams.getIndex();
        return new DataEvent(change.type, this, new DataSnapshot(change.snapshotNode, childRef, index), change.prevName);
    };
    ChildEventRegistration.prototype.getEventRunner = function (eventData) {
        var _this = this;
        if (eventData.getEventType() === 'cancel') {
            return function () {
                return _this.callbackContext.onCancel(eventData.error);
            };
        }
        else {
            return function () {
                return _this.callbackContext.onValue(eventData.snapshot, eventData.prevName);
            };
        }
    };
    ChildEventRegistration.prototype.matches = function (other) {
        if (other instanceof ChildEventRegistration) {
            return (this.eventType === other.eventType &&
                (!this.callbackContext ||
                    !other.callbackContext ||
                    this.callbackContext.matches(other.callbackContext)));
        }
        return false;
    };
    ChildEventRegistration.prototype.hasAnyCallback = function () {
        return !!this.callbackContext;
    };
    return ChildEventRegistration;
}());
function addEventListener(query, eventType, callback, cancelCallbackOrListenOptions, options) {
    var cancelCallback;
    if (typeof cancelCallbackOrListenOptions === 'object') {
        cancelCallback = undefined;
        options = cancelCallbackOrListenOptions;
    }
    if (typeof cancelCallbackOrListenOptions === 'function') {
        cancelCallback = cancelCallbackOrListenOptions;
    }
    if (options && options.onlyOnce) {
        var userCallback_1 = callback;
        var onceCallback = function (dataSnapshot, previousChildName) {
            repoRemoveEventCallbackForQuery(query._repo, query, container);
            userCallback_1(dataSnapshot, previousChildName);
        };
        onceCallback.userCallback = callback.userCallback;
        onceCallback.context = callback.context;
        callback = onceCallback;
    }
    var callbackContext = new CallbackContext(callback, cancelCallback || undefined);
    var container = eventType === 'value'
        ? new ValueEventRegistration(callbackContext)
        : new ChildEventRegistration(eventType, callbackContext);
    repoAddEventCallbackForQuery(query._repo, query, container);
    return function () { return repoRemoveEventCallbackForQuery(query._repo, query, container); };
}
function onValue(query, callback, cancelCallbackOrListenOptions, options) {
    return addEventListener(query, 'value', callback, cancelCallbackOrListenOptions, options);
}
function onChildAdded(query, callback, cancelCallbackOrListenOptions, options) {
    return addEventListener(query, 'child_added', callback, cancelCallbackOrListenOptions, options);
}
function onChildChanged(query, callback, cancelCallbackOrListenOptions, options) {
    return addEventListener(query, 'child_changed', callback, cancelCallbackOrListenOptions, options);
}
function onChildMoved(query, callback, cancelCallbackOrListenOptions, options) {
    return addEventListener(query, 'child_moved', callback, cancelCallbackOrListenOptions, options);
}
function onChildRemoved(query, callback, cancelCallbackOrListenOptions, options) {
    return addEventListener(query, 'child_removed', callback, cancelCallbackOrListenOptions, options);
}
/**
 * Detaches a callback previously attached with the corresponding `on*()` (`onValue`, `onChildAdded`) listener.
 * Note: This is not the recommended way to remove a listener. Instead, please use the returned callback function from
 * the respective `on*` callbacks.
 *
 * Detach a callback previously attached with `on*()`. Calling `off()` on a parent listener
 * will not automatically remove listeners registered on child nodes, `off()`
 * must also be called on any child listeners to remove the callback.
 *
 * If a callback is not specified, all callbacks for the specified eventType
 * will be removed. Similarly, if no eventType is specified, all callbacks
 * for the `Reference` will be removed.
 *
 * Individual listeners can also be removed by invoking their unsubscribe
 * callbacks.
 *
 * @param query - The query that the listener was registered with.
 * @param eventType - One of the following strings: "value", "child_added",
 * "child_changed", "child_removed", or "child_moved." If omitted, all callbacks
 * for the `Reference` will be removed.
 * @param callback - The callback function that was passed to `on()` or
 * `undefined` to remove all callbacks.
 */
function off(query, eventType, callback) {
    var container = null;
    var expCallback = callback ? new CallbackContext(callback) : null;
    if (eventType === 'value') {
        container = new ValueEventRegistration(expCallback);
    }
    else if (eventType) {
        container = new ChildEventRegistration(eventType, expCallback);
    }
    repoRemoveEventCallbackForQuery(query._repo, query, container);
}
/**
 * A `QueryConstraint` is used to narrow the set of documents returned by a
 * Database query. `QueryConstraint`s are created by invoking {@link endAt},
 * {@link endBefore}, {@link startAt}, {@link startAfter}, {@link
 * limitToFirst}, {@link limitToLast}, {@link orderByChild},
 * {@link orderByChild}, {@link orderByKey} , {@link orderByPriority} ,
 * {@link orderByValue}  or {@link equalTo} and
 * can then be passed to {@link query} to create a new query instance that
 * also contains this `QueryConstraint`.
 */
var QueryConstraint = /** @class */ (function () {
    function QueryConstraint() {
    }
    return QueryConstraint;
}());
var QueryEndAtConstraint = /** @class */ (function (_super) {
    __extends(QueryEndAtConstraint, _super);
    function QueryEndAtConstraint(_value, _key) {
        var _this = _super.call(this) || this;
        _this._value = _value;
        _this._key = _key;
        return _this;
    }
    QueryEndAtConstraint.prototype._apply = function (query) {
        validateFirebaseDataArg('endAt', this._value, query._path, true);
        var newParams = queryParamsEndAt(query._queryParams, this._value, this._key);
        validateLimit(newParams);
        validateQueryEndpoints(newParams);
        if (query._queryParams.hasEnd()) {
            throw new Error('endAt: Starting point was already set (by another call to endAt, ' +
                'endBefore or equalTo).');
        }
        return new QueryImpl(query._repo, query._path, newParams, query._orderByCalled);
    };
    return QueryEndAtConstraint;
}(QueryConstraint));
/**
 * Creates a `QueryConstraint` with the specified ending point.
 *
 * Using `startAt()`, `startAfter()`, `endBefore()`, `endAt()` and `equalTo()`
 * allows you to choose arbitrary starting and ending points for your queries.
 *
 * The ending point is inclusive, so children with exactly the specified value
 * will be included in the query. The optional key argument can be used to
 * further limit the range of the query. If it is specified, then children that
 * have exactly the specified value must also have a key name less than or equal
 * to the specified key.
 *
 * You can read more about `endAt()` in
 * {@link https://firebase.google.com/docs/database/web/lists-of-data#filtering_data | Filtering data}.
 *
 * @param value - The value to end at. The argument type depends on which
 * `orderBy*()` function was used in this query. Specify a value that matches
 * the `orderBy*()` type. When used in combination with `orderByKey()`, the
 * value must be a string.
 * @param key - The child key to end at, among the children with the previously
 * specified priority. This argument is only allowed if ordering by child,
 * value, or priority.
 */
function endAt(value, key) {
    validateKey('endAt', 'key', key, true);
    return new QueryEndAtConstraint(value, key);
}
var QueryEndBeforeConstraint = /** @class */ (function (_super) {
    __extends(QueryEndBeforeConstraint, _super);
    function QueryEndBeforeConstraint(_value, _key) {
        var _this = _super.call(this) || this;
        _this._value = _value;
        _this._key = _key;
        return _this;
    }
    QueryEndBeforeConstraint.prototype._apply = function (query) {
        validateFirebaseDataArg('endBefore', this._value, query._path, false);
        var newParams = queryParamsEndBefore(query._queryParams, this._value, this._key);
        validateLimit(newParams);
        validateQueryEndpoints(newParams);
        if (query._queryParams.hasEnd()) {
            throw new Error('endBefore: Starting point was already set (by another call to endAt, ' +
                'endBefore or equalTo).');
        }
        return new QueryImpl(query._repo, query._path, newParams, query._orderByCalled);
    };
    return QueryEndBeforeConstraint;
}(QueryConstraint));
/**
 * Creates a `QueryConstraint` with the specified ending point (exclusive).
 *
 * Using `startAt()`, `startAfter()`, `endBefore()`, `endAt()` and `equalTo()`
 * allows you to choose arbitrary starting and ending points for your queries.
 *
 * The ending point is exclusive. If only a value is provided, children
 * with a value less than the specified value will be included in the query.
 * If a key is specified, then children must have a value less than or equal
 * to the specified value and a key name less than the specified key.
 *
 * @param value - The value to end before. The argument type depends on which
 * `orderBy*()` function was used in this query. Specify a value that matches
 * the `orderBy*()` type. When used in combination with `orderByKey()`, the
 * value must be a string.
 * @param key - The child key to end before, among the children with the
 * previously specified priority. This argument is only allowed if ordering by
 * child, value, or priority.
 */
function endBefore(value, key) {
    validateKey('endBefore', 'key', key, true);
    return new QueryEndBeforeConstraint(value, key);
}
var QueryStartAtConstraint = /** @class */ (function (_super) {
    __extends(QueryStartAtConstraint, _super);
    function QueryStartAtConstraint(_value, _key) {
        var _this = _super.call(this) || this;
        _this._value = _value;
        _this._key = _key;
        return _this;
    }
    QueryStartAtConstraint.prototype._apply = function (query) {
        validateFirebaseDataArg('startAt', this._value, query._path, true);
        var newParams = queryParamsStartAt(query._queryParams, this._value, this._key);
        validateLimit(newParams);
        validateQueryEndpoints(newParams);
        if (query._queryParams.hasStart()) {
            throw new Error('startAt: Starting point was already set (by another call to startAt, ' +
                'startBefore or equalTo).');
        }
        return new QueryImpl(query._repo, query._path, newParams, query._orderByCalled);
    };
    return QueryStartAtConstraint;
}(QueryConstraint));
/**
 * Creates a `QueryConstraint` with the specified starting point.
 *
 * Using `startAt()`, `startAfter()`, `endBefore()`, `endAt()` and `equalTo()`
 * allows you to choose arbitrary starting and ending points for your queries.
 *
 * The starting point is inclusive, so children with exactly the specified value
 * will be included in the query. The optional key argument can be used to
 * further limit the range of the query. If it is specified, then children that
 * have exactly the specified value must also have a key name greater than or
 * equal to the specified key.
 *
 * You can read more about `startAt()` in
 * {@link https://firebase.google.com/docs/database/web/lists-of-data#filtering_data | Filtering data}.
 *
 * @param value - The value to start at. The argument type depends on which
 * `orderBy*()` function was used in this query. Specify a value that matches
 * the `orderBy*()` type. When used in combination with `orderByKey()`, the
 * value must be a string.
 * @param key - The child key to start at. This argument is only allowed if
 * ordering by child, value, or priority.
 */
function startAt(value, key) {
    if (value === void 0) { value = null; }
    validateKey('startAt', 'key', key, true);
    return new QueryStartAtConstraint(value, key);
}
var QueryStartAfterConstraint = /** @class */ (function (_super) {
    __extends(QueryStartAfterConstraint, _super);
    function QueryStartAfterConstraint(_value, _key) {
        var _this = _super.call(this) || this;
        _this._value = _value;
        _this._key = _key;
        return _this;
    }
    QueryStartAfterConstraint.prototype._apply = function (query) {
        validateFirebaseDataArg('startAfter', this._value, query._path, false);
        var newParams = queryParamsStartAfter(query._queryParams, this._value, this._key);
        validateLimit(newParams);
        validateQueryEndpoints(newParams);
        if (query._queryParams.hasStart()) {
            throw new Error('startAfter: Starting point was already set (by another call to startAt, ' +
                'startAfter, or equalTo).');
        }
        return new QueryImpl(query._repo, query._path, newParams, query._orderByCalled);
    };
    return QueryStartAfterConstraint;
}(QueryConstraint));
/**
 * Creates a `QueryConstraint` with the specified starting point (exclusive).
 *
 * Using `startAt()`, `startAfter()`, `endBefore()`, `endAt()` and `equalTo()`
 * allows you to choose arbitrary starting and ending points for your queries.
 *
 * The starting point is exclusive. If only a value is provided, children
 * with a value greater than the specified value will be included in the query.
 * If a key is specified, then children must have a value greater than or equal
 * to the specified value and a a key name greater than the specified key.
 *
 * @param value - The value to start after. The argument type depends on which
 * `orderBy*()` function was used in this query. Specify a value that matches
 * the `orderBy*()` type. When used in combination with `orderByKey()`, the
 * value must be a string.
 * @param key - The child key to start after. This argument is only allowed if
 * ordering by child, value, or priority.
 */
function startAfter(value, key) {
    validateKey('startAfter', 'key', key, true);
    return new QueryStartAfterConstraint(value, key);
}
var QueryLimitToFirstConstraint = /** @class */ (function (_super) {
    __extends(QueryLimitToFirstConstraint, _super);
    function QueryLimitToFirstConstraint(_limit) {
        var _this = _super.call(this) || this;
        _this._limit = _limit;
        return _this;
    }
    QueryLimitToFirstConstraint.prototype._apply = function (query) {
        if (query._queryParams.hasLimit()) {
            throw new Error('limitToFirst: Limit was already set (by another call to limitToFirst ' +
                'or limitToLast).');
        }
        return new QueryImpl(query._repo, query._path, queryParamsLimitToFirst(query._queryParams, this._limit), query._orderByCalled);
    };
    return QueryLimitToFirstConstraint;
}(QueryConstraint));
/**
 * Creates a new `QueryConstraint` that if limited to the first specific number
 * of children.
 *
 * The `limitToFirst()` method is used to set a maximum number of children to be
 * synced for a given callback. If we set a limit of 100, we will initially only
 * receive up to 100 `child_added` events. If we have fewer than 100 messages
 * stored in our Database, a `child_added` event will fire for each message.
 * However, if we have over 100 messages, we will only receive a `child_added`
 * event for the first 100 ordered messages. As items change, we will receive
 * `child_removed` events for each item that drops out of the active list so
 * that the total number stays at 100.
 *
 * You can read more about `limitToFirst()` in
 * {@link https://firebase.google.com/docs/database/web/lists-of-data#filtering_data | Filtering data}.
 *
 * @param limit - The maximum number of nodes to include in this query.
 */
function limitToFirst(limit) {
    if (typeof limit !== 'number' || Math.floor(limit) !== limit || limit <= 0) {
        throw new Error('limitToFirst: First argument must be a positive integer.');
    }
    return new QueryLimitToFirstConstraint(limit);
}
var QueryLimitToLastConstraint = /** @class */ (function (_super) {
    __extends(QueryLimitToLastConstraint, _super);
    function QueryLimitToLastConstraint(_limit) {
        var _this = _super.call(this) || this;
        _this._limit = _limit;
        return _this;
    }
    QueryLimitToLastConstraint.prototype._apply = function (query) {
        if (query._queryParams.hasLimit()) {
            throw new Error('limitToLast: Limit was already set (by another call to limitToFirst ' +
                'or limitToLast).');
        }
        return new QueryImpl(query._repo, query._path, queryParamsLimitToLast(query._queryParams, this._limit), query._orderByCalled);
    };
    return QueryLimitToLastConstraint;
}(QueryConstraint));
/**
 * Creates a new `QueryConstraint` that is limited to return only the last
 * specified number of children.
 *
 * The `limitToLast()` method is used to set a maximum number of children to be
 * synced for a given callback. If we set a limit of 100, we will initially only
 * receive up to 100 `child_added` events. If we have fewer than 100 messages
 * stored in our Database, a `child_added` event will fire for each message.
 * However, if we have over 100 messages, we will only receive a `child_added`
 * event for the last 100 ordered messages. As items change, we will receive
 * `child_removed` events for each item that drops out of the active list so
 * that the total number stays at 100.
 *
 * You can read more about `limitToLast()` in
 * {@link https://firebase.google.com/docs/database/web/lists-of-data#filtering_data | Filtering data}.
 *
 * @param limit - The maximum number of nodes to include in this query.
 */
function limitToLast(limit) {
    if (typeof limit !== 'number' || Math.floor(limit) !== limit || limit <= 0) {
        throw new Error('limitToLast: First argument must be a positive integer.');
    }
    return new QueryLimitToLastConstraint(limit);
}
var QueryOrderByChildConstraint = /** @class */ (function (_super) {
    __extends(QueryOrderByChildConstraint, _super);
    function QueryOrderByChildConstraint(_path) {
        var _this = _super.call(this) || this;
        _this._path = _path;
        return _this;
    }
    QueryOrderByChildConstraint.prototype._apply = function (query) {
        validateNoPreviousOrderByCall(query, 'orderByChild');
        var parsedPath = new Path(this._path);
        if (pathIsEmpty(parsedPath)) {
            throw new Error('orderByChild: cannot pass in empty path. Use orderByValue() instead.');
        }
        var index = new PathIndex(parsedPath);
        var newParams = queryParamsOrderBy(query._queryParams, index);
        validateQueryEndpoints(newParams);
        return new QueryImpl(query._repo, query._path, newParams, 
        /*orderByCalled=*/ true);
    };
    return QueryOrderByChildConstraint;
}(QueryConstraint));
/**
 * Creates a new `QueryConstraint` that orders by the specified child key.
 *
 * Queries can only order by one key at a time. Calling `orderByChild()`
 * multiple times on the same query is an error.
 *
 * Firebase queries allow you to order your data by any child key on the fly.
 * However, if you know in advance what your indexes will be, you can define
 * them via the .indexOn rule in your Security Rules for better performance. See
 * the{@link https://firebase.google.com/docs/database/security/indexing-data}
 * rule for more information.
 *
 * You can read more about `orderByChild()` in
 * {@link https://firebase.google.com/docs/database/web/lists-of-data#sort_data | Sort data}.
 *
 * @param path - The path to order by.
 */
function orderByChild(path) {
    if (path === '$key') {
        throw new Error('orderByChild: "$key" is invalid.  Use orderByKey() instead.');
    }
    else if (path === '$priority') {
        throw new Error('orderByChild: "$priority" is invalid.  Use orderByPriority() instead.');
    }
    else if (path === '$value') {
        throw new Error('orderByChild: "$value" is invalid.  Use orderByValue() instead.');
    }
    validatePathString('orderByChild', 'path', path, false);
    return new QueryOrderByChildConstraint(path);
}
var QueryOrderByKeyConstraint = /** @class */ (function (_super) {
    __extends(QueryOrderByKeyConstraint, _super);
    function QueryOrderByKeyConstraint() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    QueryOrderByKeyConstraint.prototype._apply = function (query) {
        validateNoPreviousOrderByCall(query, 'orderByKey');
        var newParams = queryParamsOrderBy(query._queryParams, KEY_INDEX);
        validateQueryEndpoints(newParams);
        return new QueryImpl(query._repo, query._path, newParams, 
        /*orderByCalled=*/ true);
    };
    return QueryOrderByKeyConstraint;
}(QueryConstraint));
/**
 * Creates a new `QueryConstraint` that orders by the key.
 *
 * Sorts the results of a query by their (ascending) key values.
 *
 * You can read more about `orderByKey()` in
 * {@link https://firebase.google.com/docs/database/web/lists-of-data#sort_data | Sort data}.
 */
function orderByKey() {
    return new QueryOrderByKeyConstraint();
}
var QueryOrderByPriorityConstraint = /** @class */ (function (_super) {
    __extends(QueryOrderByPriorityConstraint, _super);
    function QueryOrderByPriorityConstraint() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    QueryOrderByPriorityConstraint.prototype._apply = function (query) {
        validateNoPreviousOrderByCall(query, 'orderByPriority');
        var newParams = queryParamsOrderBy(query._queryParams, PRIORITY_INDEX);
        validateQueryEndpoints(newParams);
        return new QueryImpl(query._repo, query._path, newParams, 
        /*orderByCalled=*/ true);
    };
    return QueryOrderByPriorityConstraint;
}(QueryConstraint));
/**
 * Creates a new `QueryConstraint` that orders by priority.
 *
 * Applications need not use priority but can order collections by
 * ordinary properties (see
 * {@link https://firebase.google.com/docs/database/web/lists-of-data#sort_data | Sort data}
 * for alternatives to priority.
 */
function orderByPriority() {
    return new QueryOrderByPriorityConstraint();
}
var QueryOrderByValueConstraint = /** @class */ (function (_super) {
    __extends(QueryOrderByValueConstraint, _super);
    function QueryOrderByValueConstraint() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    QueryOrderByValueConstraint.prototype._apply = function (query) {
        validateNoPreviousOrderByCall(query, 'orderByValue');
        var newParams = queryParamsOrderBy(query._queryParams, VALUE_INDEX);
        validateQueryEndpoints(newParams);
        return new QueryImpl(query._repo, query._path, newParams, 
        /*orderByCalled=*/ true);
    };
    return QueryOrderByValueConstraint;
}(QueryConstraint));
/**
 * Creates a new `QueryConstraint` that orders by value.
 *
 * If the children of a query are all scalar values (string, number, or
 * boolean), you can order the results by their (ascending) values.
 *
 * You can read more about `orderByValue()` in
 * {@link https://firebase.google.com/docs/database/web/lists-of-data#sort_data | Sort data}.
 */
function orderByValue() {
    return new QueryOrderByValueConstraint();
}
var QueryEqualToValueConstraint = /** @class */ (function (_super) {
    __extends(QueryEqualToValueConstraint, _super);
    function QueryEqualToValueConstraint(_value, _key) {
        var _this = _super.call(this) || this;
        _this._value = _value;
        _this._key = _key;
        return _this;
    }
    QueryEqualToValueConstraint.prototype._apply = function (query) {
        validateFirebaseDataArg('equalTo', this._value, query._path, false);
        if (query._queryParams.hasStart()) {
            throw new Error('equalTo: Starting point was already set (by another call to startAt/startAfter or ' +
                'equalTo).');
        }
        if (query._queryParams.hasEnd()) {
            throw new Error('equalTo: Ending point was already set (by another call to endAt/endBefore or ' +
                'equalTo).');
        }
        return new QueryEndAtConstraint(this._value, this._key)._apply(new QueryStartAtConstraint(this._value, this._key)._apply(query));
    };
    return QueryEqualToValueConstraint;
}(QueryConstraint));
/**
 * Creates a `QueryConstraint` that includes children that match the specified
 * value.
 *
 * Using `startAt()`, `startAfter()`, `endBefore()`, `endAt()` and `equalTo()`
 * allows you to choose arbitrary starting and ending points for your queries.
 *
 * The optional key argument can be used to further limit the range of the
 * query. If it is specified, then children that have exactly the specified
 * value must also have exactly the specified key as their key name. This can be
 * used to filter result sets with many matches for the same value.
 *
 * You can read more about `equalTo()` in
 * {@link https://firebase.google.com/docs/database/web/lists-of-data#filtering_data | Filtering data}.
 *
 * @param value - The value to match for. The argument type depends on which
 * `orderBy*()` function was used in this query. Specify a value that matches
 * the `orderBy*()` type. When used in combination with `orderByKey()`, the
 * value must be a string.
 * @param key - The child key to start at, among the children with the
 * previously specified priority. This argument is only allowed if ordering by
 * child, value, or priority.
 */
function equalTo(value, key) {
    validateKey('equalTo', 'key', key, true);
    return new QueryEqualToValueConstraint(value, key);
}
/**
 * Creates a new immutable instance of `Query` that is extended to also include
 * additional query constraints.
 *
 * @param query - The Query instance to use as a base for the new constraints.
 * @param queryConstraints - The list of `QueryConstraint`s to apply.
 * @throws if any of the provided query constraints cannot be combined with the
 * existing or new constraints.
 */
function query(query) {
    var e_1, _a;
    var queryConstraints = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        queryConstraints[_i - 1] = arguments[_i];
    }
    var queryImpl = getModularInstance(query);
    try {
        for (var queryConstraints_1 = __values(queryConstraints), queryConstraints_1_1 = queryConstraints_1.next(); !queryConstraints_1_1.done; queryConstraints_1_1 = queryConstraints_1.next()) {
            var constraint = queryConstraints_1_1.value;
            queryImpl = constraint._apply(queryImpl);
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (queryConstraints_1_1 && !queryConstraints_1_1.done && (_a = queryConstraints_1.return)) _a.call(queryConstraints_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return queryImpl;
}
/**
 * Define reference constructor in various modules
 *
 * We are doing this here to avoid several circular
 * dependency issues
 */
syncPointSetReferenceConstructor(ReferenceImpl);
syncTreeSetReferenceConstructor(ReferenceImpl);

/**
 * This variable is also defined in the firebase Node.js Admin SDK. Before
 * modifying this definition, consult the definition in:
 *
 * https://github.com/firebase/firebase-admin-node
 *
 * and make sure the two are consistent.
 */
var FIREBASE_DATABASE_EMULATOR_HOST_VAR = 'FIREBASE_DATABASE_EMULATOR_HOST';
/**
 * Creates and caches `Repo` instances.
 */
var repos = {};
/**
 * If true, any new `Repo` will be created to use `ReadonlyRestClient` (for testing purposes).
 */
var useRestClient = false;
/**
 * Update an existing `Repo` in place to point to a new host/port.
 */
function repoManagerApplyEmulatorSettings(repo, host, port, tokenProvider) {
    repo.repoInfo_ = new RepoInfo("".concat(host, ":").concat(port), 
    /* secure= */ false, repo.repoInfo_.namespace, repo.repoInfo_.webSocketOnly, repo.repoInfo_.nodeAdmin, repo.repoInfo_.persistenceKey, repo.repoInfo_.includeNamespaceInQueryParams, 
    /*isUsingEmulator=*/ true);
    if (tokenProvider) {
        repo.authTokenProvider_ = tokenProvider;
    }
}
/**
 * This function should only ever be called to CREATE a new database instance.
 * @internal
 */
function repoManagerDatabaseFromApp(app, authProvider, appCheckProvider, url, nodeAdmin) {
    var dbUrl = url || app.options.databaseURL;
    if (dbUrl === undefined) {
        if (!app.options.projectId) {
            fatal("Can't determine Firebase Database URL. Be sure to include " +
                ' a Project ID when calling firebase.initializeApp().');
        }
        log('Using default host for project ', app.options.projectId);
        dbUrl = "".concat(app.options.projectId, "-default-rtdb.firebaseio.com");
    }
    var parsedUrl = parseRepoInfo(dbUrl, nodeAdmin);
    var repoInfo = parsedUrl.repoInfo;
    var isEmulator;
    var dbEmulatorHost = undefined;
    if (typeof process !== 'undefined' && process.env) {
        dbEmulatorHost = process.env[FIREBASE_DATABASE_EMULATOR_HOST_VAR];
    }
    if (dbEmulatorHost) {
        isEmulator = true;
        dbUrl = "http://".concat(dbEmulatorHost, "?ns=").concat(repoInfo.namespace);
        parsedUrl = parseRepoInfo(dbUrl, nodeAdmin);
        repoInfo = parsedUrl.repoInfo;
    }
    else {
        isEmulator = !parsedUrl.repoInfo.secure;
    }
    var authTokenProvider = nodeAdmin && isEmulator
        ? new EmulatorTokenProvider(EmulatorTokenProvider.OWNER)
        : new FirebaseAuthTokenProvider(app.name, app.options, authProvider);
    validateUrl('Invalid Firebase Database URL', parsedUrl);
    if (!pathIsEmpty(parsedUrl.path)) {
        fatal('Database URL must point to the root of a Firebase Database ' +
            '(not including a child path).');
    }
    var repo = repoManagerCreateRepo(repoInfo, app, authTokenProvider, new AppCheckTokenProvider(app.name, appCheckProvider));
    return new Database(repo, app);
}
/**
 * Remove the repo and make sure it is disconnected.
 *
 */
function repoManagerDeleteRepo(repo, appName) {
    var appRepos = repos[appName];
    // This should never happen...
    if (!appRepos || appRepos[repo.key] !== repo) {
        fatal("Database ".concat(appName, "(").concat(repo.repoInfo_, ") has already been deleted."));
    }
    repoInterrupt(repo);
    delete appRepos[repo.key];
}
/**
 * Ensures a repo doesn't already exist and then creates one using the
 * provided app.
 *
 * @param repoInfo - The metadata about the Repo
 * @returns The Repo object for the specified server / repoName.
 */
function repoManagerCreateRepo(repoInfo, app, authTokenProvider, appCheckProvider) {
    var appRepos = repos[app.name];
    if (!appRepos) {
        appRepos = {};
        repos[app.name] = appRepos;
    }
    var repo = appRepos[repoInfo.toURLString()];
    if (repo) {
        fatal('Database initialized multiple times. Please make sure the format of the database URL matches with each database() call.');
    }
    repo = new Repo(repoInfo, useRestClient, authTokenProvider, appCheckProvider);
    appRepos[repoInfo.toURLString()] = repo;
    return repo;
}
/**
 * Forces us to use ReadonlyRestClient instead of PersistentConnection for new Repos.
 */
function repoManagerForceRestClient(forceRestClient) {
    useRestClient = forceRestClient;
}
/**
 * Class representing a Firebase Realtime Database.
 */
var Database = /** @class */ (function () {
    /** @hideconstructor */
    function Database(_repoInternal, 
    /** The {@link @firebase/app#FirebaseApp} associated with this Realtime Database instance. */
    app) {
        this._repoInternal = _repoInternal;
        this.app = app;
        /** Represents a `Database` instance. */
        this['type'] = 'database';
        /** Track if the instance has been used (root or repo accessed) */
        this._instanceStarted = false;
    }
    Object.defineProperty(Database.prototype, "_repo", {
        get: function () {
            if (!this._instanceStarted) {
                repoStart(this._repoInternal, this.app.options.appId, this.app.options['databaseAuthVariableOverride']);
                this._instanceStarted = true;
            }
            return this._repoInternal;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Database.prototype, "_root", {
        get: function () {
            if (!this._rootInternal) {
                this._rootInternal = new ReferenceImpl(this._repo, newEmptyPath());
            }
            return this._rootInternal;
        },
        enumerable: false,
        configurable: true
    });
    Database.prototype._delete = function () {
        if (this._rootInternal !== null) {
            repoManagerDeleteRepo(this._repo, this.app.name);
            this._repoInternal = null;
            this._rootInternal = null;
        }
        return Promise.resolve();
    };
    Database.prototype._checkNotDeleted = function (apiName) {
        if (this._rootInternal === null) {
            fatal('Cannot call ' + apiName + ' on a deleted database.');
        }
    };
    return Database;
}());
function checkTransportInit() {
    if (TransportManager.IS_TRANSPORT_INITIALIZED) {
        warn('Transport has already been initialized. Please call this function before calling ref or setting up a listener');
    }
}
/**
 * Force the use of websockets instead of longPolling.
 */
function forceWebSockets() {
    checkTransportInit();
    BrowserPollConnection.forceDisallow();
}
/**
 * Force the use of longPolling instead of websockets. This will be ignored if websocket protocol is used in databaseURL.
 */
function forceLongPolling() {
    checkTransportInit();
    WebSocketConnection.forceDisallow();
    BrowserPollConnection.forceAllow();
}
/**
 * Returns the instance of the Realtime Database SDK that is associated
 * with the provided {@link @firebase/app#FirebaseApp}. Initializes a new instance with
 * with default settings if no instance exists or if the existing instance uses
 * a custom database URL.
 *
 * @param app - The {@link @firebase/app#FirebaseApp} instance that the returned Realtime
 * Database instance is associated with.
 * @param url - The URL of the Realtime Database instance to connect to. If not
 * provided, the SDK connects to the default instance of the Firebase App.
 * @returns The `Database` instance of the provided app.
 */
function getDatabase(app, url) {
    if (app === void 0) { app = getApp(); }
    var db = _getProvider(app, 'database').getImmediate({
        identifier: url
    });
    if (!db._instanceStarted) {
        var emulator = getDefaultEmulatorHostnameAndPort('database');
        if (emulator) {
            connectDatabaseEmulator.apply(void 0, __spreadArray([db], __read(emulator), false));
        }
    }
    return db;
}
/**
 * Modify the provided instance to communicate with the Realtime Database
 * emulator.
 *
 * <p>Note: This method must be called before performing any other operation.
 *
 * @param db - The instance to modify.
 * @param host - The emulator host (ex: localhost)
 * @param port - The emulator port (ex: 8080)
 * @param options.mockUserToken - the mock auth token to use for unit testing Security Rules
 */
function connectDatabaseEmulator(db, host, port, options) {
    if (options === void 0) { options = {}; }
    db = getModularInstance(db);
    db._checkNotDeleted('useEmulator');
    if (db._instanceStarted) {
        fatal('Cannot call useEmulator() after instance has already been initialized.');
    }
    var repo = db._repoInternal;
    var tokenProvider = undefined;
    if (repo.repoInfo_.nodeAdmin) {
        if (options.mockUserToken) {
            fatal('mockUserToken is not supported by the Admin SDK. For client access with mock users, please use the "firebase" package instead of "firebase-admin".');
        }
        tokenProvider = new EmulatorTokenProvider(EmulatorTokenProvider.OWNER);
    }
    else if (options.mockUserToken) {
        var token = typeof options.mockUserToken === 'string'
            ? options.mockUserToken
            : createMockUserToken(options.mockUserToken, db.app.options.projectId);
        tokenProvider = new EmulatorTokenProvider(token);
    }
    // Modify the repo to apply emulator settings
    repoManagerApplyEmulatorSettings(repo, host, port, tokenProvider);
}
/**
 * Disconnects from the server (all Database operations will be completed
 * offline).
 *
 * The client automatically maintains a persistent connection to the Database
 * server, which will remain active indefinitely and reconnect when
 * disconnected. However, the `goOffline()` and `goOnline()` methods may be used
 * to control the client connection in cases where a persistent connection is
 * undesirable.
 *
 * While offline, the client will no longer receive data updates from the
 * Database. However, all Database operations performed locally will continue to
 * immediately fire events, allowing your application to continue behaving
 * normally. Additionally, each operation performed locally will automatically
 * be queued and retried upon reconnection to the Database server.
 *
 * To reconnect to the Database and begin receiving remote events, see
 * `goOnline()`.
 *
 * @param db - The instance to disconnect.
 */
function goOffline(db) {
    db = getModularInstance(db);
    db._checkNotDeleted('goOffline');
    repoInterrupt(db._repo);
}
/**
 * Reconnects to the server and synchronizes the offline Database state
 * with the server state.
 *
 * This method should be used after disabling the active connection with
 * `goOffline()`. Once reconnected, the client will transmit the proper data
 * and fire the appropriate events so that your client "catches up"
 * automatically.
 *
 * @param db - The instance to reconnect.
 */
function goOnline(db) {
    db = getModularInstance(db);
    db._checkNotDeleted('goOnline');
    repoResume(db._repo);
}
function enableLogging(logger, persistent) {
    enableLogging$1(logger, persistent);
}

/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function registerDatabase(variant) {
    setSDKVersion(SDK_VERSION$1);
    _registerComponent(new Component('database', function (container, _a) {
        var url = _a.instanceIdentifier;
        var app = container.getProvider('app').getImmediate();
        var authProvider = container.getProvider('auth-internal');
        var appCheckProvider = container.getProvider('app-check-internal');
        return repoManagerDatabaseFromApp(app, authProvider, appCheckProvider, url);
    }, "PUBLIC" /* ComponentType.PUBLIC */).setMultipleInstances(true));
    registerVersion(name, version, variant);
    // BUILD_TARGET will be replaced by values like esm5, esm2017, cjs5, etc during the compilation
    registerVersion(name, version, 'esm5');
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var SERVER_TIMESTAMP = {
    '.sv': 'timestamp'
};
/**
 * Returns a placeholder value for auto-populating the current timestamp (time
 * since the Unix epoch, in milliseconds) as determined by the Firebase
 * servers.
 */
function serverTimestamp() {
    return SERVER_TIMESTAMP;
}
/**
 * Returns a placeholder value that can be used to atomically increment the
 * current database value by the provided delta.
 *
 * @param delta - the amount to modify the current value atomically.
 * @returns A placeholder value for modifying data atomically server-side.
 */
function increment(delta) {
    return {
        '.sv': {
            'increment': delta
        }
    };
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * A type for the resolve value of {@link runTransaction}.
 */
var TransactionResult = /** @class */ (function () {
    /** @hideconstructor */
    function TransactionResult(
    /** Whether the transaction was successfully committed. */
    committed, 
    /** The resulting data snapshot. */
    snapshot) {
        this.committed = committed;
        this.snapshot = snapshot;
    }
    /** Returns a JSON-serializable representation of this object. */
    TransactionResult.prototype.toJSON = function () {
        return { committed: this.committed, snapshot: this.snapshot.toJSON() };
    };
    return TransactionResult;
}());
/**
 * Atomically modifies the data at this location.
 *
 * Atomically modify the data at this location. Unlike a normal `set()`, which
 * just overwrites the data regardless of its previous value, `runTransaction()` is
 * used to modify the existing value to a new value, ensuring there are no
 * conflicts with other clients writing to the same location at the same time.
 *
 * To accomplish this, you pass `runTransaction()` an update function which is
 * used to transform the current value into a new value. If another client
 * writes to the location before your new value is successfully written, your
 * update function will be called again with the new current value, and the
 * write will be retried. This will happen repeatedly until your write succeeds
 * without conflict or you abort the transaction by not returning a value from
 * your update function.
 *
 * Note: Modifying data with `set()` will cancel any pending transactions at
 * that location, so extreme care should be taken if mixing `set()` and
 * `runTransaction()` to update the same data.
 *
 * Note: When using transactions with Security and Firebase Rules in place, be
 * aware that a client needs `.read` access in addition to `.write` access in
 * order to perform a transaction. This is because the client-side nature of
 * transactions requires the client to read the data in order to transactionally
 * update it.
 *
 * @param ref - The location to atomically modify.
 * @param transactionUpdate - A developer-supplied function which will be passed
 * the current data stored at this location (as a JavaScript object). The
 * function should return the new value it would like written (as a JavaScript
 * object). If `undefined` is returned (i.e. you return with no arguments) the
 * transaction will be aborted and the data at this location will not be
 * modified.
 * @param options - An options object to configure transactions.
 * @returns A `Promise` that can optionally be used instead of the `onComplete`
 * callback to handle success and failure.
 */
function runTransaction(ref, 
// eslint-disable-next-line @typescript-eslint/no-explicit-any
transactionUpdate, options) {
    var _a;
    ref = getModularInstance(ref);
    validateWritablePath('Reference.transaction', ref._path);
    if (ref.key === '.length' || ref.key === '.keys') {
        throw ('Reference.transaction failed: ' + ref.key + ' is a read-only object.');
    }
    var applyLocally = (_a = options === null || options === void 0 ? void 0 : options.applyLocally) !== null && _a !== void 0 ? _a : true;
    var deferred = new Deferred();
    var promiseComplete = function (error, committed, node) {
        var dataSnapshot = null;
        if (error) {
            deferred.reject(error);
        }
        else {
            dataSnapshot = new DataSnapshot(node, new ReferenceImpl(ref._repo, ref._path), PRIORITY_INDEX);
            deferred.resolve(new TransactionResult(committed, dataSnapshot));
        }
    };
    // Add a watch to make sure we get server updates.
    var unwatcher = onValue(ref, function () { });
    repoStartTransaction(ref._repo, ref._path, transactionUpdate, promiseComplete, unwatcher, applyLocally);
    return deferred.promise;
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
PersistentConnection.prototype.simpleListen = function (pathString, onComplete) {
    this.sendRequest('q', { p: pathString }, onComplete);
};
// eslint-disable-next-line @typescript-eslint/no-explicit-any
PersistentConnection.prototype.echo = function (data, onEcho) {
    this.sendRequest('echo', { d: data }, onEcho);
};
/**
 * @internal
 */
var hijackHash = function (newHash) {
    var oldPut = PersistentConnection.prototype.put;
    PersistentConnection.prototype.put = function (pathString, data, onComplete, hash) {
        if (hash !== undefined) {
            hash = newHash();
        }
        oldPut.call(this, pathString, data, onComplete, hash);
    };
    return function () {
        PersistentConnection.prototype.put = oldPut;
    };
};
/**
 * Forces the RepoManager to create Repos that use ReadonlyRestClient instead of PersistentConnection.
 * @internal
 */
var forceRestClient = function (forceRestClient) {
    repoManagerForceRestClient(forceRestClient);
};

/**
 * Firebase Realtime Database
 *
 * @packageDocumentation
 */
registerDatabase();

export { DataSnapshot, Database, OnDisconnect, QueryConstraint, TransactionResult, QueryImpl as _QueryImpl, QueryParams as _QueryParams, ReferenceImpl as _ReferenceImpl, forceRestClient as _TEST_ACCESS_forceRestClient, hijackHash as _TEST_ACCESS_hijackHash, repoManagerDatabaseFromApp as _repoManagerDatabaseFromApp, setSDKVersion as _setSDKVersion, validatePathString as _validatePathString, validateWritablePath as _validateWritablePath, child, connectDatabaseEmulator, enableLogging, endAt, endBefore, equalTo, forceLongPolling, forceWebSockets, get, getDatabase, goOffline, goOnline, increment, limitToFirst, limitToLast, off, onChildAdded, onChildChanged, onChildMoved, onChildRemoved, onDisconnect, onValue, orderByChild, orderByKey, orderByPriority, orderByValue, push, query, ref, refFromURL, remove, runTransaction, serverTimestamp, set, setPriority, setWithPriority, startAfter, startAt, update };
//# sourceMappingURL=index.esm5.js.map
