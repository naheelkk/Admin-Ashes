"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _template = require("@babel/template");
var _helpersGenerated = require("./helpers-generated.js");
const helpers = Object.assign({
  __proto__: null
}, _helpersGenerated.default);
var _default = exports.default = helpers;
const helper = minVersion => tpl => ({
  minVersion,
  ast: () => _template.default.program.ast(tpl)
});
{
  helpers.AwaitValue = helper("7.0.0-beta.0")`
    export default function _AwaitValue(value) {
      this.wrapped = value;
    }
  `;
}
helpers.wrapAsyncGenerator = helper("7.0.0-beta.0")`
  import AsyncGenerator from "AsyncGenerator";

  export default function _wrapAsyncGenerator(fn) {
    return function () {
      return new AsyncGenerator(fn.apply(this, arguments));
    };
  }
`;
helpers.asyncToGenerator = helper("7.0.0-beta.0")`
  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }

    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }

  export default function _asyncToGenerator(fn) {
    return function () {
      var self = this, args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);
        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }
        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }

        _next(undefined);
      });
    };
  }
`;
helpers.classCallCheck = helper("7.0.0-beta.0")`
  export default function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
`;
helpers.createClass = helper("7.0.0-beta.0")`
  import toPropertyKey from "toPropertyKey";
  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i ++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, toPropertyKey(descriptor.key), descriptor);
    }
  }

  export default function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", { writable: false });
    return Constructor;
  }
`;
{
  helpers.defineEnumerableProperties = helper("7.0.0-beta.0")`
    export default function _defineEnumerableProperties(obj, descs) {
      for (var key in descs) {
        var desc = descs[key];
        desc.configurable = desc.enumerable = true;
        if ("value" in desc) desc.writable = true;
        Object.defineProperty(obj, key, desc);
      }

      // Symbols are not enumerated over by for-in loops. If native
      // Symbols are available, fetch all of the descs object's own
      // symbol properties and define them on our target object too.
      if (Object.getOwnPropertySymbols) {
        var objectSymbols = Object.getOwnPropertySymbols(descs);
        for (var i = 0; i < objectSymbols.length; i++) {
          var sym = objectSymbols[i];
          var desc = descs[sym];
          desc.configurable = desc.enumerable = true;
          if ("value" in desc) desc.writable = true;
          Object.defineProperty(obj, sym, desc);
        }
      }
      return obj;
    }
`;
}
helpers.defaults = helper("7.0.0-beta.0")`
  export default function _defaults(obj, defaults) {
    var keys = Object.getOwnPropertyNames(defaults);
    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      var value = Object.getOwnPropertyDescriptor(defaults, key);
      if (value && value.configurable && obj[key] === undefined) {
        Object.defineProperty(obj, key, value);
      }
    }
    return obj;
  }
`;
helpers.defineProperty = helper("7.0.0-beta.0")`
  import toPropertyKey from "toPropertyKey";
  export default function _defineProperty(obj, key, value) {
    key = toPropertyKey(key);
    // Shortcircuit the slow defineProperty path when possible.
    // We are trying to avoid issues where setters defined on the
    // prototype cause side effects under the fast path of simple
    // assignment. By checking for existence of the property with
    // the in operator, we can optimize most of this overhead away.
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
`;
helpers.extends = helper("7.0.0-beta.0")`
  export default function _extends() {
    _extends = Object.assign ? Object.assign.bind() : function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };

    return _extends.apply(this, arguments);
  }
`;
{
  helpers.objectSpread = helper("7.0.0-beta.0")`
    import defineProperty from "defineProperty";

    export default function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = (arguments[i] != null) ? Object(arguments[i]) : {};
        var ownKeys = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === 'function') {
          ownKeys.push.apply(ownKeys, Object.getOwnPropertySymbols(source).filter(function(sym) {
            return Object.getOwnPropertyDescriptor(source, sym).enumerable;
          }));
        }
        ownKeys.forEach(function(key) {
          defineProperty(target, key, source[key]);
        });
      }
      return target;
    }
  `;
}
helpers.inherits = helper("7.0.0-beta.0")`
  import setPrototypeOf from "setPrototypeOf";

  export default function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }
    // We can't use defineProperty to set the prototype in a single step because it
    // doesn't work in Chrome <= 36. https://github.com/babel/babel/issues/14056
    // V8 bug: https://bugs.chromium.org/p/v8/issues/detail?id=3334
    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    Object.defineProperty(subClass, "prototype", { writable: false });
    if (superClass) setPrototypeOf(subClass, superClass);
  }
`;
helpers.inheritsLoose = helper("7.0.0-beta.0")`
  import setPrototypeOf from "setPrototypeOf";

  export default function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    setPrototypeOf(subClass, superClass);
  }
`;
helpers.getPrototypeOf = helper("7.0.0-beta.0")`
  export default function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf
      ? Object.getPrototypeOf.bind()
      : function _getPrototypeOf(o) {
          return o.__proto__ || Object.getPrototypeOf(o);
        };
    return _getPrototypeOf(o);
  }
`;
helpers.setPrototypeOf = helper("7.0.0-beta.0")`
  export default function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf
      ? Object.setPrototypeOf.bind()
      : function _setPrototypeOf(o, p) {
          o.__proto__ = p;
          return o;
        };
    return _setPrototypeOf(o, p);
  }
`;
helpers.isNativeFunction = helper("7.0.0-beta.0")`
  export default function _isNativeFunction(fn) {
    // Note: This function returns "true" for core-js functions.
    try {
      return Function.toString.call(fn).indexOf("[native code]") !== -1;
    } catch (e) {
      // Firefox 31 throws when "toString" is applied to an HTMLElement
      return typeof fn === "function";
    }
  }
`;
helpers.wrapNativeSuper = helper("7.0.0-beta.0")`
  import getPrototypeOf from "getPrototypeOf";
  import setPrototypeOf from "setPrototypeOf";
  import isNativeFunction from "isNativeFunction";
  import construct from "construct";

  export default function _wrapNativeSuper(Class) {
    var _cache = typeof Map === "function" ? new Map() : undefined;

    _wrapNativeSuper = function _wrapNativeSuper(Class) {
      if (Class === null || !isNativeFunction(Class)) return Class;
      if (typeof Class !== "function") {
        throw new TypeError("Super expression must either be null or a function");
      }
      if (typeof _cache !== "undefined") {
        if (_cache.has(Class)) return _cache.get(Class);
        _cache.set(Class, Wrapper);
      }
      function Wrapper() {
        return construct(Class, arguments, getPrototypeOf(this).constructor)
      }
      Wrapper.prototype = Object.create(Class.prototype, {
        constructor: {
          value: Wrapper,
          enumerable: false,
          writable: true,
          configurable: true,
        }
      });

      return setPrototypeOf(Wrapper, Class);
    }

    return _wrapNativeSuper(Class)
  }
`;
helpers.instanceof = helper("7.0.0-beta.0")`
  export default function _instanceof(left, right) {
    if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) {
      return !!right[Symbol.hasInstance](left);
    } else {
      return left instanceof right;
    }
  }
`;
helpers.interopRequireDefault = helper("7.0.0-beta.0")`
  export default function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
`;
helpers.newArrowCheck = helper("7.0.0-beta.0")`
  export default function _newArrowCheck(innerThis, boundThis) {
    if (innerThis !== boundThis) {
      throw new TypeError("Cannot instantiate an arrow function");
    }
  }
`;
helpers.objectDestructuringEmpty = helper("7.0.0-beta.0")`
  export default function _objectDestructuringEmpty(obj) {
    if (obj == null) throw new TypeError("Cannot destructure " + obj);
  }
`;
helpers.objectWithoutPropertiesLoose = helper("7.0.0-beta.0")`
  export default function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};

    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;

    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }

    return target;
  }
`;
helpers.objectWithoutProperties = helper("7.0.0-beta.0")`
  import objectWithoutPropertiesLoose from "objectWithoutPropertiesLoose";

  export default function _objectWithoutProperties(source, excluded) {
    if (source == null) return {};

    var target = objectWithoutPropertiesLoose(source, excluded);
    var key, i;

    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
      for (i = 0; i < sourceSymbolKeys.length; i++) {
        key = sourceSymbolKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
        target[key] = source[key];
      }
    }

    return target;
  }
`;
helpers.assertThisInitialized = helper("7.0.0-beta.0")`
  export default function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self;
  }
`;
helpers.possibleConstructorReturn = helper("7.0.0-beta.0")`
  import assertThisInitialized from "assertThisInitialized";

  export default function _possibleConstructorReturn(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    } else if (call !== void 0) {
      throw new TypeError("Derived constructors may only return object or undefined");
    }

    return assertThisInitialized(self);
  }
`;
{
  helpers.createSuper = helper("7.9.0")`
    import getPrototypeOf from "getPrototypeOf";
    import isNativeReflectConstruct from "isNativeReflectConstruct";
    import possibleConstructorReturn from "possibleConstructorReturn";

    export default function _createSuper(Derived) {
      var hasNativeReflectConstruct = isNativeReflectConstruct();

      return function _createSuperInternal() {
        var Super = getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          // NOTE: This doesn't work if this.__proto__.constructor has been modified.
          var NewTarget = getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return possibleConstructorReturn(this, result);
      }
    }
`;
}
helpers.superPropBase = helper("7.0.0-beta.0")`
  import getPrototypeOf from "getPrototypeOf";

  export default function _superPropBase(object, property) {
    // Yes, this throws if object is null to being with, that's on purpose.
    while (!Object.prototype.hasOwnProperty.call(object, property)) {
      object = getPrototypeOf(object);
      if (object === null) break;
    }
    return object;
  }
`;
helpers.get = helper("7.0.0-beta.0")`
  import superPropBase from "superPropBase";

  export default function _get() {
    if (typeof Reflect !== "undefined" && Reflect.get) {
      _get = Reflect.get.bind();
    } else {
      _get = function _get(target, property, receiver) {
        var base = superPropBase(target, property);

        if (!base) return;

        var desc = Object.getOwnPropertyDescriptor(base, property);
        if (desc.get) {
          // STEP 3. If receiver is not present, then set receiver to target.
          return desc.get.call(arguments.length < 3 ? target : receiver);
        }

        return desc.value;
      };
    }
    return _get.apply(this, arguments);
  }
`;
helpers.set = helper("7.0.0-beta.0")`
  import superPropBase from "superPropBase";
  import defineProperty from "defineProperty";

  function set(target, property, value, receiver) {
    if (typeof Reflect !== "undefined" && Reflect.set) {
      set = Reflect.set;
    } else {
      set = function set(target, property, value, receiver) {
        var base = superPropBase(target, property);
        var desc;

        if (base) {
          desc = Object.getOwnPropertyDescriptor(base, property);
          if (desc.set) {
            desc.set.call(receiver, value);
            return true;
          } else if (!desc.writable) {
            // Both getter and non-writable fall into this.
            return false;
          }
        }

        // Without a super that defines the property, spec boils down to
        // "define on receiver" for some reason.
        desc = Object.getOwnPropertyDescriptor(receiver, property);
        if (desc) {
          if (!desc.writable) {
            // Setter, getter, and non-writable fall into this.
            return false;
          }

          desc.value = value;
          Object.defineProperty(receiver, property, desc);
        } else {
          // Avoid setters that may be defined on Sub's prototype, but not on
          // the instance.
          defineProperty(receiver, property, value);
        }

        return true;
      };
    }

    return set(target, property, value, receiver);
  }

  export default function _set(target, property, value, receiver, isStrict) {
    var s = set(target, property, value, receiver || target);
    if (!s && isStrict) {
      throw new TypeError('failed to set property');
    }

    return value;
  }
`;
helpers.taggedTemplateLiteral = helper("7.0.0-beta.0")`
  export default function _taggedTemplateLiteral(strings, raw) {
    if (!raw) { raw = strings.slice(0); }
    return Object.freeze(Object.defineProperties(strings, {
        raw: { value: Object.freeze(raw) }
    }));
  }
`;
helpers.taggedTemplateLiteralLoose = helper("7.0.0-beta.0")`
  export default function _taggedTemplateLiteralLoose(strings, raw) {
    if (!raw) { raw = strings.slice(0); }
    strings.raw = raw;
    return strings;
  }
`;
helpers.readOnlyError = helper("7.0.0-beta.0")`
  export default function _readOnlyError(name) {
    throw new TypeError("\\"" + name + "\\" is read-only");
  }
`;
helpers.writeOnlyError = helper("7.12.13")`
  export default function _writeOnlyError(name) {
    throw new TypeError("\\"" + name + "\\" is write-only");
  }
`;
helpers.classNameTDZError = helper("7.0.0-beta.0")`
  export default function _classNameTDZError(name) {
    throw new ReferenceError("Class \\"" + name + "\\" cannot be referenced in computed property keys.");
  }
`;
helpers.temporalUndefined = helper("7.0.0-beta.0")`
  // This function isn't mean to be called, but to be used as a reference.
  // We can't use a normal object because it isn't hoisted.
  export default function _temporalUndefined() {}
`;
helpers.tdz = helper("7.5.5")`
  export default function _tdzError(name) {
    throw new ReferenceError(name + " is not defined - temporal dead zone");
  }
`;
helpers.temporalRef = helper("7.0.0-beta.0")`
  import undef from "temporalUndefined";
  import err from "tdz";

  export default function _temporalRef(val, name) {
    return val === undef ? err(name) : val;
  }
`;
helpers.slicedToArray = helper("7.0.0-beta.0")`
  import arrayWithHoles from "arrayWithHoles";
  import iterableToArrayLimit from "iterableToArrayLimit";
  import unsupportedIterableToArray from "unsupportedIterableToArray";
  import nonIterableRest from "nonIterableRest";

  export default function _slicedToArray(arr, i) {
    return (
      arrayWithHoles(arr) ||
      iterableToArrayLimit(arr, i) ||
      unsupportedIterableToArray(arr, i) ||
      nonIterableRest()
    );
  }
`;
helpers.slicedToArrayLoose = helper("7.0.0-beta.0")`
  import arrayWithHoles from "arrayWithHoles";
  import iterableToArrayLimitLoose from "iterableToArrayLimitLoose";
  import unsupportedIterableToArray from "unsupportedIterableToArray";
  import nonIterableRest from "nonIterableRest";

  export default function _slicedToArrayLoose(arr, i) {
    return (
      arrayWithHoles(arr) ||
      iterableToArrayLimitLoose(arr, i) ||
      unsupportedIterableToArray(arr, i) ||
      nonIterableRest()
    );
  }
`;
helpers.toArray = helper("7.0.0-beta.0")`
  import arrayWithHoles from "arrayWithHoles";
  import iterableToArray from "iterableToArray";
  import unsupportedIterableToArray from "unsupportedIterableToArray";
  import nonIterableRest from "nonIterableRest";

  export default function _toArray(arr) {
    return (
      arrayWithHoles(arr) ||
      iterableToArray(arr) ||
      unsupportedIterableToArray(arr) ||
      nonIterableRest()
    );
  }
`;
helpers.toConsumableArray = helper("7.0.0-beta.0")`
  import arrayWithoutHoles from "arrayWithoutHoles";
  import iterableToArray from "iterableToArray";
  import unsupportedIterableToArray from "unsupportedIterableToArray";
  import nonIterableSpread from "nonIterableSpread";

  export default function _toConsumableArray(arr) {
    return (
      arrayWithoutHoles(arr) ||
      iterableToArray(arr) ||
      unsupportedIterableToArray(arr) ||
      nonIterableSpread()
    );
  }
`;
helpers.arrayWithoutHoles = helper("7.0.0-beta.0")`
  import arrayLikeToArray from "arrayLikeToArray";

  export default function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return arrayLikeToArray(arr);
  }
`;
helpers.arrayWithHoles = helper("7.0.0-beta.0")`
  export default function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }
`;
helpers.maybeArrayLike = helper("7.9.0")`
  import arrayLikeToArray from "arrayLikeToArray";

  export default function _maybeArrayLike(next, arr, i) {
    if (arr && !Array.isArray(arr) && typeof arr.length === "number") {
      var len = arr.length;
      return arrayLikeToArray(arr, i !== void 0 && i < len ? i : len);
    }
    return next(arr, i);
  }
`;
helpers.iterableToArray = helper("7.0.0-beta.0")`
  export default function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
  }
`;
helpers.unsupportedIterableToArray = helper("7.9.0")`
  import arrayLikeToArray from "arrayLikeToArray";

  export default function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return arrayLikeToArray(o, minLen);
  }
`;
helpers.arrayLikeToArray = helper("7.9.0")`
  export default function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
    return arr2;
  }
`;
helpers.nonIterableSpread = helper("7.0.0-beta.0")`
  export default function _nonIterableSpread() {
    throw new TypeError(
      "Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
    );
  }
`;
helpers.nonIterableRest = helper("7.0.0-beta.0")`
  export default function _nonIterableRest() {
    throw new TypeError(
      "Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
    );
  }
`;
helpers.createForOfIteratorHelper = helper("7.9.0")`
  import unsupportedIterableToArray from "unsupportedIterableToArray";

  // s: start (create the iterator)
  // n: next
  // e: error (called whenever something throws)
  // f: finish (always called at the end)

  export default function _createForOfIteratorHelper(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];

    if (!it) {
      // Fallback for engines without symbol support
      if (
        Array.isArray(o) ||
        (it = unsupportedIterableToArray(o)) ||
        (allowArrayLike && o && typeof o.length === "number")
      ) {
        if (it) o = it;
        var i = 0;
        var F = function(){};
        return {
          s: F,
          n: function() {
            if (i >= o.length) return { done: true };
            return { done: false, value: o[i++] };
          },
          e: function(e) { throw e; },
          f: F,
        };
      }

      throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }

    var normalCompletion = true, didErr = false, err;

    return {
      s: function() {
        it = it.call(o);
      },
      n: function() {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      },
      e: function(e) {
        didErr = true;
        err = e;
      },
      f: function() {
        try {
          if (!normalCompletion && it.return != null) it.return();
        } finally {
          if (didErr) throw err;
        }
      }
    };
  }
`;
helpers.createForOfIteratorHelperLoose = helper("7.9.0")`
  import unsupportedIterableToArray from "unsupportedIterableToArray";

  export default function _createForOfIteratorHelperLoose(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];

    if (it) return (it = it.call(o)).next.bind(it);

    // Fallback for engines without symbol support
    if (
      Array.isArray(o) ||
      (it = unsupportedIterableToArray(o)) ||
      (allowArrayLike && o && typeof o.length === "number")
    ) {
      if (it) o = it;
      var i = 0;
      return function() {
        if (i >= o.length) return { done: true };
        return { done: false, value: o[i++] };
      }
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
`;
helpers.skipFirstGeneratorNext = helper("7.0.0-beta.0")`
  export default function _skipFirstGeneratorNext(fn) {
    return function () {
      var it = fn.apply(this, arguments);
      it.next();
      return it;
    }
  }
`;
helpers.initializerWarningHelper = helper("7.0.0-beta.0")`
    export default function _initializerWarningHelper(descriptor, context){
        throw new Error(
          'Decorating class property failed. Please ensure that ' +
          'transform-class-properties is enabled and runs after the decorators transform.'
        );
    }
`;
helpers.initializerDefineProperty = helper("7.0.0-beta.0")`
    export default function _initializerDefineProperty(target, property, descriptor, context){
        if (!descriptor) return;

        Object.defineProperty(target, property, {
            enumerable: descriptor.enumerable,
            configurable: descriptor.configurable,
            writable: descriptor.writable,
            value: descriptor.initializer ? descriptor.initializer.call(context) : void 0,
        });
    }
`;
helpers.applyDecoratedDescriptor = helper("7.0.0-beta.0")`
    export default function _applyDecoratedDescriptor(target, property, decorators, descriptor, context){
        var desc = {};
        Object.keys(descriptor).forEach(function(key){
            desc[key] = descriptor[key];
        });
        desc.enumerable = !!desc.enumerable;
        desc.configurable = !!desc.configurable;
        if ('value' in desc || desc.initializer){
            desc.writable = true;
        }

        desc = decorators.slice().reverse().reduce(function(desc, decorator){
            return decorator(target, property, desc) || desc;
        }, desc);

        if (context && desc.initializer !== void 0){
            desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
            desc.initializer = undefined;
        }

        if (desc.initializer === void 0){
            Object.defineProperty(target, property, desc);
            desc = null;
        }

        return desc;
    }
`;
helpers.classPrivateFieldLooseKey = helper("7.0.0-beta.0")`
  var id = 0;
  export default function _classPrivateFieldKey(name) {
    return "__private_" + (id++) + "_" + name;
  }
`;
helpers.classPrivateFieldLooseBase = helper("7.0.0-beta.0")`
  export default function _classPrivateFieldBase(receiver, privateKey) {
    if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {
      throw new TypeError("attempted to use private field on non-instance");
    }
    return receiver;
  }
`;
helpers.classPrivateFieldGet = helper("7.0.0-beta.0")`
  import classApplyDescriptorGet from "classApplyDescriptorGet";
  import classPrivateFieldGet2 from "classPrivateFieldGet2";
  export default function _classPrivateFieldGet(receiver, privateMap) {
    var descriptor = classPrivateFieldGet2(privateMap, receiver);
    return classApplyDescriptorGet(receiver, descriptor);
  }
`;
helpers.classPrivateFieldSet = helper("7.0.0-beta.0")`
  import classApplyDescriptorSet from "classApplyDescriptorSet";
  import classPrivateFieldGet2 from "classPrivateFieldGet2";
  export default function _classPrivateFieldSet(receiver, privateMap, value) {
    var descriptor = classPrivateFieldGet2(privateMap, receiver);
    classApplyDescriptorSet(receiver, descriptor, value);
    return value;
  }
`;
helpers.classPrivateFieldDestructureSet = helper("7.4.4")`
  import classApplyDescriptorDestructureSet from "classApplyDescriptorDestructureSet";
  import classPrivateFieldGet2 from "classPrivateFieldGet2";
  export default function _classPrivateFieldDestructureSet(receiver, privateMap) {
    var descriptor = classPrivateFieldGet2(privateMap, receiver);
    return classApplyDescriptorDestructureSet(receiver, descriptor);
  }
`;
helpers.classExtractFieldDescriptor = helper("7.13.10")`
  import classPrivateFieldGet2 from "classPrivateFieldGet2";

  export default function _classExtractFieldDescriptor(receiver, privateMap) {
    return classPrivateFieldGet2(privateMap, receiver);
  }
`;
helpers.classStaticPrivateFieldSpecGet = helper("7.0.2")`
  import classApplyDescriptorGet from "classAppla"
    }
    Component {
        prototype: "QQuickTumbler"
        name: "QtQuick.Controls/Tumbler 2.0"
        exports: ["QtQuick.Controls/Tumbler 2.0"]
        exportMetaObjectRevisions: [0]
        isComposite: true
        defaultProperty: "data"
    }
    Component {
        prototype: "QQuickVerticalHeaderView"
        name: "QtQuick.Controls/VerticalHeaderView 2.15"
        exports: ["QtQuick.Controls/VerticalHeaderView 2.15"]
        exportMetaObjectRevisions: [15]
        isComposite: true
        defaultProperty: "flickableData"
    }
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ssStaticPrivateMethodGet = helper("7.3.2")`
  import assertClassBrand from "assertClassBrand";
  export default function _classStaticPrivateMethodGet(receiver, classConstructor, method) {
    assertClassBrand(classConstructor, receiver);
    return method;
  }
`;
helpers.classStaticPrivateMethodSet = helper("7.3.2")`
  export default function _classStaticPrivateMethodSet() {
    throw new TypeError("attempted to set read only static private field");
  }
`;
helpers.classApplyDescriptorGet = helper("7.13.10")`
  export default function _classApplyDescriptorGet(receiver, descriptor) {
    if (descriptor.get) {
      return descriptor.get.call(receiver);
    }
    return descriptor.value;
  }
`;
helpers.classApplyDescriptorSet = helper("7.13.10")`
  export default function _classApplyDescriptorSet(receiver, descriptor, value) {
    if (descriptor.set) {
      descriptor.set.call(receiver, value);
    } else {
      if (!descriptor.writable) {
        // This should only throw in strict mode, but class bodies are
        // always strict and private fields can only be used inside
        // class bodies.
        throw new TypeError("attempted to set read only private field");
      }
      descriptor.value = value;
    }
  }
`;
helpers.classApplyDescriptorDestructureSet = helper("7.13.10")`
  export default function _classApplyDescriptorDestructureSet(receiver, descriptor) {
    if (descriptor.set) {
      if (!("__destrObj" in descriptor)) {
        descriptor.__destrObj = {
          set value(v) {
            descriptor.set.call(receiver, v)
          },
        };
      }
      return descriptor.__destrObj;
    } else {
      if (!descriptor.writable) {
        // This should only throw in strict mode, but class bodies are
        // always strict and private fields can only be used inside
        // class bodies.
        throw new TypeError("attempted to set read only private field");
      }

      return descriptor;
    }
  }
`;
helpers.classStaticPrivateFieldDestructureSet = helper("7.13.10")`
  import classApplyDescriptorDestructureSet from "classApplyDescriptorDestructureSet";
  import assertClassBrand from "assertClassBrand";
  import classCheckPrivateStaticFieldDescriptor from "classCheckPrivateStaticFieldDescriptor";
  export default function _classStaticPrivateFieldDestructureSet(receiver, classConstructor, descriptor) {
    assertClassBrand(classConstructor, receiver);
    classCheckPrivateStaticFieldDescriptor(descriptor, "set");
    return classApplyDescriptorDestructureSet(receiver, descriptor);
  }
`;
helpers.classCheckPrivateStaticAccess = helper("7.13.10")`
  import assertClassBrand from "assertClassBrand";
  export default function _classCheckPrivateStaticAccess(receiver, classConstructor, returnValue) {
    return assertClassBrand(classConstructor, receiver, returnValue);
  }
`;
helpers.classCheckPrivateStaticFieldDescriptor = helper("7.13.10")`
  export default function _classCheckPrivateStaticFieldDescriptor(descriptor, action) {
    if (descriptor === undefined) {
      throw new TypeError("attem{
  "WalletECNewCtaDescriptionCashback": "캐시백 프로그램 활성화",
  "WalletECNewCtaDescriptionCoupon": "쿠폰 자동 적용",
  "WalletECNewCtaDescriptionFillAddress": "배송 정보 자동 채우기",
  "WalletECNewCtaDescriptionFillDetail": "배송 및 청구 정보 입력",
  "WalletECNewCtaDescriptionFillPayment": "청구 정보 입력",
  "WalletECNewCtaDescriptionGiftCard": "기프트 카드 사용",
  "WalletECNewCtaDescriptionTakeToBNPL": "$1(으)로 이동",
  "WalletECNewUXErrorMessageForAutofill": "자동 채우기에서 모든 세부 정보를 완료할 수 없습니다. 구매를 완료하려면 수동으로 입력하세요.",
  "WalletECNewUXErrorMessageForCashback": "지금은 구매에 캐시백을 적용할 수 없습니다. 나중에 다시 시도하세요.",
  "WalletECNewUXErrorMessageForCoupon": "쿠폰 테스트는 현재 사용할 수 없지만 수동으로 쿠폰을 테스트할 수 있습니다.",
  "WalletECNewUXForNoSuccessMessage": "죄송합니다. 지금은 도와드릴 수 없습니다.",
  "WalletECNewUXForNoSuccessMessageOptimized": "흠. 작동하지 않습니다. 다시 시도하세요.",
  "WalletECNewUXForNoWorkingCoupon": "작동하는 쿠폰을 찾지 못했습니다.",
  "WalletECNewUXMultiErrorMessageForAutofill": "자동 채우기",
  "WalletECNewUXMultiErrorMessageForCashback": "캐시백",
  "WalletECNewUXMultiErrorMessageForCoupon": "쿠폰",
  "WalletECNewUXPartialSuccessMessageForAutofill": "일부 세부 정보가 입력되었습니다. 구매를 완료하려면 나머지 정보를 입력하세요.",
  "WalletECNewUXSSuccessMessageForCouponAndGiftCard": "이미 최상의 쿠폰과 기프트 카드로 $1를 절약했습니다.",
  "WalletECNewUXSSuccessMessagegiftCardInfo": "$2에 $1 Microsoft Rewards 포인트를 사용했습니다.",
  "WalletECNewUXSuccessMessageForAutofill": "구매하기 세부 정보가 입력되었습니다.",
  "WalletECNewUXSuccessMessageForCashback": "최대 $1의 캐시백 $2를 받게 됩니다.",
  "WalletECNewUXSuccessMessageForCoupon": "이미 최상의 쿠폰으로 $1를 절약했습니다.",
  "WalletECNewUXSuccessMessageForGiftCard": "기프트 카드로 $1를 이미 절약했습니다.",
  "WalletECSimplifyAutofillSubTitle": "켜서 자동 채우기 사용",
  "WalletECSimplifyAutofillTitle": "구매하기 세부 정보 자동 완성",
  "WalletECUXSimplifyCtaDescriptionSaving": "할인 적용",
  "walletBNPLSmallCardBottomMessagePayInFour": "$1는 이자가 있는 월별 결제도 제공합니다.",
  "walletBNPLSmallCardBottomMessageZip": "Zip은 이자가 있는 월별 결제도 제공합니다.",
  "walletBNPLSmallCardFooterMessage": "Microsoft는 사용자에게 요금을 부과하거나 이러한 공급자로부터 결제를 받지 않습니다.",
  "walletBNPLSmallCardTitle": "구매는 4번의 할부로 분할됩니다.",
  "walletBNPLSmallCardTitleBothFinancedAndPayInFour": "구매는 4회 할부로 분할할 수 있습니다.",
  "walletChangeYourSettings": "설정 변경",
  "walletDrawerFormPageMicroFeedbackPrompt": "전자지갑에 만족하셨나요?",
  "walletDrawerGiftCardAuofillMultipleFailureTitle": "기프트 카드를 이 주문에 자동으로 적용합니다. 전자 메일에서 기프트 카드 번호를 확인한 다음 수동으로 입력하여 사용합니다.",
  "walletDrawerGiftCardAutofillFailureTitle": "기프트 카드를 이 주문에 자동으로 적용할 수 없습니다. 전자 메일에서 기프트 카드 번호를 확인한 다음 수동으로 입력하여 사용합니다.",
  "walletDrawerGiftCardRedeemFailureTitle": "Rewards 포인트를 기프트 카드로 사용할 수 없습니다. 주문을 계속하거나 나중에 트랜잭션을 다시 시도할 수 있습니다.",
  "walletDrawerGiftCardRedeemMultipleFailureTitle": "Rewards 포인트를 기프트 카드로 사용하세요.",
  "walletECAllFailureMessageBottom": "걱정하지 마세요. 트랜잭션을 계속할 수 있습니다.",
  "walletECAllFailureTitle": "현재 사용할 수 없는 기능은 다음과 같습니다.",
  "walletECApplyCashBackTitle": "캐쉬백",
  "walletECApplyCashCackTitle": "최대 $1의 현금이 지급됩니다.",
  "walletECApplySavingTitle": "$1을(를) 절약하면 최대 $2의 현금이 절약됩니다.",
  "walletECAutoApplyApplyingBestCouponsNew": "검색된 최상의 쿠폰을 적용하는 중...",
  "walletECAutoApplyFailureTitle": "쿠폰 테스트는 현재 사용할 수 없지만 수동으로 쿠폰을 테스트할 수 있습니다.",
  "walletECAutoApplyFeature": "쿠폰 테스트",
  "walletECAutoApplyTryingCoupons": "$1를 시도하는 중...",
  "walletECAutofillErrorMessage": "세부 정보 자동 채우기",
  "walletECAutofillPaymentOnlySingleErrorMessage": "자동 채우기에서 모든 세부 정보를 완료할 수 없습니다. 트랜잭션을 계속하려면 수동으로 입력하세요.",
  "walletECAutofillPaymentOnlySuccessMessage": "빠르게 구매할 수 있도록 결제 세부 정보를 자동으로 채웠습니다.",
  "walletECBrandFooter": "Microsoft 전자지갑 제공",
  "walletECCancelCouponButton": "쿠폰 건너뛰기",
  "walletECCancelCouponFooter": "사용자의 45%가 쿠폰으로 절약",
  "walletECCancelCouponStatus": "쿠폰 적용이 취소됨",
  "walletECCashBackAndCouponTitle": "캐쉬백 및 쿠폰",
  "walletECCashBackDisplayValue": "최대 $1",
  "walletECCashBackEnableErrorMessage": "지금은 구매에 캐쉬백을 적용할 수 없습니다. 나중에 다시 시도하세요.",
  "walletECCashBackEnableSubErrorMessage": "캐쉬백 활성화",
  "walletECCashBackInfo": "$1에 전자 메일 업데이트를 받고 캐쉬백 세부 정보를 추적합니다.",
  "walletECCashBackOptionText": "캐시백 받기",
  "walletECCashBackUpto": "최대 $1",
  "walletECCashbackActivateFailedLabel": "이 구매에 대한 캐시백을 활성화할 수 없습니다. 나중에 다시 시도하세요.",
  "walletECCashbackActivateLabel": "캐쉬백 활성화",
  "walletECCashbackEnrollDisclaimer": "Microsoft Edge에 로그인하면 검색 데이터를 백업하고 모든 장치에서 즐겨찾기, 암호 기록 등을 볼 수 있습니다. 또한 파트너 제품에 대한 제안을 포함하여 $1에 대한 전자 메일에 가입하고 받게 됩니다. $2 | $3",
  "walletECCashbackLinkLabel": "$1에 대한 제품 세부 정보 보기",
  "walletECCashbackPrivacyLinkLabel": "개인정보처리방침",
  "walletECCashbackSigninLabel": "지금 가입하고 캐시백 활성화",
  "walletECCashbackStatus": "캐쉬백 활성화됨",
  "walletECCashbackTermsLinkLabel": "사용 약관",
  "walletECContinueSavingsAndFillDetailsButtonLabel": "할인을 적용하고 계속",
  "walletECContinueSavingsAndFillDetailsLabel": "계속하면 캐시백 프로그램이 활성화되고 쿠폰이 자동으로 적용되며 배송 및 청구 정보가 채워집니다.",
  "walletECContinueSavingsAndFillDetailsLabelBNPL": "계속하면 캐쉬백 프로그램이 활성화되고 쿠폰을 자동으로 적용하고 배송을 자동으로 채우고 $1(으)로 안내합니다",
  "walletECContinueSavingsAndFillDetailsNoCouponLabel": "계속하면 캐쉬백 프로그램을 활성화하고 배송 및 청구 정보를 입력합니다.",
  "walletECContinueSavingsAndFillDetailsNoCouponLabelBNPL": "계속하면 캐쉬백 프로그램을 활성화하고 배송을 자동으로 채워 $1(으)로 안내합니다.",
  "walletECContinueSavingsButtonLabel": "할인 적용",
  "walletECContinueSavingsLabel": "계속하면 캐시백 프로그램이 활성화되고 쿠폰이 자동으로 적용됩니다.",
  "walletECContinueSavingsNoCouponLabel": "계속하면 캐쉬백 프로그램을 활성화합니다.",
  "walletECCopyButtonCopied": "복사했습니다!",
  "walletECCouponAverageSaving": "평균적으로 $1을(를) 저장함",
  "walletECCouponOptionText": "쿠폰 사용",
  "walletECCouponSkipAndNoSavingMessage": "더 많은 쿠폰을 사용하여 절약해 보세요.",
  "walletECCouponSkipAndNoSavingTitle": "유효한 쿠폰을 건너뛰었을 수 있습니다.",
  "walletECCouponsCookieDisclaimer": "$2에 따라 쿠폰 공급자와 결제를 돕기 위해 내 장치에 $1을(를) 배치하는 것을 허용합니다.",
  "walletECCouponsCookieDisclaimerPrivacyLinkLabel": "Microsoft 개인정보처리방침",
  "walletECDismiss": "해제",
  "walletECEnjoyMessage": "쇼핑 여정을 계속해서 즐기세요.",
  "walletECFillDetailsButtonLabelUXSimplify": "세부 정보 채우기",
  "walletECFreBannerContent": "결제하기 전에 쿠폰과 캐시백으로 최상의 거래를 찾아보세요.",
  "walletECFreBannerTitle": "Microsoft Edge 전자지갑으로 비용 및 시간 절약",
  "walletECGetCashbackLabel": "$2에 최대 $1 캐쉬백을 받을 수 있습니다",
  "walletECGiftCardTitle": "기프트 카드",
  "walletECHumanInteractionContentForA": "계속하려면 가맹점 사이트에서 필수 필드를 채우세요.",
  "walletECHumanInteractionContentForB": "가맹점 사이트에서 아직 채워야 하는 필수 필드가 있습니다.",
  "walletECHumanInteractionErrorMessage": "누락된 세부 정보를 완료하여 계속 진행",
  "walletECHumanInteractionTitleForA": "전체 세부 정보",
  "walletECHumanInteractionTitleForB": "추가 세부 정보 필요",
  "walletECManagePersonalInfo": "개인 정보 관리",
  "walletECMaskedCardDetailFetching": "계속하려면 CVC를 입력하세요.",
  "walletECMaskedFetchErrorMessage": "다시 시도하고 메시지가 표시되면 CVC를 입력하세요. 또는 계속하려면 다른 결제 방법을 선택하세요.",
  "walletECNewCtaDescriptionTemplateFive": "계속하면 $1, $2, $3, $4 및 $5이(가) 됩니다.",
  "walletECNewCtaDescriptionTemplateFour": "계속하면 $1, $2, $3 및 $4이(가) 됩니다.",
  "walletECNewCtaDescriptionTemplateOne": "계속하면 $1이(가) 됩니다.",
  "walletECNewCtaDescriptionTemplateThree": "계속하면 $1, $2 및 $3이(가) 됩니다.",
  "walletECNewCtaDescriptionTemplateTwo": "계속하면 $1 및 $2이(가) 됩니다.",
  "walletECNewShippingAddressTitle": "우편물 세부 정보",
  "walletECNewUXErrorMessageTemplateFive": "지금은 $1, $2, $3, $4 및 $5를 사용할 수 없습니다. 걱정하지 마세요. 여전히 트랜잭션을 완료할 수 있습니다.",
  "walletECNewUXErrorMessageTemplateFour": "지금은 $1, $2, $3 및 $4를 사용할 수 없습니다. 걱정하지 마세요. 여전히 트랜잭션을 완료할 수 있습니다.",
  "walletECNewUXErrorMessageTemplateThree": "지금은 $1, $2 및 $3를 사용할 수 없습니다. 걱정하지 마세요. 여전히 트랜잭션을 완료할 수 있습니다.",
  "walletECNewUXErrorMessageTemplateTwo": "지금은 $1 및 $2를 사용할 수 없습니다. 걱정하지 마세요. 여전히 트랜잭션을 완료할 수 있습니다.",
  "walletECNewUXSSuccessMessageForCouponAndGiftCardOptimized": "최고의 쿠폰 $2 및 기프트 카드로 $1을(를) 절약했습니다!",
  "walletECNewUXSSuccessMessageForCouponSkipButSucceedAndGiftCard": "최상의 쿠폰 $2 및 기프트 카드로 $1을(를) 절약했지만, 더 많은 쿠폰을 사용해 보면 더 많은 비용을 절약할 수 있습니다.",
  "walletECNewUXSuccessMessageForCouponOptimized": "최고의 쿠폰인 $2로 $1을(를) 절약했습니다!",
  "walletECNewUXSuccessMessageForCouponSkipButSucceed": "$2을(를) 사용하여 $1을(를) 절약했지만, 더 많은 쿠폰을 사용해 보면 더 많은 비용을 절약할 수 있습니다.",
  "walletECNewUXSuccessMessageForGiftCardOptimized": "기프트 카드로 $1을(를) 절약했습니다.",
  "walletECNoSavedAddress": "저장된 주소 없음",
  "walletECNoSavedName": "저장된 이름 없음",
  "walletECRebatesCouponsSelectorDescription": "가장 적합한 할인 혜택을 적용하였으며 이 구매에 하나만 사용할 수 있음을 확인했습니다. 계속하려면 아래 중 하나를 선택하세요.",
  "walletECRebatesCouponsSelectorTitle": "계속하려면 하나를 선택하세요.",
  "walletECReturnToCheckoutButtonAria": "창을 닫고 구매하기 페이지로 돌아가기",
  "walletECRewardsAutofillFailureCopyMessage": ement);
        if (
          placement !== "static" &&
          placement !== "prototype" &&
          placement !== "own"
        ) {
          throw new TypeError(
            'An element descriptor\\'s .placement property must be one of "static",' +
              ' "prototype" or "own", but a decorator created an element descriptor' +
              ' with .placement "' +
              placement +
              '"',
          );
        }

        var descriptor /*: PropertyDescriptor */ = elementObject.descriptor;

        this.disallowProperty(elementObject, "elements", "An element descriptor");

        var element /*: ElementDescriptor */ = {
          kind: kind,
          key: key,
          placement: placement,
          descriptor: Object.assign({}, descriptor),
        };

        if (kind !== "field") {
          this.disallowProperty(elementObject, "initializer", "A method descriptor");
        } else {
          this.disallowProperty(
            descriptor,
            "get",
            "The property descriptor of a field descriptor",
          );
          this.disallowProperty(
            descriptor,
            "set",
            "The property descriptor of a field descriptor",
          );
          this.disallowProperty(
            descriptor,
            "value",
            "The property descriptor of a field descriptor",
          );

          element.initializer = elementObject.initializer;
        }

        return element;
      },

      toElementFinisherExtras: function(
        elementObject /*: ElementObject */,
      ) /*: ElementFinisherExtras */ {
        var element /*: ElementDescriptor */ = this.toElementDescriptor(
          elementObject,
        );
        var finisher /*: ClassFinisher */ = _optionalCallableProperty(
          elementObject,
          "finisher",
        );
        var extras /*: ElementDescriptors[] */ = this.toElementDescriptors(
          elementObject.extras,
        );

        return { element: element, finisher: finisher, extras: extras };
      },

      // FromClassDescriptor
      fromClassDescriptor: function(
        elements /*: ElementDescriptor[] */,
      ) /*: ClassObject */ {
        var obj = {
          kind: "class",
          elements: elements.map(this.fromElementDescriptor, this),
        };

        var desc = { value: "Descriptor", configurable: true };
        Object.defineProperty(obj, Symbol.toStringTag, desc);

        return obj;
      },

      // ToClassDescriptor
      toClassDescriptor: function(
        obj /*: ClassObject */,
      ) /*: ElementsFinisher */ {
        var kind = String(obj.kind);
        if (kind !== "class") {
          throw new TypeError(
            'A class descriptor\\'s .kind property must be "class", but a decorator' +
              ' created a class descriptor with .kind "' +
              kind +
              '"',
          );
        }

        this.disallowProperty(obj, "key", "A class descriptor");
        this.disallowProperty(obj, "placement", "A class descriptor");
        this.disallowProperty(obj, "descriptor", "A class descriptor");
        this.disallowProperty(obj, "initializer", "A class descriptor");
        this.disallowProperty(obj, "extras", "A class descriptor");

        var finisher = _optionalCallableProperty(obj, "finisher");
        var elements = this.toElementDescriptors(obj.elements);

        return { elements: elements, finisher: finisher };
      },

      // RunClassFinishers
      runClassFinishers: function(
        constructor /*: Class<*> */,
        finishers /*: ClassFinisher[] */,
      ) /*: Class<*> */ {
        for (var i = 0; i < finishers.length; i++) {
          var newConstructor /*: ?Class<*> */ = (0, finishers[i])(constructor);
          if (newConstructor !== undefined) {
            // NOTE: This should check if IsConstructor(newConstructor) is false.
            if (typeof newConstructor !== "function") {
              throw new TypeError("Finishers must return a constructor.");
            }
            constructor = newConstructor;
          }
        }
        return constructor;
      },

      disallowProperty: function(obj, name, objectType) {
        if (obj[name] !== undefined) {
          throw new TypeError(objectType + " can't have a ." + name + " property.");
        }
      }
    };

    return api;
  }

  // ClassElementEvaluation
  function _createElementDescriptor(
    def /*: ElementDefinition */,
  ) /*: ElementDescriptor */ {
    var key = toPropertyKey(def.key);

    var descriptor /*: PropertyDescriptor */;
    if (def.kind === "method") {
      descriptor = {
        value: def.value,
        writable: true,
        configurable: true,
        enumerable: false,
      };
    } else if (def.kind === "get") {
      descriptor = { get: def.value, configurable: true, enumerable: false };
    } else if (def.kind === "set") {
      descriptor = { set: def.value, configurable: true, enumerable: false };
    } else if (def.kind === "field") {
      descriptor = { configurable: true, writable: true, enumerable: true };
    }

    var element /*: ElementDescriptor */ = {
      kind: def.kind === "field" ? "field" : "method",
      key: key,
      placement: def.static
        ? "static"
        : def.kind === "field"
        ? "own"
        : "prototype",
      descriptor: descriptor,
    };
    if (def.decorators) element.decorators = def.decorators;
    if (def.kind === "field") element.initializer = def.value;

    return element;
  }

  // CoalesceGetterSetter
  function _coalesceGetterSetter(
    element /*: ElementDescriptor */,
    other /*: ElementDescriptor */,
  ) {
    if (element.descriptor.get !== undefined) {
      other.descriptor.get = element.descriptor.get;
    } else {
      other.descriptor.set = element.descriptor.set;
    }
  }

  // CoalesceClassElements
  function _coalesceClassElements(
    elements /*: ElementDescriptor[] */,
  ) /*: ElementDescriptor[] */ {
    var newElements /*: ElementDescriptor[] */ = [];

    var isSameElement = function(
      other /*: ElementDescriptor */,
    ) /*: boolean */ {
      return (
        other.kind === "method" &&
        other.key === element.key &&
        other.placement === element.placement
      );
    };

    for (var i = 0; i < elements.length; i++) {
      var element /*: ElementDescriptor */ = elements[i];
      var other /*: ElementDescriptor */;

      if (
        element.kind === "method" &&
        (other = newElements.find(isSameElement))
      ) {
        if (
          _isDataDescriptor(element.descriptor) ||
          _isDataDescriptor(other.descriptor)
        ) {
          if (_hasDecorators(element) || _hasDecorators(other)) {
            throw new ReferenceError(
              "Duplicated methods (" + element.key + ") can't be decorated.",
            );
          }
          other.descriptor = element.descriptor;
        } else {
          if (_hasDecorators(element)) {
            if (_hasDecorators(other)) {
              throw new ReferenceError(
                "Decorators can't be placed on different accessors with for " +
                  "the same property (" +
                  element.key +
                  ").",
              );
            }
            other.decorators = element.decorators;
          }
          _coalesceGetterSetter(element, other);
        }
      } else {
        newElements.push(element);
      }
    }

    return newElements;
  }

  function _hasDecorators(element /*: ElementDescriptor */) /*: boolean */ {
    return element.decorators && element.decorators.length;
  }

  function _isDataDescriptor(desc /*: PropertyDescriptor */) /*: boolean */ {
    return (
      desc !== undefined &&
      !(desc.value === undefined && desc.writable === undefined)
    );
  }

  function _optionalCallableProperty /*::<T>*/(
    obj /*: T */,
    name /*: $Keys<T> */,
  ) /*: ?Function */ {
    var value = obj[name];
    if (value !== undefined && typeof value !== "function") {
      throw new TypeError("Expected '" + name + "' to be a function");
    }
    return value;
  }

`;
helpers.classPrivateMethodGet = helper("7.1.6")`
  import assertClassBrand from "assertClassBrand";
  export default function _classPrivateMethodGet(receiver, privateSet, fn) {
    assertClassBrand(privateSet, receiver);
    return fn;
  }
`;
helpers.checkPrivateRedeclaration = helper("7.14.1")`
  export default function _checkPrivateRedeclaration(obj, privateCollection) {
    if (privateCollection.has(obj)) {
      throw new TypeError("Cannot initialize the same private elements twice on an object");
    }
  }
`;
helpers.classPrivateFieldInitSpec = helper("7.14.1")`
  import checkPrivateRedeclaration from "checkPrivateRedeclaration";

  export default function _classPrivateFieldInitSpec(obj, privateMap, value) {
    checkPrivateRedeclaration(obj, privateMap);
    privateMap.set(obj, value);
  }
`;
helpers.classPrivateMethodInitSpec = helper("7.14.1")`
  import checkPrivateRedeclaration from "checkPrivateRedeclaration";

  export default function _classPrivateMethodInitSpec(obj, privateSet) {
    checkPrivateRedeclaration(obj, privateSet);
    privateSet.add(obj);
  }
`;
{
  helpers.classPrivateMethodSet = helper("7.1.6")`
    export default function _classPrivateMethodSet() {
      throw new TypeError("attempted to reassign private method");
    }
  `;
}
helpers.identity = helper("7.17.0")`
  export default function _identity(x) {
    return x;
  }
`;
helpers.nullishReceiverError = helper("7.22.6")`
  export default function _nullishReceiverError(r) {
    throw new TypeError("Cannot set property of null or undefined.");
  }
`;

//# sourceMappingURL=helpers.js.map
