Studio.(Impossible de r√©tablir cette extension.}Ce SDK d'extension ne sera pas install√©. Planifiez les modifications des SDK d'extension s√©par√©ment des autres extensions.%Cette extension n'est pas install√©e.Restauration de {0}T√©l√©chargement de {0}T√©l√©chargement termin√©Installation de {0}D√©sinstallation de {0}Restauration de {0}...Installation de {0}...Modification de {0}...D√©sinstallation de {0}...Restauration de {0}¬†:Installation de {0}¬†:D√©sinstallation de {0}¬†:Modification de {0}¬†:Restauration des changements√âchec de RevertUninstall
{0}_L'instance d'installation {0} a √©t√© trouv√©e mais pas dans un √©tat permettant son lancement.nL'instance du programme d'installation {0} n√©cessite un red√©marrage. Red√©marrez l'ordinateur et r√©essayez.QImpossible d'obtenir l'instance du programme d'installation pour le chemin¬†: {0}Ü/skuName non sp√©cifi√©. Quand /appidInstallPath est sp√©cifi√©, vous devez √©galement sp√©cifier /appidName, /skuName et /skuVersion.â/skuVersion non sp√©cifi√©. Quand /appidInstallPath est sp√©cifi√©, vous devez √©galement sp√©cifier /appidName, /skuName et /skuVersion.ÜImpossible de d√©terminer l'action. Vous devez sp√©cifier un chemin d'installation VSIX ou l'argument de ligne de commande /uninstall.√âchec de la d√©sinstallationÆ√âchec de la d√©sinstallation de '{0}' pour le produit s√©lectionn√©. Pour plus d'informations, cliquez sur le lien du journal d'installation au bas de la bo√Æte de dialogue.⁄La d√©sinstallation de ¬´{0}¬ª n‚Äôa pas r√©ussi pour le produit s√©lectionn√© et n‚Äôa pas √©t√© d√©sinstall√©e. Pour plus d'informations, cliquez sur le lien du journal d'installation au bas de la bo√Æte de dialogue.D√©sinstallation effectu√©e¢'{0}' a √©t√© correctement d√©sinstall√©. Fermez et red√©marrez toutes les instances ouvertes des applications ci-dessous pour que les changements prennent effet.%Le pr√©requis sp√©cifi√© n'existe pas3La version sp√©cifi√©e du pr√©requis est non valideOLa version sp√©cifi√©e du pr√©requis ne correspond pas √† la version install√©e5Cette extension contient des pr√©requis introuvables.)Mise √† jour de la configuration pour {0}¸Utilisation¬†: VSIXInstaller.exe [/quiet] [/norepair] [/admin] [/prerequisitesRequired] [/force] [/instanceIds:ID_instance] [/appIdInstallPath:Chemin_SKU_install√©] [/appIdName:Nom_installation_cible] [/skuName:nom /skuVersion:version] [/logFile:nom_fichier] </uninstall:ID_vsix | /downgrade:ID_vsix | chemin_vsix>

    - OPTIONS -

/quiet
Supprime l'IU (interface utilisateur). La forme abr√©g√©e est '/q'.

/norepair
D√©sactive la prise en charge de la r√©paration du programme d'installation de VSIX et force l'√©chec de ce programme quand l'extension est d√©j√† install√©e. La forme abr√©g√©e est '/nr'.

/admin
L'extension est install√©e √† l'emplacement des extensions d'administration. La forme abr√©g√©e est '/a'.

/prerequisitesRequired
Installe l'extension uniquement sur les instances o√π TOUS les pr√©requis sont respect√©s. La forme abr√©g√©e est '/p'.

/force
Autorise le remplacement des fichiers. Cette option est uniquement disponible pour l'installation d'une extension 'par ordinateur'. La forme abr√©g√©e est '/f'.

/shutdownprocesses
Force l'arr√™t des processus de blocage quand l'IU est en cours de suppression. La forme abr√©g√©e est '/sp'.

/noextensionpack
D√©sactive la d√©compression du pack d'extension. La forme abr√©g√©e est '/noep'.

/appIdInstallPath:<Chemin_SKU_install√©>
Chemin d'installation du SKU (produit) √† cibler pour l'installation. Si cette option est sp√©cifi√©e, /appName, /skuName et 
/skuVersion doivent √©galement √™tre sp√©cifi√©s.

/appIdName:<nom>
Nom de l'application sur laquelle effectuer l'installation ou la d√©sinstallation. Par exemple¬†: VS, Blend, etc.

/skuName:<nom>
Nom du SKU sur lequel installer ou d√©sinstaller l'extension. √Ä utiliser avec /skuVersion. Valeurs valides¬†:
- Enterprise - (Visual Studio Enterprise Edition)
- Ultimate - (Visual Studio Ultimate Edition)
- Premium - (Visual Stubits must be added. */

    var finalBlock = forge.util.createBuffer();
    finalBlock.putBytes(_input.bytes());

    // compute remaining size to be digested (include message length size)
    var remaining = (
      md.fullMessageLength[md.fullMessageLength.length - 1] +
      md.messageLengthSize);

    // add padding for overflow blockSize - overflow
    // _padding starts with 1 byte with first bit is set (byte value 128), then
    // there may be up to (blockSize - 1) other pad bytes
    var overflow = remaining & (md.blockLength - 1);
    finalBlock.putBytes(_padding.substr(0, md.blockLength - overflow));

    // serialize message length in bits in little-endian order; since length
    // is stored in bytes we multiply by 8 and add carry
    var bits, carry = 0;
    for(var i = md.fullMessageLength.length - 1; i >= 0; --i) {
      bits = md.fullMessageLength[i] * 8 + carry;
      carry = (bits / 0x100000000) >>> 0;
      finalBlock.putInt32Le(bits >>> 0);
    }

    var s2 = {
      h0: _state.h0,
      h1: _state.h1,
      h2: _state.h2,
      h3: _state.h3
    };
    _update(s2, _w, finalBlock);
    var rval = forge.util.createBuffer();
    rval.putInt32Le(s2.h0);
    rval.putInt32Le(s2.h1);
    rval.putInt32Le(s2.h2);
    rval.putInt32Le(s2.h3);
    return rval;
  };

  return md;
};

// padding, constant tables for calculating md5
var _padding = null;
var _g = null;
var _r = null;
var _k = null;
var _initialized = false;

/**
 * Initializes the constant tables.
 */
function _init() {
  // create padding
  _padding = String.fromCharCode(128);
  _padding += forge.util.fillString(String.fromCharCode(0x00), 64);

  // g values
  _g = [
    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
    1, 6, 11, 0, 5, 10, 15, 4, 9, 14, 3, 8, 13, 2, 7, 12,
    5, 8, 11, 14, 1, 4, 7, 10, 13, 0, 3, 6, 9, 12, 15, 2,
    0, 7, 14, 5, 12, 3, 10, 1, 8, 15, 6, 13, 4, 11, 2, 9];

  // rounds table
  _r = [
    7, 12, 17, 22,  7, 12, 17, 22,  7, 12, 17, 22,  7, 12, 17, 22,
    5,  9, 14, 20,  5,  9, 14, 20,  5,  9, 14, 20,  5,  9, 14, 20,
    4, 11, 16, 23,  4, 11, 16, 23,  4, 11, 16, 23,  4, 11, 16, 23,
    6, 10, 15, 21,  6, 10, 15, 21,  6, 10, 15, 21,  6, 10, 15, 21];

  // get the result of abs(sin(i + 1)) as a 32-bit integer
  _k = new Array(64);
  for(var i = 0; i < 64; ++i) {
    _k[i] = Math.floor(Math.abs(Math.sin(i + 1)) * 0x100000000);
  }

  // now initialized
  _initialized = true;
}

/**
 * Updates an MD5 state with the given byte buffer.
 *
 * @param s the MD5 state to update.
 * @param w the array to use to store words.
 * @param bytes the byte buffer to update with.
 */
function _update(s, w, bytes) {
  // consume 512 bit (64 byte) chunks
  var t, a, b, c, d, f, r, i;
  var len = bytes.length();
  while(len >= 64) {
    // initialize hash value for this chunk
    a = s.h0;
    b = s.h1;
    c = s.h2;
    d = s.h3;

    // round 1
    for(i = 0; i < 16; ++i) {
      w[i] = bytes.getInt32Le();
      f = d ^ (b & (c ^ d));
      t = (a + f + _k[i] + w[i]);
      r = _r[i];
      a = d;
      d = c;
      c = b;
      b += (t << r) | (t >>> (32 - r));
    }
    // round 2
    for(; i < 32; ++i) {
      f = c ^ (d & (b ^ c));
      t = (a + f + _k[i] + w[_g[i]]);
      r = _r[i];
      a = d;
      d = c;
      c = b;
      b += (t << r) | (t >>> (32 - r));
    }
    // round 3
    for(; i < 48; ++i) {
      f = b ^ c ^ d;
      t = (a + f + _k[i] + w[_g[i]]);
      r = _r[i];
      a = d;
      d = c;
      c = b;
      b += (t << r) | (t >>> (32 - r));
    }
    // round 4
    for(; i < 64; ++i) {
      f = c ^ (b | ~d);
      t = (a + f + _k[i] + w[_g[i]]);
      r = _r[i];
      a = d;
      d = c;
      c = b;
      b += (t << r) | (t >>> (32 - r));
    }

    // update hash state
    s.h0 = (s.h0 + a) | 0;
    s.h1 = (s.h1 + b) | 0;
    s.h2 = (s.h2 + c) | 0;
    s.h3 = (s.h3 + d) | 0;

    len -= 64;
  }
}
